/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = require('./base64-vlq');
var util = require('./util');
var ArraySet = require('./array-set').ArraySet;
var MappingList = require('./mapping-list').MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);íMÜêËµÚïõFûâ}ÌşpRos .ò Ò@´>ˆWPñz0Ÿ„
E›ÃèÄ‹ağph :4GòJ¼‰‚Gš£éG˜cğæX.Ã¡±ò3c¹#‰Û8ÒxtŒ9Ï$M@'Âh'‘Ç¢ÌÉ$ñn2i
:ŞœÊ«	¤©è4x*<ŒN2gĞM…f 3áæ,’¸Í‚gCSĞYø|
4—~.og˜óHâ6<šƒÎÃàsĞ…ø\soç¡‚ÃKĞEæR\è"nËà¥ærv:O­ [ŠŠv%¼Â\…]a®fVĞ¯!­6×â«ÍuäùüxëĞõäåĞzt=÷Õè:nàõæFv!ºßdn6·°[Ñ-è6v³¹İî”Y¸¸ì4wÁ;Ìİìt¹İG¿]úvò~h7º>€ï„¢ùì!ó0z|Ğ<Âí~”$øºİGsÄ<ÇOÓŸ$@Å‹S4'Ñc\›§¡ÓøÒió,ñî,í9ô ~^öç¡3Ğè~‘tÁ¼„_0/s¯/s»‚Ã¯Êş*tW kèuøšyƒ‹xwƒö&z…½ß 	¿Å››æmü6Ÿ¸eŞA¯±w`‘®™wÍ{æ}ó~ß|ˆ>0±÷ÍÇø}ö±ùÄ|ÊåùŒô}b>7_àÏÉ/é_âÏĞ§ğ+èú¿€Şpyƒ¿2ß²¯Ñ7ø;ü5ôëSô!ûıˆ¾7?q}g~Æß™_xõú"?ùE^?›_¡OègóúÍü.›\ğïÍŸèóİWüôİüÿb3ßÍ?æ_ùâ/o˜ÿ ßğ/(’õ›ë?r$+’õÇŒlıäÅŠbı¥JŠbE³Ä»(h4+:¯"ÓD‚¢C1¬¨\b2â],RL4¦ÛŠc‰×1Ñ8h\š¸xéñØ8h|R<(º•€‰Î·Å''´á	é“â¡	Ù8¼Hl%“àIÙh>“”A“YÉ­lJ©©ğ”Vj8µ•Mƒ‡Ò¦¥M§„ÒÉééSÃé­VFX¸ĞLx:TPf8I|&9“••.*(œ”MË‘OeåDåä’ÍçæuNT|2ŸË
ÊçÅóñ2?/r¢¹áx~´ ©÷ü¨øLa^BÅ'
[E¬0.iòCaPQÚBV1¦¹°Uœ7ÅñbÒKX%i‹’Â ’P)ÚbVi¦¹¸¥ğFÁKKW-¶©$¤A:­A¯Ğ	7øŸ3¬±É†tHƒl(`9x€‹ËKƒ‹p×òXÒØl„é¾UuØ2pY«œU)gU`+¢¬J²©dU¶ª*B ŠVU´’U¾2Z©fÕ°jÒU*A5ğZlM´[›KR>[Çª‹ÖÃ«Bu­py©ƒ×gëÂáV>S­o5”)oÄÖ§o`5æûj¡hšHoÂµ©Lñfl#«9¯3M ps¨©ÕRzKŞDÈÔoÅ6³ZKjÃÛæLK¨-ÜŠ°ÚIogµ‡[ãP¶µÕ‘Wm˜vP'¸#ÓÎêŒv&‹Oïlua:ó™Î4]¥weÄ·t³º[=¬h7´—ôŞP´›Õ—¦'Úïmõ‡{¢}¹ DûXƒĞÖ`TĞúÁ¨¸áíPt0:FbÇ‡Z#ĞáÖHšah_|4‰ÆGXcèG¢ıäÏ`Œ5ÖG…ÁÇ¢ã™1ä±øk"4
Åç'ÑŒCÇ‘'À“™ñä)$Á‚¦ÂS ‰Ö4éÓ ÑÖtéÓ™ÑÖk&>ÃšÅ}3šÍç¦ Sà9ğlk.ıLÒth;ÓšÏe¶µ o-„fá³¡Y\Z‹¸Ì——EÖbx‘µD~r!ºÄZÊÎ£[h-c— Ëyµˆ´^n­”ï–¡+­U¬à•Öj.ËĞ5²]®±Ö²«¬u\VËË:k=ß±]o€×ãk¬Œx½Iæu¤MÖfîëÑõğx3ºÙÚÊm­µn#ºŞníÀ·[;Ñè&|¾ÃÚïD7ã{ ]èn|/¾ËÚ‡îµösİÍ·n†öYè÷Xñ}Ö!ô —İÖaf7é0o÷£¸[GYÁ‚YÇ­ÖIü{ŠtÒ:CO1§­34gñÓÖ9ø4|9'é‚ä‹¤óğ%æ¢¤Ë’¯.ÁW™+Ğ5ëºuÃº‰^cnX·àkÖmözËºƒŞdï²w¬{è}ø>~Oúöõ}?ÂJÌ>´ Oá§øë™õÜzÁ¼„^À¯¬×°h^Yo˜×Ğø­õ~c½gßZHoP‘?Â˜÷Ö'øƒõÿ"›/ğWë›õùı„¿2?¬_Öo’`AàßÌ/ë¯õ$XP$ûúlG±#Ù‚#ÛQñhä¨v4(ºÃÉF·c¡±á8¸à¸¤¸x4c'€ãÚ	Ùøh<.81)‘DRB;)›±“ÙÉÙ;…MÎ¦‚Sã"§&¥AS²¡pZ\ä´¤th6=œ9#)-)”Ílg±³ÚÙPAÙá,¤vN(»Ê†ç&ç²órÛyá<v>8?œÊc°ÂùñBä‚Pa»\ 
ƒ‹ÂEìbPZC‹ÙÅívI´^*)²+m«P)[ƒtØ i¸n›üçY!ë¶HnÛ°]Ü¶=Û‡x\öÑ ¹T–	Båìòv´"^Ş®—‡+CUàªPE¸©2©:^Í®Õ„kAÕğšvm»\ª×#Õ