'use strict';

const fs = require('fs');
const sysPath = require('path');
const { promisify } = require('util');

let fsevents;
try {
  fsevents = require('fsevents');
} catch (error) {
  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);
}

if (fsevents) {
  // TODO: real check
  const mtch = process.version.match(/v(\d+)\.(\d+)/);
  if (mtch && mtch[1] && mtch[2]) {
    const maj = Number.parseInt(mtch[1], 10);
    const min = Number.parseInt(mtch[2], 10);
    if (maj === 8 && min < 16) {
      fsevents = undefined;
    }
  }
}

const {
  EV_ADD,
  EV_CHANGE,
  EV_ADD_DIR,
  EV_UNLINK,
  EV_ERROR,
  STR_DATA,
  STR_END,
  FSEVENT_CREATED,
  FSEVENT_MODIFIED,
  FSEVENT_DELETED,
  FSEVENT_MOVED,
  // FSEVENT_CLONED,
  FSEVENT_UNKNOWN,
  FSEVENT_TYPE_FILE,
  FSEVENT_TYPE_DIRECTORY,
  FSEVENT_TYPE_SYMLINK,

  ROOT_GLOBSTAR,
  DIR_SUFFIX,
  DOT_SLASH,
  FUNCTION_TYPE,
  EMPTY_FN,
  IDENTITY_FN
} = require('./constants');

const Depth = (value) => isNaN(value) ? {} : {depth: value};

const stat = promisify(fs.stat);
const lstat = promisify(fs.lstat);
const realpath = promisify(fs.realpath);

const statMethods = { stat, lstat };

/**
 * @typedef {String} Path
 */

/**
 * @typedef {Object} FsEventsWatchContainer
 * @property {Set<Function>} listeners
 * @property {Function} rawEmitter
 * @property {{stop: Function}} watcher
 */

// fsevents instance helper functions
/**
 * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)
 * @type {Map<Path,FsEventsWatchContainer>}
 */
const FSEventsWatchers = new Map();

// Threshold of duplicate path prefixes at which to start
// consolidating going forward
const consolidateThreshhold = 10;

const wrongEventFlags = new Set([
  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912
]);

/**
 * Instantiates the fsevents interface
 * @param {Path} path path to be watched
 * @param {Function} callback called when fsevents is bound and ready
 * @returns {{stop: Function}} new fsevents instance
 */
const createFSEventsInstance = (path, callback) => {
  const stop = fsevents.watch(path, callback);
  return {stop};
};

/**
 * Instantiates the fsevents interface or binds listeners to an existing one covering
 * the same file tree.
 * @param {Path} path           - to be watched
 * @param {Path} realPath       - real path for symlinks
 * @param {Function} listener   - called when fsevents emits events
 * @param {Function} rawEmitter - passes data to listeners of the 'raw' event
 * @returns {Function} closer
 */
function setFSEventsListener(path, realPath, listener, rawEmitter) {
  let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;

  const parentPath = sysPath.dirname(watchPath);
  let cont = FSEventsWatchers.get(watchPath);

  // If we've accumulated a substantial number of paths that
  // could have been consolidated by watching one directory
  // above the current one, create a watcher on the parent
  // path instead, so that we do consolidate going forward.
  if (couldConsolidate(parentPath)) {
    watchPath = parentPath;
  }

  const resolvedPath = sysPath.resolve(path);
  const hasSymlink = resolvedPath !== realPath;

  const filteredListener = (fullPath, flags, info) => {
    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
    if (
      fullPath === resolvedPath ||
      !fullPath.indexOf(resolvedPath + sysPath.sep)
    ) listener(fullPath, flags, info);
  };

  // check if there is already a watcher on a parent path
  // modifies `watchPath` to the parent path when it finds a match
  let watchedParent = false;
  for (const watchedPath of FSEventsWatchers.keys()) {
    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {
      watchPath = watchedPath;
      cont = FSEventsWatchers.get(watchPath);
      watchedParent = true;
      break;
    }
  }

  if (cont || watchedParent) {
    cont.listeners.add(filteredListener);
  } else {
    cont = {
      listeners: new Set([filteredListener]),
      rawEmitter,
      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
        if (!cont.listeners.size) return;
        const info = fsevents.getInfo(fullPath, flags);
        cont.listeners.forEach(list => {
          list(fullPath, flags, info);
        });

        cont.rawEmitter(info.event, fullPath, info);
      })
    };
    FSEventsWatchers.set(watchPath, cont);
  }

  // removes this instance's listeners and closes the underlying fsevents
  // instance if there are no more listeners left
  return () => {
    const lst = cont.listeners;

    lst.delete(filteredListener);
    if (!lst.size) {
      FSEventsWatchers.delete(watchPath);
      if (cont.watcher) return cont.watcher.stop().then(() => {
        cont.rawEmitter = cont.watcher = undefined;
        Object.freeze(cont);
      });
    }
  };
}

// Decide whether or not we should start a new higher-level
// parent watcher
const couldConsolidate = (path) => {
  let count = 0;
  for (const watchPath of FSEventsWatchers.keys()) {
    if (watchPath.indexOf(path) === 0) {
      count++;
      if (count >= consolidateThreshhold) {
        return true;
      }
    }
  }

  return false;
};

// returns boolean indicating whether fsevents can be used
const canUse = () => fsevents && FSEventsWatchers.size < 128;

// determines subdirectory traversal levels from root to path
const calcDepth = (path, root) => {
  let i = 0;
  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;
  return i;
};

// returns boolean indicating whether the fsevents' event info has the same type
// as the one returned by fs.stat
const sameTypes = (info, stats) => (
  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||
  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||
  info.type === FSEVENT_TYPE_FILE && stats.isFile()
)

/**
 * @mixin
 */
class FsEventsHandler {

/**
 * @param {import('../index').FSWatcher} fsw
 */
constructor(fsw) {
  this.fsw = fsw;
}
checkIgnored(path, stats) {
  const ipaths = this.fsw._ignoredPaths;
  if (this.fsw._isIgnored(path, stats)) {
    ipaths.add(path);
    if (stats && stats.isDirectory()) {
      ipaths.add(path + ROOT_GLOBSTAR);
    }
    return true;
  }

  ipaths.delete(path);
  ipaths.delete(path + ROOT_GLOBSTAR);
}

addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
  const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;
  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);
}

async checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
  try {
    const stats = await stat(path)
    if (this.fsw.closed) return;
    if (sameTypes(info, stats)) {
      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
    } else {
      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
    }
  } catch (error) {
    if (error.code === 'EACCES') {
      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
    } else {
      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
    }
  }
}

handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {
  if (this.fsw.closed || this.checkIgnored(path)) return;

  if (event === EV_UNLINK) {
    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY
    // suppress unlink events on never before seen files
    if (isDirectory || watchedDir.has(item)) {
      this.fsw._remove(parent, item, isDirectory);
    }
  } else {
    if (event === EV_ADD) {
      // track new directories
      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);

      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
        // push symlinks back to the top of the stack to get handled
        const curDepth = opts.depth === undefined ?
          undefined : calcDepth(fullPath, realPath) + 1;
        return this._addToFsEvents(path, false, true, curDepth);
      }

      // track new paths
      // (other than symlinks being followed, which will be tracked soon)
      this.fsw._getWatchedDir(parent).add(item);
    }
    /**
     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}
     */
    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
    this.fsw._emit(eventName, path);
    if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);
  }
}

/**
 * Handle symlinks encountered during directory scan
 * @param {String} watchPath  - file/dir path to be watched with fsevents
 * @param {String} realPath   - real path (in case of symlinks)
 * @param {Function} transform  - path transformer
 * @param {Function} globFilter - path filter in case a glob pattern was provided
 * @returns {Function} closer for the watcher instance
*/
_watchWithFsEvents(watchPath, realPath, transform, globFilter) {
  if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;
  const opts = this.fsw.options;
  const watchCallback = async (fullPath, flags, info) => {
    if (this.fsw.closed) return;
    if (
      opts.depth !== undefined &&
      calcDepth(fullPath, realPath) > opts.depth
    ) return;
    const path = transform(sysPath.join(
      watchPath, sysPath.relative(watchPath, fullPath)
    ));
    if (globFilter && !globFilter(path)) return;
    // ensure directories are tracked
    const parent = sysPath.dirname(path);
    const item = sysPath.basename(path);
    const watchedDir = this.fsw._getWatchedDir(
      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent
    );

    // correct for wrong events emitted
    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
      if (typeof opts.ignored === FUNCTION_TYPE) {
        let stats;
        try {
          stats = await stat(path);
        } catch (error) {}
        if (this.fsw.closed) return;
        if (this.checkIgnored(path, stats)) return;
        if (sameTypes(info, stats)) {
          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
        } else {
          this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
        }
      } else {
        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
    } else {
      switch (info.event) {
      case FSEVENT_CREATED:
      case FSEVENT_MODIFIED:
        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
      case FSEVENT_DELETED:
      case FSEVENT_MOVED:
        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
    }
  };

  const closer = setFSEventsListener(
    watchPath,
    realPath,
    watchCallback,
    this.fsw._emitRaw
  );

  this.fsw._emitReady();
  return closer;
}

/**
 * Handle symlinks encountered during directory scan
 * @param {String} linkPath path to symlink
 * @param {String} fullPath absolute path to the symlink
 * @param {Function} transform pre-existing path transformer
 * @param {Number} curDepth level of subdirectories traversed to where symlink is
 * @returns {Promise<void>}
 */
async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {
  // don't follow the same symlink more than once
  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;

  this.fsw._symlinkPaths.set(fullPath, true);
  this.fsw._incrReadyCount();

  try {
    const linkTarget = await realpath(linkPath);
    if (this.fsw.closed) return;
    if (this.fsw._isIgnored(linkTarget)) {
      return this.fsw._emitReady();
    }

    this.fsw._incrReadyCount();

    // add the linkTarget for watching with a wrapper for transform
    // that causes emitted paths to incorporate the link's path
    this._addToFsEvents(linkTarget || linkPath, (path) => {
      let aliasedPath = linkPath;
      if (linkTarget && linkTarget !== DOT_SLASH) {
        aliasedPath = path.replace(linkTarget, linkPath);
      } else if (path !== DOT_SLASH) {
        aliasedPath = sysPath.join(linkPath, path);
      }
      return transform(aliasedPath);
    }, false, curDepth);
  } catch(error) {
    if (this.fsw._handleError(error)) {
      return thiGìé¯šüá'øÄ?½ù3Ñ—	ş”şHÖ‚±}ük;(ì<ï»ùÎõCÑwâ¶š?&X3À$ßF0Î·øX¾a.
A|{ÃçÁí…Â‚=ò.•™äÂ•x{¤‡˜	
¾&¼ä»qLR"J.Hdşæ/„Ä²Ù<“” xóF¸bSp¢†ÛØ<“œêâ×Å8äL¢ŒÛ;²“1¿Úg$¸0–NOuñë‚\æñx,™ò…Tæªø•°µJ>ÛQÅòWñó¿P0c%¿ÊégğV-ßåŸF$ğµ7Ær‚1Ë/[P‚¥@Ï½NE:X‚óïùXC‚ŠgpïÁ~nœÍ¿Zœü·–ur.ÿX(ÌÿÎì0şBÅ·„ ÁÊÅªxñinAŠÍXä:Bˆ^Çßb$ù D&]~,‹lÏÏaçø¹"Ïf¦B	Lª(¼×7>¾–`_{Äª¨&Á÷ùîáv½Âö»Ş-#t_¥¤Aÿ÷ËJQó2 ¿‚t÷·ğ|À‰€ñxÖ°{£¦Aÿ©î?–UÕ¢GzËMYŠ	¿s#7®ÖĞ©øO>Ÿ·rßP8°IèQlòÛ´•1ÃŒÛù¥*.eªg´ò	*~fÌ1şÊUq¨q¹ñ8¿\ˆ+6=îËD7™†Ù*ö5m6şêÆ¬±¦É¯áW750İ
İ$ôxúºn•±¾XnŠŠqã¹©*Æãë×G0_
— Ä½}›be¬»0YÅXÿeaªŠñx.n>¯pñ¸¯ÑßÙ2oxÌÖ†ü³nƒĞß©òt]WšİÉ„ÖúÎ”s£9‡¹_¢Ë ´¥Xºü‡ãïùâë¡ı›Ùnÿ³)0ğßÌd0?ŞÔÿl#è{3•Áú–˜vò%6Cû×énoúÿÎòÁ™ÿ‹¼Ã•4Œ«³=j›à–cLË1›ğ&«;šî3SNĞ]a›:şÕ´Îh&“%¿Âæó€§ö™òò\saÿrFG4üytxy.ŸÆÓÙÊMeªÏóv½UÀØ^n
ó•é9ÿwä¡bÌ —ü9È•Ä.ùyßüGSdÌçùlc}:şO¡¢}€cùŸB%[Ë³¯§™ìgwôLÀ	=cIEpá¶¾L@r$Áş+}Ÿúv§|#û	Ãõ×êeF>Ëh¦¾[Á<äÌúoÍ	¼¯dn±¿‡˜/ğ/Ób]ò-‘ <©±"ÿ½¨ëm¾Î¿±tCİ,¾r?v›ÇfÏbŸ³ÿ°‡„×Ó	8[x=šğŸÿğ|lX¦2‹ØîO¡Fİgc0Æœ`}¸ğlT”è3“ù‰­Çİ~Äü	Ìf2Èó@^Ò²í²<—³¯Ùlv©PrªÿxÆ‚à¡äXÂGÀO~³ÜB·,Qrû˜½xUøm<ÁY€­ª<0 8‹àÇ€¯
‰ÖãÉò3s&ëÇÍQq=ö[‡;Há4ÀÙÿ>ğÏ¦ÁõL“ñõöŠ@áÏ§ÂõL‘ñõ¡p'_0UÆöÙ^,âÙ°ÇÇ™2¶G“ˆ·á%;ÌCmŸ`‚MM/ù*BÉsQ»ç£=;Ã”Ï¯æK¶Ÿ‹Ú>O`DS!ógBÏQä½YÙT\ÈæKZ_r”Œù:øVĞWj„ŒõĞ·Ú—LqûÖ¸½uÂÇí[Aûåv¢ıbmy%»GÈ1ú–ØˆlíjÀøLÂc¶ğÕg«‘½cu›@¸Âh/ò= şàï¨Á`~3ÈïƒüH ƒåÍLÇ„@¿­6ƒõ şê%èÛVÁúLØßÖ£8Ë&•/~¡~k¡À2²0ß™K…3B3 ŸàŸ‡ôò~Zü*ìóÿÚ€z q>så0v>û‡ğæÛh”Ï¹!›¸¹ğzxô­O–ü‚Æ­au*–A¾äx?Zgy+—ãÏØ	Nç&˜Ç	¾<Áaü³Â+¸sÆ¡À/–°û8O~Éæ^'ûvùqŒg—ÏeÅF¬C£?fË¯Ø¿¹¢”<PÁ“…L&Í‚ı|‘1ˆ›+ÂÄ†hjÀ9¹¹)¢›±<‘/4~ÍÎå-üŒ†WÑÔ«çäK†Il?š§íW‰ÑØ/ŸÑØ¯:¬x´ı^À
ùva?´¼ø¹™±§é¼ 
o– .<U>YÖ” è ÷uá€ïæ÷GËKo“[[_ŞYz£Ë;¹\PŞ×t’'x‚ÎŸ?nLPq@Ğu.ÇHËuü5[
,è£eª`2ÿÁ²–ÿf Œ÷ıT7À+¼øÕóûû€¼¯K>ä}…wCaüO·1¸}¼±—¢¯’å¸\“?Çµ5êT¼„3ğCwJnàÛ»SòsœÃàä/±’Ïqş†éáCx7öšî§âm€Q(ı(tˆâOK-ïå syã.AÅMå!H ä	¦9Ü>J`ŠÜÊR
•²ì‘[›GÆÂıuã†XN/üÛÁ0NƒG¾3µÈåÌŸ‰œ b¹uÔHŠ«˜>3^Õ»åo­£ ¾S0œ	äÌİ"rÁã	Şbê‘@a‡é«ÈWù[Ì_EnÌ¤N…ı|¼|…-)E˜Ô)A|¾’KŠÊ‹<Ä3)3|„ó‹liåË$àOÿf;EÙ#?œçaroc«×æ±*şÛ V_gUñC«JŞÕ(V
r&m:Bc¬¿®>ŸgĞ$ÀcÜÿ]ycà+lÉHr<ğ˜(QÎ¹Ëf3—•ÇÁøÒJ+˜x‹á5Æ nRÁhæ.‹åp>™’†&üğZÃ+Œ'Z`{Ÿ(oæVEYà§@{fŒ|İ`øS y"B“!>ßúşÂrÜ“ rÌ—Ø"ËcL/ô1¦|?1¼ŒÌ1VÜò—‘1&7~lx¡Ï1æ+şˆïç-#^Qˆd\¡Ëç·|…®¢HÉ¹ğ|>V(Ü?õŸ(o¾cŸó{(œØ*î—ú^.dÃj³äŠ|à×€‹|™ŒVÉ”ğ"W®Nš‘à<¾W®n‚Ñ-/òx¯9 òÕ€ße2ç	:Á¸½ƒÂXÿ¡1…Ë0T˜õ+œÈ¬†ñê«@°U˜Î…í*ş®Ï ìQñJa>ğw.{Î4ğ‘¢°È•OålCbC	â"¯V5±¡ÎÏ©s0»†â÷R™4f²À°^Z¬
/ˆ‚óOä» ×
uãuÀü›æ¾¨íÀ2J{?6Şø"e;ÚÖ§4³@(ÉVf‡ªx¾àÏVbGşt=ÒLi_øŠ¾‚4·ß6P Xé/÷gU0
sõ·ü›Ç ÿïÊ(ícÙ Ó‹4èoei÷×T1Ob:Øú_ĞLißøS²Ğ&Sñ}p¼a´P•…ÒKí•ûë?o0ÌPC(˜”‰ÒKïŒå€§L~ğ±ø“'£i1åßj¡´ÏD“†û ?»ÁDÌÇòFş Çx´¢oÒ·Xù5òşçûïgx¾oAŞ×Àöé`y)¹_ø¢æòÁ…¸B€Ù(¸å„¢æî*Nâğ“…ßSO¡ĞÜ™hîG#²Íøílq¡Ğ öÏ)&†m¸„P>:5ûëæŠ¹¿˜}Ïw.–„JlZÊ2·ç³Ø’BÛ’‰¨äNó“™áçÃŒûºZ4™	2pÉ€GÂå3s:SÌÔœıW4uâ¿`K	ß?[‰JnÎÔáãø<¾ˆnÿ½Èÿ0Ä§|wGá­Eåvtgºò#ø¼Qg}´•ÿ±/CŞ½ùonÃ÷]K²b¯êì¾!'0™Éh"àâì+>‹œâÂ§Ãzœ™ªà‘pÊcû ¶ N|p'˜o	(ÁÂÈƒX»Ğ÷ç> h ì§íÙ‹pú‹äÜòB{¾à‘h$àópV9Çûqˆà×€»rİ§¼AÓ ^¬¸oQ‡	ˆ[óõ)ö<©ªfïÒàN«óQ¼ïby}èA~s°X§ãÖ(¶Ô2ùQè;áfğùĞNçÏ¢–v¹‡n´À„šBp¼âgÉ•«éß	9¡çC7ŸA-¯–¯éGMÂÌ!Û¶ú£Ï–É‡£Ş	§ÃÏ‡b~?ØÏ¿Ğ^6<TŸà»ú"B«0[ı-kJ£ø7‹å²Æ0¡¯.!xÃê’¨ï›ïä;Q‡øÇáê¬Ÿâ‹¦A<yÓ°ÖU
ğ…xâ;Çc¹y\eË	tÂr[®Âb<Œ°œGç-WeÿÅ†ØA	öÂòÆòÜzÇÉ;y-
cy-î¶¢¿2ÄÓ¿aİóß°$_Ú–Ãò3Æò3À7 ğ+ò-Æò-ìz‹/ò…şn)òL
cy&§àõ²Çò¯(Œå_±•}·åTEnb,!(®?U‘›XĞ…ãgù„"÷cñõa]º“ë\›'84ø{nKİZ*¶„[¸§J©¸U­°ùªØÁU	yÀ\6ì{$ø¬Š#k×âVÜRqØ„zyN,[dÜ_QÎÕ`<ú\mãşE®”Šqÿù¬¯Šqÿ¹ª>Ü(wVÅ¸ÿgì-ãşKryêó®Qûø‹*1„'ñ(ùZÃ~™ŠOE>3öäo©ødäPCOŞıülŸ~­¡Åß§ßolDéo¡7ê@ÿ g~Gb(jüLÿQÅÅŒõŒSõEx‚g3¼Ö?Uåeƒ]w]Å?C~‘gTÜÙØ>ê˜~ŠÃ‡£.ê~RñnC™¨z+§Äw€±%£.EesÎxË"Wb×C¼¹‚Ãù§üƒáRÔWb¿0Ú#ïª8Ÿİa,cxÇÕ_ğj¸4PÉ­eãÍVÁ>($% ¢k’å€ÇcœLğZÀVáİ—éêäı Ÿr7^Ø*dd0èİWéòUÀ›4ø(àƒBÃ%èâ ùÈsAîÆG¼=ÅßìbÛª¯°‹5«˜<õö¼Uó|ËyÜ¾´Š×(ø¶ú¼–</ûäó\ğò>:Ášç[€Éûåîç)Ôó*Àšçc€Éó+‚É÷“ï3R3TM—";t;sêöç“Ó¸¿ÉrSİ¦ºõêÿ¡âÛº¢õN×ïÃc~‰ö© ß_'!ğ>ËÒåº)u*QqS