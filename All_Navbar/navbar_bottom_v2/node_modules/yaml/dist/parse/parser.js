'use strict';

var cst = require('./cst.js');
var lexer = require('./lexer.js');

function includesToken(list, type) {
    for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
            return true;
    return false;
}
function findNonEmptyIndex(list) {
    for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
            case 'space':
            case 'comment':
            case 'newline':
                break;
            default:
                return i;
        }
    }
    return -1;
}
function isFlowToken(token) {
    switch (token?.type) {
        case 'alias':
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'flow-collection':
            return true;
        default:
            return false;
    }
}
function getPrevProps(parent) {
    switch (parent.type) {
        case 'document':
            return parent.start;
        case 'block-map': {
            const it = parent.items[parent.items.length - 1];
            return it.sep ?? it.start;
        }
        case 'block-seq':
            return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
            return [];
    }
}
/** Note: May modify input array */
function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
        return [];
    let i = prev.length;
    loop: while (--i >= 0) {
        switch (prev[i].type) {
            case 'doc-start':
            case 'explicit-key-ind':
            case 'map-value-ind':
            case 'seq-item-ind':
            case 'newline':
                break loop;
        }
    }
    while (prev[++i]?.type === 'space') {
        /* loop */
    }
    return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
    if (fc.start.type === 'flow-seq-start') {
        for (const it of fc.items) {
            if (it.sep &&
                !it.value &&
                !includesToken(it.start, 'explicit-key-ind') &&
                !includesToken(it.sep, 'map-value-ind')) {
                if (it.key)
                    it.value = it.key;
                delete it.key;
                if (isFlowToken(it.value)) {
                    if (it.value.end)
                        Array.prototype.push.apply(it.value.end, it.sep);
                    else
                        it.value.end = it.sep;
                }
                else
                    Array.prototype.push.apply(it.start, it.sep);
                delete it.sep;
            }
        }
    }
}
/**
 * A YAML concrete syntax tree (CST) parser
 *
 * ```ts
 * const src: string = ...
 * for (const token of new Parser().parse(src)) {
 *   // token: Token
 * }
 * ```
 *
 * To use the parser with a user-provided lexer:
 *
 * ```ts
 * function* parse(source: string, lexer: Lexer) {
 *   const parser = new Parser()
 *   for (const lexeme of lexer.lex(source))
 *     yield* parser.next(lexeme)
 *   yield* parser.end()
 * }
 *
 * const src: string = ...
 * const lexer = new Lexer()
 * for (const token of parse(src, lexer)) {
 *   // token: Token
 * }
 * ```
 */
class Parser {
    /**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */
    constructor(onNewLine) {
        /** If true, space and sequence indicators count as indentation */
        this.atNewLine = true;
        /** If true, next token is a scalar value */
        this.atScalar = false;
        /** Current indentation level */
        this.indent = 0;
        /** Current offset since the start of parsing */
        this.offset = 0;
        /** On the same line with a block map key */
        this.onKeyLine = false;
        /** Top indicates the node that's currently being built */
        this.stack = [];
        /** The source of the current token, set in parse() */
        this.source = '';
        /** The type of the current token, set in parse() */
        this.type = '';
        // Must be defined after `next()`
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
    }
    /**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */
    *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
            this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
            yield* this.next(lexeme);
        if (!incomplete)
            yield* this.end();
    }
    /**
     * Advance the parser by the `source` of one lexical token.
     */
    *next(source) {
        this.source = source;
        if (process.env.LOG_TOKENS)
            console.log('|', cst.prettyToken(source));
        if (this.atScalar) {
            this.atScalar = false;
            yield* this.step();
            this.offset += source.length;
            return;
        }
        const type = cst.tokenType(source);
        if (!type) {
            const message = `Not a YAML token: ${source}`;
            yield* this.pop({ type: 'error', offset: this.offset, message, source });
            this.offset += source.length;
        }
        else if (type === 'scalar') {
            this.atNewLine = false;
            this.atScalar = true;
            this.type = 'scalar';
        }
        else {
            this.type = type;
            yield* this.step();
            switch (type) {
                case 'newline':
                    this.atNewLine = true;
                    this.indent = 0;
                    if (this.onNewLine)
                        this.onNewLine(this.offset + source.length);
                    break;
                case 'space':
                    if (this.atNewLine && source[0] === ' ')
                        this.indent += source.length;
                    break;
                case 'explicit-key-ind':
                case 'map-value-ind':
                case 'seq-item-ind':
                    if (this.atNewLine)
                        this.indent += source.length;
                    break;
                case 'doc-mode':
                case 'flow-error-end':
                    return;
                default:
                    this.atNewLine = false;
            }
            this.offset += source.length;
        }
    }
    /** Call at end of input to push out any remaining constructions */
    *end() {
        while (this.stack.length > 0)
            yield* this.pop();
    }
    get sourceToken() {
        const st = {
            type: this.type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
        return st;
    }
    *step() {
        const top = this.peek(1);
        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {
            while (this.stack.length > 0)
                yield* this.pop();
            this.stack.push({
                type: 'doc-end',
                offset: this.offset,
                source: this.source
            });
            return;
        }
        if (!top)
            return yield* this.stream();
        switch (top.type) {
            case 'document':
                return yield* this.document(top);
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return yield* this.scalar(top);
            case 'block-scalar':
                return yield* this.blockScalar(top);
            case 'block-map':
                return yield* this.blockMap(top);
            case 'block-seq':
                return yield* this.blockSequence(top);
            case 'flow-collection':
                return yield* this.flowCollection(top);
            case 'doc-end':
                return yield* this.documentEnd(top);
        }
        /* istanbul ignore next should not happen */
        yield* this.pop();
    }
    peek(n) {
        return this.stack[this.stack.length - n];
    }
    *pop(error) {
        const token = error ?? this.stack.pop();
        /* istanbul ignore if should not happen */
        if (!token) {
            const message = 'Tried to pop an empty stack';
            yield { type: 'error', offset: this.offset, source: '', message };
        }
        else if (this.stack.length === 0) {
            yield token;
        }
        else {
            const top = this.peek(1);
            if (token.type === 'block-scalar') {
                // Block scalars use their parent rather than header indent
                token.indent = 'indent' in top ? top.indent : 0;
            }
            else if (token.type === 'flow-collection' && top.type === 'document') {
                // Ignore all indent for top-level flow collections
                token.indent = 0;
            }
            if (token.type === 'flow-collection')
                fixFlowSeqItems(token);
            switch (top.type) {
                case 'document':
                    top.value = token;
                    break;
                case 'block-scalar':
                    top.props.push(token); // error
                    break;
                case 'block-map': {
                    const it = top.items[top.items.length - 1];
                    if (it.value) {
                        top.items.push({ start: [], key: token, sep: [] });
                        this.onKeyLine = true;
                        return;
                    }
                    else if (it.sep) {
                        it.value = token;
                    }
                    else {
                        Object.assign(it, { key: token, sep: [] });
                        this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');
                        return;
                    }
                    break;
                }
                case 'block-seq': {
                    const it = top.items[top.items.length - 1];
                    if (it.value)
                        top.items.push({ start: [], value: token });
                    else
                        it.value = token;
                    break;
                }
                case 'flow-collection': {
                    const it = top.items[top.items.length - 1];
                    if (!it || it.value)
                        top.items.push({ start: [], key: token, sep: [] });
                    else if (it.sep)
                        it.value = token;
                    else
                        Object.assign(it, { key: token, sep: [] });
                    return;
                }
                /* istanbul ignore next should not happen */
                default:
                    yield* this.pop();
                    yield* this.pop(token);
            }
            if ((top.type === 'document' ||
                top.type === 'block-map' ||
                top.type === 'block-seq') &&
                (token.type === 'block-map' || token.type === 'block-seq')) {
                const last = token.items[token.items.length - 1];
                if (last &&
                    !last.sep &&
                    !last.value &&
                    last.start.length > 0 &&
                    findNonEmptyIndex(last.start) === -1 &&
                    (token.indent === 0 ||
                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {
                    if (top.type === 'document')
                        top.end = last.start;
                    else
                        top.items.push({ start: last.start });
                    token.items.splice(-1, 1);
                }
            }
        }
    }
    *stream() {
        switch (this.type) {
            case 'directive-line':
                yield { type: 'directive', offset: this.offset, source: this.source };
                return;
            case 'byte-order-mark':
            case 'space':
            case 'comment':
            case 'newline':
                yield this.sourceToken;
                return;
            case 'doc-mode':
            case 'doc-start': {
                const doc = {
                    type: 'document',
                    offset: this.offset,
                    start: []
                };
                if (this.type === 'doc-start')
                    doc.start.push(this.sourceToken);
                this.stack.push(doc);
                return;
            }
        }
        yield {
            type: 'error',
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML stream`,
            source: this.source
        };
    }
    *document(doc) {
        if (doc.value)
            return yield* this.lineEnd(doc);
        switch (this.type) {
            case 'doc-start': {
                if (findNonEmptyIndex(doc.start) !== -1) {
                    yield* this.pop();
                    yield* this.step();
                }
                else
                    doc.start.push(this.sourceToken);
                return;
            }
            case 'anchor':
            case 'tag':
            case 'space':
            case 'comment':
            case 'newline':
                doc.start.push(this.sourceToken);
                return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
            this.stack.push(bv);
        else {
            yield {
                type: 'error',
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML document`,
                source: this.source
            };
        }
    }
    *scalar(scalar) {
        if (this.type === 'map-value-ind') {
            const prev = getPrevProps(this.peek(2));
            const start = getFirstKeyStartProps(prev);
            let sep;
            if (scalar.end) {
                sep = scalar.end;
                sep.push(this.sourceToken);
                delete scalar.end;
            }
            else
                sep = [this.sourceToken];
            const map = {
                type: 'block-map',
                offset: scalar.offset,
                indent: scalar.indent,
                items: [{ start, key: scalar, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
        }
        else
            yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
        switch (this.type) {
            case 'space':
            case 'comment':
            case 'newline':
                scalar.props.push(this.sourceToken);
                return;
            case 'scalar':
                scalar.source = this.source;
                // block-scalar source includes trailing newline
                this.atNewLine = true;
                this.indent = 0;
                if (this.onNewLine) {
                    let nl = this.source.indexOf('\n') + 1;
                    while (nl !== 0) {
                        this.onNewLine(this.offset + nl);
                        nl = this.source.indexOf('\n', nl) + 1;
                    }
                }
                yield* this.pop();
                break;
            /* istanbul ignore next should not happen */
            default:
                yield* this.pop();
                yield* this.step();
        }
    }
    *blockMap(map) {
        const it = map.items[map.items.length - 1];
        // it.sep is true-ish if pair already has key or : separator
        switch (this.type) {
            case 'newline':
                this.onKeyLine = false;
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    it.start.push(this.sourceToken);
                }
                return;
            case 'space':
            case 'comment':
                if (it.value) {
                    map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    if (this.atIndentedComment(it.start, map.indent)) {
                        const prev = map.items[map.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            map.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
        }
        if (this.indent >= map.indent) {
            const atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep;
            // For empty nodes, assign newline-separated not indented empty tokens to following node
            let start = [];
            if (atNextItem && it.sep && !it.value) {
                const nl = [];
                for (let i = 0; i < it.sep.length; ++i) {
                    const st = it.sep[i];
                    switch (st.type) {
                        case 'newline':
                            nl.push(i);
                            break;
                        case 'space':
                            break;
                        case 'comment':
                            if (st.indent > map.indent)
                                nl.length = 0;
                            break;
                        default:
                            nl.length = 0;
                    }
                }
                if (nl.length >= 2)
                    start = it.sep.splice(nl[1]);
            }
            switch (this.type) {
                case 'anchor':
                case 'tag':
                    if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        it.sep.push(this.sourceToken);
                    }
                    else {
                        it.start.push(this.sourceToken);
                    }
                    return;
                case 'explicit-key-ind':
                    if (!it.sep && !includesToken(it.start, 'explicit-key-ind')) {
                        it.start.push(this.sourceToken);
                    }
                    else if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                    }
                    else {
                        this.stack.push({
                            type: 'block-map',
                            offset: this.offset,
                            indent: this.indent,
                            items: [{ start: [this.sourceToken] }]
                        });
                    }
                    this.onKeyLine = true;
                    return;
                case 'map-value-ind':
                    if (includesToken(it.start, 'explicit-key-ind')) {
                        if (!it.sep) {
                            if (includesToken(it.start, 'newline')) {
                                Object.assign(it, { key: null, sep: [this.sourceToken] });
                            }
                            else {
                                const start = getFirstKeyStartProps(it.start);
                                this.stack.push({
                                    type: 'block-map',
                                    offset: this.offset,
                                    indent: this.indent,
                                    items: [{ start, key: null, sep: [this.sourceToken] }]
                                });
                            }
                        }
                        else if (it.value) {
                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else if (isFlowToken(it.key) &&
                            !includesToken(it.sep, 'newline')) {
                            const start = getFirstKeyStartProps(it.start);
                            const key = it.key;
                            const sep = it.sep;
                            sep.push(this.sourceToken);
                            // @ts-expect-error type guard is wrong here
                            delete it.key, delete it.sep;
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key, sep }]
                            });
                        }
                        else if (start.length > 0) {
                            // Not actually at next item
                            it.sep = it.sep.concat(start, this.sourceToken);
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    else {
                        if (!it.sep) {
                            Object.assign(it, { key: null, sep: [this.sourceToken] });
                        }
                        else if (it.value || atNextItem) {
                            map.items.push({ start, key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start: [], key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    this.onKeyLine = true;
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (atNextItem || it.value) {
                        map.items.push({ start, key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        this.stack.push(fs);
                    }
                    else {
                        Object.assign(it, { key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    return;
                }
                default: {
                    const bv = this.startBlockValue(map);
                    if (bv) {
                        if (atNextItem &&
                            bv.type !== 'block-seq' &&
                            includesToken(it.start, 'explicit-key-ind')) {
                            map.items.push({ start });
                        }
                        this.stack.push(bv);
      íü')2‡‹åÆãŸ/â Á/Q|î?TÍ6ıWzş1vû4Œ;æşÿ¼MĞiuy[»Z“íOLş6f‚¹³ÜÔJF¬À¶ ×>o	pNc{bC¥lSZ~3Ì5l¿æB·ÑºÚK«àL!Qö?IŸxø†¹#70Ä“
ğâ9âÂ˜í’ÁcõàòWñQ°r;Xeæ;Ê:d‰Yç÷¡ÖÉ¸ùMšˆ‡múïè3.$~ªvª$"ûáç%³8ˆ¤s<£óãm/£oœz#$màe7i­—<8J&lY¾cVêÜ¼ëÛ*úÍ®¿ûŸ0‚NDğ<P„êÌi ñ¢2¦Ú\›(º:ÑÑœ€n“°-	ç*±lY¢ÍçúM)e{e:ì	`I›O ¸ÏŠï
İ¢»÷Ù‚Œ"hª– Å/³+İ-•dÍ„G¨¯æ×—ÎtÖakèŒQ^´÷                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ÿBPµ/¿å`3IÊ{_CîßÙ¦Â•…†]ŞùpA€L®Uğß4×&±;¹³Æ¡V‡à¸ë2¹Ì×ëËü™²3Œ^aQoµ#Gmo¡ÚáîºŠV›ÿóÅ8éÇ¤rW_¦—aëD¶eËCÜL?ë‘>˜
ÇR®°º1¿$«Û8€¦»EP|¼Õš€Í¿¿ÑF€û¥3†wnÂ®cÃöîK6!íEŞÑ ,ê§êÓ#ŒÜ÷a1Á¾¹çu‘ŠmŞ1Şµ›ÙÑæo’Óˆ't:€Gˆ²E51¸b¼ÈiÀ5 ¢.â¿rWt°”êÁ.ğ-Äò(Æ¿z‰Á*D€ÌPĞÈyù2rÂ(C!àU HBÌÔWƒ·°{7-´ZÍCDÔ.GiÂV¬ÛõŞÃUÂïûüˆ©ûÓ¤+Dãë3Ã[İ ¹VØÚ'”•ä"	SØS|«ï‰@€øÂr
§^–<‡ä—y•qÓ&œbÊ6œœã·„Pç!kvlO0	2Ò××n§ê±ıøÒx7/€%²oÁ	ÿùàVsL*bºU‚üœ7æaé®®v’˜BŒìHÈÍÖòR4pãµéĞRŠoJ‘•W†şm“	Ñ®Şlp«9×Ãñ=2¡èùM—P‹óRÂ‘] ¯$ÖËn4åyOià@cB"ïÑ[À7¹=«J$….½¬øÀP¡ Å·Zù‰i¤çSá÷+ÏÌ.	&,"+p€ø{ã³Êè˜w¸çx¹>pé@ÑÈ5#­|°v--òF_l.ÓyÍÂ‚ŠG…s.D>Pc8ìip¥£{9² ’†$vH­zA“C7â‡©ÁÁeÛõa3ÜÑ®Às½2¡–P¦¥^‰\Q_púŒ“´{üKµÎbJO£¯)î”ó™Ÿ¸3Õ­_ONJ`Üº†÷m¸œ©¹ &ššã|‡H‘Ë=7Ï¹FW¥›å¿‡”}Dâ‹Gè*æİzü¢~+[OTğÏí2Í}!¤ıGÒ7(ñ@¾i?^Åroí÷,%ëq lëJú3nì|ÉİÎy
(µsi¯œ,O{­Ry%áW¬Ê’‹	¤TÀ÷RÖŠÃVÜ)¦_}7"qÒKõ`÷)åe,9ú`TY² 5ã”ÃÉ¯-"°Í¼µ$ğ´í4¢ÚÏR¢så»CrE_t70ıagKÑB‹
@!OlO‰ëUœ
M;.6¶Üò¹ƒÀı$é,áW+âÇ+µ+C­O½h`	³ıíİCïÃ¬pëØRféÖs°(²öó8Qù%;NE5Ğn©˜EaKPÛ6åájGŞ|—vºP™®?	f˜œ7ÏÏ8cÄuôÖ`¥ã@Ì3ˆHÍ“Â‡ôóı©š}|öCÀäÛ/¢/"C mÀ“¯æm[¯›yá0©Oıµ´ä5cÌ*è]ÊLæº†Óö‰šŞU¿òôÙµË.-îã°!ÔPEkPí`®¥ÿĞ$¨ƒÂªu0¯”pïöİ´Ş64>WøF@,N
ÜkÃtÁm²êåKó}5eÁ
7x‡bÍ±–JÒçzŞ=l˜W‰ïA.»ÃškP	Û‡mÍg–=¤c|¾¸±yPkõW‘#­®rõÿÆ—ÏúÿÜr5¾Q#rigá {İá¦·ùİ§¹µ/#-	+œö]ú»1z  pR‹íÎ(ş½Ö‹zOA°x¡òÛ}^ì(`½ÆÏ,5pÊŒY*˜x|IêDí€”pªô!ªú
c“ë¼æÄµI‹Ğ÷¯ã­éWŒ£Åš‚FöXêÎ÷.²r²‡©Œ¼–U’õêŸ»jàü× åB¿JV!ÕX)Ò-¾YûK	0Ú|,ï¡õY‹¡isvLHzüBŠ« hSyÈEIæwŒòdehÁT”/¡Qs}uEQö:ü.ÍÙõ¦ÕìİŒõPLÊ>ÁÈ±}—íë@È}éYÒÑ
ãg˜ê¦µğ0nBæä
ÿ¤º >Ä€€ÎÚ\G7
ğş,NCÏ¯óÓ0¼›”D„9Mşéõ0BÅ’8íMñ°	ùNé„ÒLP¨­‰%J¼Maƒ™Ü&¡z=âŞ®ªËáäóÉfÑù’.4oØ2ĞÁè56fÁ‡ê=s°_±-ÈD«…÷³Æ—€qÀà‡ËJ†»p~~#<’ã'Hè—|¿®‘™QëY]MÏİğ¡YØz)ğßÁ¡ kyu'hí[×0@SsÂx=®m*óÖsßÜÄYÊc¶.¨Æ@ùG±”Å+:$‹2ªÔ_”XÂeßP7Ğ3EvL^`1ja—iÜ‹èä§ËÎ\iWÜ t·•†Ú”ôO'ğd\óß4ûµc–[:o)Æ­[¸IâÍÆ©#WÙtGœ$ğ8æ"Ö‘1mi`)²í’»³¾öB"ì–úJu¶[…©O¾Bmì$ÂˆF-ŠgtÖEÙ{È]dú ¹@ş¿§åK_áğ‘•'3Ü¡uUÀkX~¦¸,£Ş[š}o üÔ•·8ô\ÁÔOc¼zêf'"Ø©½f İ|ìáh®ç¸ñ·;?â C-X1÷R‚”cm*'yM3N³‰RË"VşÅ÷®v„ÀØ‡òbÙP„¤æ·É Ù‚Æ<h¨­ÜÏZ.8"(\Ç>Æ™â`pİ%&*ÖáBpäÇEÑö,0Ì›™Ó¨<kW™”–¢*i2LıŠ¬ÆjĞtĞ¯aUsò0£zU²#Ğ†µb<6Z#‰^e$şûú»LëàT9¹l1×Š/ƒhYKã3r–/îš@®ÆN ]aÃ¢`7_**J÷ˆ%—CÇ†xªK·ÔQiIbghR|”ãŞi¡(ó4Ú*²xXÓ·€|¯>ŸÊLFm<¯ñ¸ŒEC•;
1õS{MÒ)O””©™ƒ{µiV¹ßçI#²!Á9hé­â9ò«ºt°ùãKôh·ö•Çxi-4–=Ld,ì5	£Ôh±ÏL'»éÜØF"Ô_Âm·Š|gìñéÂ@ËÌ& \êÿ $[PDEÀüş`ß]3Ÿ&uÔÉí‡²•o'=4XŞctæiÂj-$…(ÉmWĞê—ß·v2ê¾Ìí¸?Êç¹¯ÏJÍlWÙE½$\Üö£¡™C´0«û[çÔ$äV>ç¨V›AaéãSSJò‡[SÃİa¥Mæ¼äGÀqFh}Â«×#Šb[C2àëÅSØ´÷pDrš.µÜOß#Ğ·¹:ëôõJd½>Î:åz¨¼!éu¯Iñø„rDµ°×ÜÓeX?] ŒÔ0?Ws'	)¯Ëv¡c9ÑG¶F “”0ÜğÀ+™)è}ì›Í¥(_Ó€Æš¶”X ízSs¥* %­3“¯ñ\5šî?¼˜ûU3éU‘–Fät5V¦~#§.u™>qæWXá\4‹Šõb¾|÷@ÈÔ_ê>÷÷\Ò¡
!Ç9iSlæ‹²Ê ×$9œ?K6yëëqFË® ÿˆÓ+4r#®:€Û¦‹ı)Ô\ÇŞŸ2(O*=Òºs<Df%ûei,ßÿBé¬o+g¡ˆÑ£v;ú”(9x1’Íª¼ Æ³Š¢j\õ™ŒÔ]Å€Kn©@ê+$~¬£¬5NÆC.Mì0ˆadf>qäUÌjitwÎ¬ÉÏôe3ÊA¥)[c,Ô¨¸Äo ÖDœ£¬ßı0
¬ÍD|Ïnè±ŠKUğ“9›C1É°îIpº8ÊN?Un´b5Û7¾t^÷Fcş±×ëEM÷’6®æ,,»Õ²Ğø“vƒj}tn¼ê+ıÑƒ¦éP¡Å˜šn­ù1ÛO©n‘õ¿4cĞÓùñGqÜ×Åµ¢y2¸¦o«SBW=FQ)Í>D|ìs'…§‚ã•c¯Êı†[/F`e6bWeHVº8˜ÏoW0‰ìşöEi(!#ºLuøÜØIaÅy—Ù$ÖQsšá-®×eKZ'mÜœzş¯¼O_é²«Á:_Ûh u—ßé-”…àt‰#Rğåº¿¬7(Ò(&eÑK;ûa\1àíõŠ¥RFÄ}˜âIuÆ¡ˆSÿ»ušµ¶¨(‡êL ŞaØ$`&"g°fÙ×Ğ:TM(å„$!eQˆøÓo±3s$Åà\Îñº[;€ø³-vËùÔáŠ5}x²ìÒâÈ¸ûÈ½Ö¦ŞiÅäJ9ÃH£%¾Ûn%tP•?gíñ8ÑaİD:«Úë)ôœÁfµ'BúUÓReÙ1ø\‚­ï[pÌH:¥ø¬æ÷§Ø#à¤UråLÀÏõaåÚ\	+7Ö4N/ÉméIŞ;7@ñ9goß˜…†1?„ÙÇ}TÍî_¢@÷¿3ÄÜµğ¾±Ä-£¸i[?>¦±–µk¢ı	¥–IïM*wKŠöŠ… ½°p­‡?ÉxÕı9k=î"!«¢‘ˆÜÃ÷C×~fŠ¶¸Aïøóï,ãC² ònĞ8çJ—…JéÇx: ÉãéÏVëN9Ù?Ğ1óÇ6 ¥ˆæmàÕmŠŒ^I´TÚêÙñ>êÅ.õ>Qø2>0™+Iåu!äX"ÅEW±Œ§mĞÉvÓ°XÍä¹ß^ƒq]İ)H:š
ËıQ«x·Â—mé
z¡g¿3Ïå/RŞæÔ+ïV‚ƒ¶ŠÛu­ÄËÍAv?²›…M8ÛØ8ŒµÅÆJ]#©#XCÔ­Îÿš*ı\`±aì/µ´~KDXÍ^o×²<û†°×ëÅ/á¤´Q„)wô§µT8?ˆSÇŸìÉ›õ'İ°8~`oÈU€ A$\Uÿftâh‘À;³Er5lğié,œÎş·¾^ÉŠÉT¡Ã3Då¼)çƒÇâÓÈè¹Cè/á˜ĞïêæÓ ß†7"!µ\J¤.Y`¶î«È8§lÓD\VçËšŠÖSS¹[õ·¾€sbŠãóEÑZ®ËÕÖúÔÿú—>RıøÎçó^µ‰¹>Á[ÅB6ÒˆÃÎ{åP>lišÿn,à[gz6·9üÉµ'ïØì¢4MîjÑUØÿHŸzeò“(EJ;Ë1}ŠZ§hÙ^NI[NEa¿;NF:àR/¿p¬6{AŠ);È*ÉùIŒ’¹èx†+bŠw¸:L°`™röùD¼{Ğ´¡ªíª8È¶ø,Q’.&z70g¥';/£Ò	×SøŠ;(ĞDÕ¼¯ğ”Üœ•6êúQ7Ç]§2'^½Òio7®@º«5e*i?Ôiv°ši¬J™Á•æÔÿ›m|zRì:xØNº¬P@ĞÏ¯–?@“
é»2WM¡^…™Ş×ù	Í–_4,jL^§Õ€»ºşšV¨#›[$¨v˜`ÜûÑ
÷ ÊèŞ…Ò(!S¸ö:*ÓÜåê÷“ºd;ù¸¶Ó%ÄP—İÃÏ+T#‚VÒ”º	m09\ßtĞIµaˆ™2âÄAK¦àå³Së›¡Úz™­Šæ›µ*ºßÒÜˆªşê—/Ï¹´"”÷8¥ä@ïé/õ´ï~zÚ3ì++—–jÇ9Ãúkà7LuìC#HîÁ‹æ¬PßÊ´2nkÊö—Ïğ9¦è7Cx§g@N’èIşÒæşv¢IÜãäÇÖLv¹d;³îsl~+`d`©Õ+iâÏ¾ÿWß;Ö6I ×S©)í÷`ëç˜ëİğBw¸œÌû+0Õ2ñ>ó¢?’k‘ZlGm a©m/AÛö(!Hs°ã³õ4/–#±~…ğŠÆyÛÆü6“[»…@!XÍ™Ú¸ñÔ<#ü ùBÇ&1x BğÅr	‰ÔÉµ•ŒoÅƒ ß\;®ßš´uã‰‡DºåMz5ED¯n¯F„³à{“Ì°Œò©	ºÆ	ûD™ş¼CíĞ…TÍ`Îh?§GÂ¹g.m–9¼"‚f°t=jB´¤F’Sx„8×òJZm^‚ËHñ–¹Æ)ÿ¥KÎ­üÖ CAœMÉRÊ¯K\¬ëÍ:Â}˜IÏEóÙW[ê•à·…‚¤­D}'ã-Œâ˜’ÊÍÕÑÈ•õ–ÃïuÌ¸¡¾N€ÇvbæjI&+èÙA´,D†.Ff´UèOÍ
â«ÍÚ^>käxnÍŠÔ)÷Qé»®WıúE‡Ú¹|* RœdÙHÊ
æıuª²Ó9.3* ÏX@ôb¡¿•ÒÜM¤¨Æ…ÇO&b·=aù³SÈslnEiÏáôñ©Éˆ¤€!ŸQaâDÕÀ
:;±këÕö¿ôBÚJ¼?Û>×EÚ§cÁT©·ùşÒ‡§JëJr/G³p›wîZ…Ë3ÇŸL²á.F®ÃUPŸ—œı.»g¾ßğÙcPãüw—!K¸"ë&Úö‰´ß-Xkò•j¿dñw/Wë‚øL~`dèC{[ÊDt<¤ƒ2^Ú¬v$›(İ‚ƒ§~a`V0Dä;§Ú'Êw!_Z%À‘êEêaŞÀõÊ-ñ)G˜6«œŞÉê0ÃwÏ'}ÔÅ™etÙ±ë\İlneäjvBâr£ò×àô§½…­`bÆ[1×füM­z|ln_ŸuVsÑ(’OhÖÀåhãòTù#İµ/ğYuuW(óãÉ e½Î[ğ×—µˆ„¹Y±k~@ˆ¼R”@L…`Lhœ³çBPûpí`Ó:sJ}è'Q.•€a­æEşõÌj°ze-ÎYvQE¨é¬îGJº™ûúF,şğÁÒÑÆX;Äû	3ÆŠM“ô¡fğdæú[<sõ|Qu"¹qëÚ—Zá_¦ä!6¯ÅHÌŠJ=‹Í3DjÂ¤²jí¼ ùs÷GÑI€JÈ
’ÑG>Ù‘ĞıÊMd İ°ˆLTû™KŒlƒÚeÛ„XY]àÆIÔ©~?n—„No0w&r¯e@xQir:9	JâØ!yîíÚ¶3v>ÿñÜf€IïÑ§ÀÁÖT(İ’kpD*´LÄÏRNE3CØDŸş*1åÊ	Òm€‘íT¸æµÈ™P±pn¹Vd>köÔ­OàÙ¦­óìªr]é`«H•Øµ¹’ÉAE	‡¸F¤§ò]ê}”_,rilJéRÕâ ÓêËÂÁE IRP˜&UÛÚ °cvè$M89*w¸ŠàĞÏ Õ•·¶œ|0ëÈ®VÓ+_JÊº^ÄLƒœ*µ'5Ò×‡‰Ô4Hú¹'ì è°oP6s\¸¢fÊo_=&Õ¬‘‚¥õ4‹°æ$Âs<­äC	ùH“Õ$¹Ü+V}a<£Kş˜ãïƒ·Ç“Í„ÿ²&ª@n£ÀtÙ·]=èB%¼2ÿÊØÒç‘f±&ºöz™ª°ÒÒ0ÏÒ¹)HÃÔuL«æËÜé$.ÏÇÚéa)¦Ÿ(0ºÏ;Ùˆ·-}t{n‰åvõÁ	#¾2Có®€Â;?9Åm „‚+YP¿àW°&&sVşáÈBYı¿½[JäÜ+jq –šL{¦.«Cè³»ÆhàŠù –'—¯Õ_B0Ï9ÖjÍm„wÖ9—ÖRJµÉ®KœU»<SçAH¯Ñoƒñ