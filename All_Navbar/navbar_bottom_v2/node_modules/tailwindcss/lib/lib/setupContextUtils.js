"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    INTERNAL_FEATURES: function() {
        return INTERNAL_FEATURES;
    },
    isValidVariantFormatString: function() {
        return isValidVariantFormatString;
    },
    parseVariant: function() {
        return parseVariant;
    },
    getFileModifiedMap: function() {
        return getFileModifiedMap;
    },
    createContext: function() {
        return createContext;
    },
    getContext: function() {
        return getContext;
    }
});
const _fs = /*#__PURE__*/ _interop_require_default(require("fs"));
const _url = /*#__PURE__*/ _interop_require_default(require("url"));
const _postcss = /*#__PURE__*/ _interop_require_default(require("postcss"));
const _dlv = /*#__PURE__*/ _interop_require_default(require("dlv"));
const _postcssselectorparser = /*#__PURE__*/ _interop_require_default(require("postcss-selector-parser"));
const _transformThemeValue = /*#__PURE__*/ _interop_require_default(require("../util/transformThemeValue"));
const _parseObjectStyles = /*#__PURE__*/ _interop_require_default(require("../util/parseObjectStyles"));
const _prefixSelector = /*#__PURE__*/ _interop_require_default(require("../util/prefixSelector"));
const _isPlainObject = /*#__PURE__*/ _interop_require_default(require("../util/isPlainObject"));
const _escapeClassName = /*#__PURE__*/ _interop_require_default(require("../util/escapeClassName"));
const _nameClass = /*#__PURE__*/ _interop_require_wildcard(require("../util/nameClass"));
const _pluginUtils = require("../util/pluginUtils");
const _corePlugins = require("../corePlugins");
const _sharedState = /*#__PURE__*/ _interop_require_wildcard(require("./sharedState"));
const _toPath = require("../util/toPath");
const _log = /*#__PURE__*/ _interop_require_default(require("../util/log"));
const _negateValue = /*#__PURE__*/ _interop_require_default(require("../util/negateValue"));
const _isSyntacticallyValidPropertyValue = /*#__PURE__*/ _interop_require_default(require("../util/isSyntacticallyValidPropertyValue"));
const _generateRules = require("./generateRules");
const _cacheInvalidation = require("./cacheInvalidation.js");
const _offsets = require("./offsets.js");
const _featureFlags = require("../featureFlags.js");
const _formatVariantSelector = require("../util/formatVariantSelector");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const INTERNAL_FEATURES = Symbol();
const VARIANT_TYPES = {
    AddVariant: Symbol.for("ADD_VARIANT"),
    MatchVariant: Symbol.for("MATCH_VARIANT")
};
const VARIANT_INFO = {
    Base: 1 << 0,
    Dynamic: 1 << 1
};
function prefix(context, selector) {
    let prefix = context.tailwindConfig.prefix;
    return typeof prefix === "function" ? prefix(selector) : prefix + selector;
}
function normalizeOptionTypes({ type ="any" , ...options }) {
    let types = [].concat(type);
    return {
        ...options,
        types: types.map((type)=>{
            if (Array.isArray(type)) {
                return {
                    type: type[0],
                    ...type[1]
                };
            }
            return {
                type,
                preferOnConflict: false
            };
        })
    };
}
function parseVariantFormatString(input) {
    /** @type {string[]} */ let parts = [];
    // When parsing whitespace around special characters are insignificant
    // However, _inside_ of a variant they could be
    // Because the selector could look like this
    // @media { &[data-name="foo bar"] }
    // This is why we do not skip whitespace
    let current = "";
    let depth = 0;
    for(let idx = 0; idx < input.length; idx++){
        let char = input[idx];
        if (char === "\\") {
            // Escaped characters are not special
            current += "\\" + input[++idx];
        } else if (char === "{") {
            // Nested rule: start
            ++depth;
            parts.push(current.trim());
            current = "";
        } else if (char === "}") {
            // Nested rule: end
            if (--depth < 0) {
                throw new Error(`Your { and } are unbalanced.`);
            }
            parts.push(current.trim());
            current = "";
        } else {
            // Normal character
            current += char;
        }
    }
    if (current.length > 0) {
        parts.push(current.trim());
    }
    parts = parts.filter((part)=>part !== "");
    return parts;
}
function insertInto(list, value, { before =[]  } = {}) {
    before = [].concat(before);
    if (before.length <= 0) {
        list.push(value);
        return;
    }
    let idx = list.length - 1;
    for (let other of before){
        let iidx = list.indexOf(other);
        if (iidx === -1) continue;
        idx = Math.min(idx, iidx);
    }
    list.splice(idx, 0, value);
}
function parseStyles(styles) {
    if (!Array.isArray(styles)) {
        return parseStyles([
            styles
        ]);
    }
    return styles.flatMap((style)=>{
        let isNode = !Array.isArray(style) && !(0, _isPlainObject.default)(style);
        return isNode ? style : (0, _parseObjectStyles.default)(style);
    });
}
function getClasses(selector, mutate) {
    let parser = (0, _postcssselectorparser.default)((selectors)=>{
        let allClasses = [];
        if (mutate) {
            mutate(selectors);
        }
        selectors.walkClasses((classNode)=>{
            allClasses.push(classNode.value);
        });
        return allClasses;
    });
    return parser.transformSync(selector);
}
function extractCandidates(node, state = {
    containsNonOnDemandable: false
}, depth = 0) {
    let classes = [];
    // Handle normal rules
    if (node.type === "rule") {
        // Ignore everything inside a :not(...). This allows you to write code like
        // `div:not(.foo)`. If `.foo` is never found in your code, then we used to
        // not generated it. But now we will ignore everything inside a `:not`, so
        // that it still gets generated.
        function ignoreNot(selectors) {
            selectors.walkPseudos((pseudo)=>{
                if (pseudo.value === ":not") {
                    pseudo.remove();
                }
            });
        }
        for (let selector of node.selectors){
            let classCandidates = getClasses(selector, ignoreNot);
            // At least one of the selectors contains non-"on-demandable" candidates.
            if (classCandidates.length === 0) {
                state.containsNonOnDemandable = true;
            }
            for (let classCandidate of classCandidates){
                classes.push(classCandidate);
            }
        }
    } else if (node.type === "atrule") {
        node.walkRules((rule)=>{
            for (let classCandidate of rule.selectors.flatMap((selector)=>getClasses(selector))){
                classes.push(classCandidate);
            }
        });
    }
    if (depth === 0) {
        return [
            state.containsNonOnDemandable || classes.length === 0,
            classes
        ];
    }
    return classes;
}
function withIdentifiers(styles) {
    return parseStyles(styles).flatMap((node)=>{
        let nodeMap = new Map();
        let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node);
        // If this isn't "on-demandable", assign it a universal candidate to always include it.
        if (containsNonOnDemandableSelectors) {
            candidates.unshift(_sharedState.NOT_ON_DEMAND);
        }
        // However, it could be that it also contains "on-demandable" candidates.
        // E.g.: `span, .foo {}`, in that case it should still be possible to use
        // `@apply foo` for example.
        return candidates.map((c)=>{
            if (!nodeMap.has(node)) {
                nodeMap.set(node, node);
            }
            return [
                c,
                nodeMap.get(node)
            ];
        });
    });
}
function isValidVariantFormatString(format) {
    return format.startsWith("@") || format.includes("&");
}
function parseVariant(variant) {
    variant = variant.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
    let fns = parseVariantFormatString(variant).map((str)=>{
        if (!str.startsWith("@")) {
            return ({ format  })=>format(str);
        }
        let [, name, params] = /@(\S*)( .+|[({].*)?/g.exec(str);
        var _params_trim;
        return ({ wrap  })=>{
            return wrap(_postcss.default.atRule({
                name,
                params: (_params_trim = params === null || params === void 0 ? void 0 : params.trim()) !== null && _params_trim !== void 0 ? _params_trim : ""
            }));
        };
    }).reverse();
    return (api)=>{
        for (let fn of fns){
            fn(api);
        }
    };
}
/**
 *
 * @param {any} tailwindConfig
 * @param {any} context
 * @param {object} param2
 * @param {Offsets} param2.offsets
 */ function buildPluginApi(tailwindConfig, context, { variantList , variantMap , offsets , classList  }) {
    function getConfigValue(path, defaultValue) {
        return path ? (0, _dlv.default)(tailwindConfig, path, defaultValue) : tailwindConfig;
    }
    function applyConfiguredPrefix(selector) {
        return (0, _prefixSelector.default)(tailwindConfig.prefix, selector);
    }
    function prefixIdentifier(identifier, options) {
        if (identifier === _sharedState.NOT_ON_DEMAND) {
            return _sharedState.NOT_ON_DEMAND;
        }
        if (!options.respectPrefix) {
            return identifier;
        }
        return context.tailwindConfig.prefix + identifier;
    }
    function resolveThemeValue(path, defaultValue, opts = {}) {
        let parts = (0, _toPath.toPath)(path);
        let value = getConfigValue([
            "theme",
            ...parts
        ], defaultValue);
        return (0, _transformThemeValue.default)(parts[0])(value, opts);
    }
    let variantIdentifier = 0;
    let api = {
        postcss: _postcss.default,
        prefix: applyConfiguredPrefix,
        e: _escapeClassName.default,
        config: getConfigValue,
        theme: resolveThemeValue,
        corePlugins: (path)=>{
            if (Array.isArray(tailwindConfig.corePlugins)) {
                return tailwindConfig.corePlugins.includes(path);
            }
            return getConfigValue([
                "corePlugins",
                path
            ], true);
        },
        variants: ()=>{
            // Preserved for backwards compatibility but not used in v3.0+
            return [];
        },
        addBase (base) {
            for (let [identifier, rule] of withIdentifiers(base)){
                let prefixedIdentifier = prefix¿Æ×ôú½}|}v ñôƒx«>o~M;­¿Ã›äÔ×û³	yB]Ê¼örÄLÔÛ÷öùx?é·öQ¦ì³#Ì½]õMqßsïáŸŸ½8Lûüì@üôRÆFÁ¾¶ı(.û±İ4´?aşı¯ß{]ıu÷Ïp¼ïÿ!àOtş?±*°#ìÏá:œ~A57¦”)ŞGí âòæ›ìîÏ)EøüØ¯şv‹`ÿˆß@ã°–©ûò=–$;G3€÷wğ/à;r@¨¿,~üsĞßÆö¼`@=óCD”ššÉlTØá~Ğ´¾B’Ÿ¹„í&†záêt!®_Æ¸Pˆ|Vè‹Ã÷‚@|§ïzrÜ‘ç!ô×“@¾rrò<Ânã ¹ô¯ßht:IÁ÷½­üïı"šù4‹ÚX¹²€=é ºàE9Ùµ|§ø#,a@ÿ gê€åÀë¾\G½~û÷ƒ>öSü·Ÿ~Ê÷6ÛÁÏ oQ„‚>Qƒİ [~l xñ>òúÿ# g:Î#ğ‹vµÂÓŠ¦İÿÄíû×Ÿ"hà¿İ?ÃuBÿßâü{§\æßc{ìä‘È¯ûÜö€œÎ›ğ+;µ¿‡¾îÆñ_§ö-Øß~Äÿ)0l”BJ÷7ã¸gÆ=‚çq¹§øùX$òÇš"ï£Äº‘Ş?2k*£ÿ`WœJMÍ`ÃNÛç2_”ñdÍ2j„@ a¢“5ôä½Ú!ïÇúiæP×ïêvÈ/(ŞÂùÉ)œó›„zş=¤çPßeD´¯82åUÄ[¿E%ñÏ#’.4dÂFqoOù˜ÚAû?íà°1<Öøbu­ûkjBÁÿÕµÃñ7·uÇ©1¸iã9fîoñËïù hÃj‰Ãa®‡ÈûÏKâŸ	*-®“ùE¢ 'ü÷m[„~üm§Èÿü÷m“r%qükû÷aŞEv¨[…ë;û¥‹tÏ.˜:çŸıñş®¯ÖçÀçe
3çŸÏ?ÿm]gri¢pÿX·î™D[ò<ÿõ5ğ‡ÜZÇóô=êŞ½5ÌÓäK‰ÃÆ	y‹ÍF¥İfÃóQâ7§ ~B<CĞğ»-!p£Õ8›Ş„ßÍe°7‰;ñŠ—¨$g	’ŸºÅ@MH2Ê (WÅù˜_/N#¿D-vØó³2Ùp7Y˜Ÿ•ÅJìQf¬¿«ã¿íËË[©yF"ÉkNA¿NÍEœÎ˜©ğ„øíàG|¸‡7c~Ú¾6ûpzxlú‹Õøİ;¾Ì%©¬ƒrdd¤Éæ>i—ßÏ¿ç0ìƒ<>è5Wj+=÷2t>uCÿwo/]šŒß¯·.	ÓØ˜šÕj¾ÂïKÒ›R³èwzø>ÑŞŠï±¾´‹“ñ»“S?\s ï´‚ù§£ö¡Òá½íÔb6ÀuÃU„ú<õ~í~¸¯!öd±Ğ®ÒŠıwI–ÒûÄaÀ÷Ø*VD¿kÛNöĞïı^îßã ß±¹ÕB»d­síÄ€ãğö©8Ë¡¢uPµ«<üÂ™Õ˜òÑá¬gFóÚl÷i=añû·Œ¦Ô0¼>©QÑïfègØë¨Åq¥]ñô;
F'§ûì÷îÃ}²Óù—Œh¨mYÑº¤yíÎêŸÈÇ&VGÔøö&Q(22ğûAJAÒçj•ZÁ*|ÏÈ{‰ó¹gÌˆïjC{MÚ•Ãî°Ï›—ı“¾‡ñ£—4Ñ÷¹ø½[ö¤<œ›òbuÈè”axşŸå,¾ |‡‡ßse‘yÖ—&çù]ôû@~KW+ın×•R“ŠúçÉ¼yó#Zrr2¾?º/ñ¹wÉ~R¾o ğËá:›?7¦†â{è´£l×KîË(¸:Ù¯ñ~s zæÉ8Ï¾‘ï/ÿÙnRú¿[#ş÷Ú;…ï…÷İ8¿pî!'ˆÌ“ûk]8·.¡2T)—PÆ¦”P¦4=†íRš&Û§|òM¿ûÇ?,¼WÍ½jFBzåÀÑÆfìøŸt†fd¬dí,‘@¼pfàyæ2ß‘e'«/áuV{õÃp{²z¶s8XünìÆ™…ş¼Ä‰ı3˜^&;’ÑTı‘ì7½ÙæŸû¿ğÏHA|€ÏÀ_ë×½œ™:/ğ}Â°ƒ7SjŞÊ€qâLíkCB=•ë<ÿq&¶“‹4yy)Œáa(ş ÿ¥K—²:Ö=ôÜÙIÜoğ*"àúóÛÕ¿ãòìÇÍò¿ıä|~™=ùçùÓğ|9=¿¸Gş¿ÆÿóQ\™šMñ÷ãé—5®½,ÈÔI¼'¥ß.ş×}ün™©öã†Q§ÑîvöÆ"^ËšßúˆòÄ£&_lzcÏCÀ??Ïhª	ÅïqÁO/A¼Ş;ğŸSé„ëÇGFBÈÿ?ü÷îEébD’Œ”yÌ›UşGÒ…ï¿‰ôøŒo‡ûø~˜İ–L¿ÿ{×¿àÏqLêó§øŸâ“É¿ëí%>ÌíşIûá‹ÿ7œp¼NŞ@&ıı?ø7#‡í§ö²ä?ğÀ¤ü÷q?ûòÛµWARü„ï—“ıü@ùïßíä_ğÿ)øŸÓq2@#–·Â8NÄÅ™yAcufFŞRöÉ>"‚çlY=ù¿ÇW oÄ¦Ô¬Í¢ïg×†â5åI*c>ò_‡	ö4õÁ>R¨]d4Óï8"Vÿ'ü1?È ¿·õÙyØ¿ÏƒSXƒÑhhMÇsåšğÌÌLõ/!Pâ{ÛcòœÛyy¹	\ëçğÓğ7ıßWO~/Ø(èm£ßïwRÿüˆ'ı¶ÅÏßÿËÏıß
ï¥ù±ŸâõŒ]ğ7ú]â¤¤öÏU 'Î3vC¢òãŸíoÿÑğ{ÀEø¾‡
ß­Sÿsr|ú<E¸ô+qMúñOå?ñŸ´*±ß.a¼j\;õ8c\½;<ãò"ŠÃ[{	ò.\W‡xV+2 ı©Â{ÚE5Õc!î\¤qPXê)Ô¨V#è—a>òéäüB{ºn–ˆ¢ºü¿· KğûzãcğÂœ6ø¼ÈYÔ§jÛëÛ‚‚sræÛ,åôwMtWÓÆ…¬÷}]ÅÂ1ëÆUh6‹âuä1Û¦íß¥¦Îg·Ó9êlæÊğûŞT6/§òªT¶p}¿ 1\O›mR
ı–uci+ç¬˜wÚ,*5öÙ^°`Ş‡ïmP.2Ğü*Ğf#¡_Ç,:¿MFóG‹Íë ç—†nü}ÌWK¯“MÉş~ÖÉñğÜÛfsl÷·7Â|j¸ÆˆH„û#Èhÿüt<œ§Üâ Ùoà÷ìM=ÑöÉ5Na|Í_Åâ“NlW
ûÇ¼Éfãy˜æ‘Ğ<qÓ¦ßÑõƒËûÉ(«qàs}bµ„î_1qòe'Ä<¼N¤ó¦²6å¦©;Ê©‰ÕÕtŸÉN:ŸÂæp€¿2o(â­ø>g•bxÜ¿ÿ|–øcg[®Ogj¼rÔ0·è_ï^™abG¼wL™ùA9ÖB?Îë¬Å<Ôëœñ>JgÔx&æN§fñwx[™Ğş°ãO(5ûöâwONgÎfPIê7¯\™ÿsgağ<Äá8_PÀ©›ØnYl7èTëğÚ{K=e¬W§ùÔƒm»ğ»y6Î©×ÓçQúgğ;ú6'ıõ¶Å‡åæ®R«5z\ßaïk§èzÛötRéí¤òso]×`˜^t¼ƒ^B0OV({Ìvåæë×k„v>Ï¾§ãµÂy`½
ÊÃçEô;/X"mïÓM7)ñ~Ûß„õƒ>òh½§P‘ÿÔÎ{K¯‡ı,ÆóNaaÙÂøzıd»Ü\ÌûÿyıÓş±m3uT?ÍÂïœN±Aè/èÏ+ìkdAJ&ëlS„5n†úšÈh}´ĞÍj]†¯›¾¨ôÎÂ[—ù;ÿ¸9İ§¹«%^‡Ãs±35LfÚOÊFßÁôÎâ…`÷z=Œ²¬ì—÷ÇM÷5/éXísõassàÉX¬ÿ'ûÃó¨¬â0ÚØñV6\«u¼u™öŸiËE© œÍ³úë™ıK_Feâ¤,+ÃvÙl›œ×ƒıD\9Ì§†éˆ %Ì«U,æ@æáxx­saa^™MLpúÄòù·&@	ûI¤í`şñì'Õ±àßöæÀÎ“xnáß—Ûá:P…ó·—ø¥CvÇäµ0Ã19>ÊxÅ"îŸë~ŸâæÇÏñş(¶'$|°ÏŸ^ã¼“í"æ8OöçÈ,p_ÉŠQZÄuçTÚh´§qÍ™„xE)rÊnEZÒ•s:
éÍ3±º µÚ“¸c*QµÈV«-iı1IŒ¢l@~ff<û‰‚Q6Ë,Q\Kšëñ¹ÌÇrb?­Ë>wCAÎÅÄ³øñÈé§w‘Qõ™„‰CSÍ­2.Æ"67ãx‘}°ÖQì”ÆZ»’3aI?›ó³×ŞvZ¥e$Îk†uGZÄ½ı1ZFvc‡k6¬CQŸyÖQ7 ~áLÌ\V¡˜ÙPèôÅXåæÉ}âRÇ>'zå;Ü¿Šë®»ª‚ş;ää« ŠqMû“
ØÿªÑU3ø!‘âtüìÅŸ)bNãüêXØ‡æâT‚íƒä
•Û%ò
ÅŸ4sf~½OYºJíõj?\;šß,
ã'¨~ˆwÈ…ëÜ›Áø4gôjµÛ]x ø‹GVFöµß‚ıƒŞõ
øR§PœRµÊ,1ÖÒ]±t~õ.èº[­½[T_õãşÕ°×ãñú0Å^×l-#WÈ~Kûï-ÛLçÕ4À<·”·`¿ëTÜ2%*îËŞõ­2o”µ»n}³Ìª¶~™¶¾Eæ´v§]€}ÂªJË¼1å¤—÷Ü»íƒúâãOlù¶î¨Çªâ^’¯?Lû÷·ÊgmK/ÄÌe~vUÜ,ƒv‡dÅíÛÚŠCÛO'ÎeÕªP‚Ïß¯#dıaOI\ùÁÊ9gô^¸)ƒù½°ºqÍGH(	…yq]0®'¦üPzq›çvÂ¶Cõçbæ;N³—8=ëÔ\ëRlŸ2’Òµ¾]6ë¬ß{6Áf{P¢Ôò*‘ô³Îª¨ê-ióÆ•ÙëõÄÀz/ÌŒW‹ R.éøËñ±°_Ê~RÒ"óàşÇ5g0DTX‚ó[?†ıÎ­?”~5q1CŞß¯*>êÙ¨*°àş‡qÿ GÏ¬ònºÿÿrØÉúĞ¯bMšùípNWq¨¾¨İóÅœòîŞ«ğ¼á5;QêËƒ}\³Uë×\Òa^†úpŒÚşvl7èãQÿ°ÿ>Øô¿æ·Âş·#~°¾:Ø?èûƒZô/©ƒ¨aëPÿ\»gP[ñA_	H]ÅWé^Èpµ°nÄ/õ¯?ğã_ı½³Ê[z×ƒã@ÿÀ{`}%ÿ…}ˆ!õ‚Ş Îû{â`r™\ë)^ÈJ _ìï‚ıÒ¿©Æ‰´ªw^J°m!öqË¥„±1	Úü}¡çE?„uxèühOå-ufè7«|Mâv$ƒùaÿk¶£ãíúnDEÆmé’ø$^©ÿôİé×½µ Orñj¯R­†ó…ÙI¤ôÛ*ì×I÷Mñn©+FûçZîï=İwÎ£Û	ìŸµ×†“õ ÿ+'» öœuL$‡qƒØxXÇÌxæM2ÍEñ ½ƒ}[caÿW‚9.#¥°ÿÛj®jû‰ˆÏgˆøoº·ËÚç¬–éÏèE]ÉÖfÙ°ZÀaØ?ÿ`\ØÿQÔã¡ô¸Àô_U×ˆoıú£°NkØèAl"Wcâ™ äMÔ[KİÕDĞÿö~rôü}‘ø÷ãƒü²N°7ªğ·ÒJ¨~vøã>àšê¿ƒÎ²¶ö£“7Ÿ&%´]•õÔwğùUà_ò3 ş°^ÄQ[qÖÏO}KÈ½Ë¿!!¤z ½£ĞŞ@ŞDz +ğ8èOã’Š	ê3^ATÂz ¿“ú0§­ œ¨ş·…\{œ2x•İ{èU‚ËIõØªˆo>+t}1îî^¾ÿ€;åÜl°OÑê Ôúò™š;To¥û\L÷ÏEâ:K"á~I‹°ÿ’Ã~½´ _ Uê‹€ÖÁ»Îêì„·]Ib‰ZL=’]Eû:(’—´z¬QÖCàghï‚k+¾po1I7‰è/=Ó’7|šÕ`¯SÍãšfô{Ñª€Mî®¿‘_ÏàËHz‰ÿ¨7wåËu¸ÿŠ¿°ÿy°ÿ’£× `İkÒ!¾°„©¼ ¼}&q¬ıi+º8Î¯º¨ıÃşÓÁo5„’ıø÷"/Â>ë°}”µ5İoõˆ{,®ãñxæAéº q|tXEĞŞ$ÌˆK½|·xÖµ¸âÄ‘mÛKšeƒjìûĞUTÕ£ÿ|½ÖãÅøı/ì³¸ùµ…úÙí‚‚şú;=TçŸŸÚ'Ø?µC°ÿtĞ';ÍÍØoQ¨˜«°._Ò~ÉÄ'ªÃ.C‘ÏÁm¿ğøì4B2¾±?@ÚÛ=º„²¨4ôÃ„uõJÍê„óÛ#KÁ?›ø2I2¬Û÷WUÿZÀçM"ş&_İîy¨ÍşmHDvìüùüğ`Ñ;à§åQµ4> S^´4 ?áş‘Ç`ÿÇ¸Šª>À‹=ü31)?ì‰šc­ìE!v=â`'v‚øóßíw=.ã#K¢e~N‡ı‚ÿ/ĞıŒ|)wˆ	ğ‚eNù—u˜OÑw}.Ø©DÒeıGZ-Kq]±~ık+Öô!NwÜ.#ğ¹5êŸ¼_‡óLâ¡³ZŠ8¿@H2ìí˜>Gü×·ÉÊ»İçà9Oˆê]®U¡Ş;—îI¸¿§”{/çÏxÿ‚ì…ÙĞ	|Dõs¨í¨uµÄQ–TBíîÌ…q—Œ†\…xLH5Æ¿Á9€sñÛ8ÿ¶`Ü‡ßaİõh'ßIİØò0BŒübõÓõÛdÅïx ı¢~ğh_ÕwôâĞ«„¸UÕ‡|†~‰¼›<³¶_¦oOˆ‰£ğ‰¹L˜äGœhÚÎ'ˆ—àƒàğ­gÔÉä¿*âĞ}üÀ HµHÿÍ ÕÃg"îÿÄÄ¿Çäş37à«ª~Ì;tkúOŒæ7)¶ßÕ„ëWëø‰ÅÉÇßöèbVŸ87C¤‰;eºØÕF™şl"ï¥ÀüàG­?àşã*ZŒhÿ”_h¾!ğA\yÕvØßêE¯¯©;˜„ß_Za]Lô€]r.ö	X×õ°^õ é"‚_ƒ¿©´ôwîş‡„x]qFæI°V-Eüc¬­i4¾b^tXf‰{8£Å¿g ‡ñØŞnò¢?>/\Õ¼—'Ûaÿ'ÕãıˆŸ¨‡8àê÷À[ãúOÏ‘HyVâ§Òî#ùB‹ùâqÙíˆ›˜Ç\v³Šb§Ÿ ¾>CÈLXÿ­˜úîZ®ôÀ™/âºcá¹ÏpVONíM.zÇs;ÖĞ‡ñi¾]•|o ;O1U‘¤Ôÿµœ!näu·m)ês–•Îù‹•Gÿ×Ë»E“ç2Õ<ùS{À'€·{ï{İrú+ogª¸ÃÁ·b¹Êóç@/Œ!ÿâş?^ñ7õ·É»\Âşi|¶ÄT|YÇçâÊ^H^æõc'">™Aê'ì'"NÏ¸I’øqÍ3:…H!Ÿ¼4áÁC<[7‡æÇ§°rÿÀÿaßÀƒ-(o£İ£ğ¼Hûçpÿ ÿ&Ğbá;[±ÖmõÜqÔËÁ‚ş»ké~q]mái–Lˆ¬búd¾‰< øÔ ÜnÏ©h¹€öÉYh\@n“­‹³VÕ•Ğz¬Uşï·§ ó' |í¼Ûöƒë¤ù´€Ú/Í‹7Şƒz	ó"’@¾ùz‹ë³ñùØÇĞ|øqjÅ<µŠâ_N$vô{uyUpqKxIÌ¶C!Åmá%±\U&æçº
ƒÛê”FZ£¤XÇ‰IéAàBîæ7Üƒ:n‚«	ILrÿÃãšÕú>qä à›èvqéE‡ÛOÊôó×ö.Nb4Z	àt±©‹$Ï×ŸÑmœh˜ïšù8[Û-"ı³YŞÓ“È6Ë‰±°]v+®¼ò«p_[[…qóÊÚâV%ª¾[Êµ"/UÊ)Ïwñï¸ü¯¥uäPoü%iÈe'ë"¾núNñò´ß†~< ùo³ì6è±ìõî@=Å¢{,àuÜÛ[€Û¯1.Ûç¢¿R?Çq Ÿã ğÌÓ½€˜Hò?ğºÔê{Vyk½â$©O À¿ğÇ>Ğë:Àâw<ëÚŒx	Äûxæ·ƒ-´N´r¸Şu‘\+Ú©GÅİ4Ã5¬›òö=·Õˆ/­7+ëè~H0Í'§ÊÈ9¨¯İî{b¨cÕÄ>FëÅ‚÷ 7…úš×Æ”Wö‚ÎÚÖ’V|ô|ÁA^vuˆî´â´Â
ûUsæ^g@O‡‘7Áş1ÿƒùÑŸİÃ›ˆLß¡wØ’Â'¼;•8FõæEe["ôíó=íO¯‹®‹Ğ›uı?n¼'[pVÏ—}_†ñvâ×„˜Ûd\,gşµğÊ!!hsŒà¯C}İJùöß‡ó«*ZÜˆ»Ë>DÂ5ÈÿÏ÷É4g·ÜyA5®¿špAÜæ>jËn=+j¹şŒ>húà?&ÍN´tÿßÑı³ñz1æO%˜—#¿Æ•S|oGq¨ßxö¥-r2®¹¦‡r’Œ—A];vì—%42ú‡8|ıoø¾ß£]ÑúÖãêÃ¸-&ò=X_è@oà÷Ø
.ã7ğÈ-è¯ø0ò@òÂ íR°ƒîUß‡H0?>pö×ßËÅ"!Ÿn©âxß÷Şüì²ÏoÏ!ãî³úø¤ô.«lU3oó	õ?àFó«Ê^äÓX¨Ÿÿ’(keÍ+è_§u(£Ê×¤—´€^¬•Kñ<"’«D;VA¾e= +ÁzçŸx“P»â¿‡¸=S«VÁ\Ïã‰ÂñıÆ¼,E©y6¡LO~ìçeíÉwŸ|æ/½jû’i<°Ù¢mJuË“0 w‚î[M]ïÜÈ™âœX·rÁµ§½CjÕÿ«ŸYN¸À‰°é6É1¾+Q;¾õ#½èY¹À·n_ÿ:¿~m)_H”`$˜
ù?àr+n[woÑñpØçÂ¥%tÿĞÿa_Å´ş@= >«ÒÆÏ|”àè—œ×ü5
è%‘êğÁø[n û÷¾;yÎÑRç—½Xßû¦ĞxÆÏ§õÎ«(Ûòb×8wV÷Å@h	­ß_JG>ÁúÏâÒ«0N9DrÈïdƒsËõ*gußÈ™áqÍÕÿÆï¨)~àç8ïìo…º”ú?]o¥Q©Ás„¿‡`|ID©¿~¨I¼ß^è9HäV«Ûıq…@?±¼ÁµP^4¢ ¿¡=À:ÍnŒ/‘å•u«>o¾ITD8¯à?õŸCÃúô­äod\ÿá“¯×®Ô_Kôz‰C©¹š V{İŠÖ<n ÉL¸şì“^q¬‚¼Pÿå"™ş`”Ã qxô&ªSúº.¼ğôj¢lZßÔÏß˜Øàjòzğú	·bÿø¡OÔ¼ÿÇFGp™ƒk¬Şäşv[Á¥Ç·~œ@â‰œ“­>fK4Zƒ5¼ë‡ã˜ï _õÂ¾Án»ûÆ©~\vˆlŠD„çj·c¸/Óº ®eI—d|è!~,}\óIT¤}È¾6Àêõ¾ğÈø™³Oúbò>æOÅ4o ¿Ô¿àuÂùVÆ[ÌïëÆgŞø,y¦UVt„üvÏ¥ş“&ö]ÆáÒâùÂ¢M"ş6ã®bò äç\_	ÍªÒ't¯BÜXÃmKÇx‹v×‚<ù Ô£>à±Ù0Nu˜
yG÷¡n×ÈïmDû¸ş(ä“-i.Z·O¬§’ÜZqçGş$Có½rni1ÆG®*İßè<hÇÈójäfô÷Ê:Ä]D^ÿÑÿ˜W'í¾²nø1é›>³ïw:k¼â¢b¼§õÉÚÕcÏ\³ƒ~ç2*ğcİLÒÏ£_¦ˆ]’ñ­İQ$L”¸±^æmLßÑsÁ¡
‚4G±>bƒî&ayÄ}O—û«ñ7?Ñ³|Ğ–ñVÀ„ÿn]C°µ1½qÊ†Fépmz{ê¦YYMÁİšJCÆ·7ĞÂºKb(Ÿ#íóÍ¹¤¿²·ÄÜ¾ö±”›2±¶`ı»­ù7Š«Z:Ğ­ÉÜ³]<oüÌåLdÒ¥£Wşäüúoèlş¸ü“M\!"ByÈ_Oİ÷û:‡JšÆAFÏ‘Üb2Şy6±Ï+;Ï>‰ß—•´Ën¾uEg~:äzó«aà÷€»EÏ!@½v”òµ+•ê±fÙ-¨£Ò9zÂÉŠé¼Uµ8ÿ#È_ôœÀ,¥vJóÁù] W|ÒL¤óFvø{?_CÜâ šUÎ…ÓsÜª`áœ¤¥â?Ìø·ÈJ"q\ÿ×àsÈ[×¤]Ğ>È¹€ÕË´îLÄ¿ŸW\KàÇˆıú‘ç÷hëåZ÷Ï}Å°˜,Qv~˜4f“/Ä`4|Îñ8;yêºé`}nãƒ Á@?æ‡ù·VÏÜÛçp£=„é'Î­«—zÒwœü×5¤·/ü¡}{*Èu‹ÚS7ÖVæ^š|õ‰ÑÚz*ÿ¢ş‚
âôRòCÈÃË[Ò/¨âÁ™®œsvş7¶oÆğü=âİúV¬g«Ò•ú¤1­Ü¸:3È÷”]2~æ\¢ÜA@^I<A2È…§“Ñ8yEÈªhÜW#îÍø>`M?JŒ«ˆÛ,ğ‹A¿4ßO°Bü[6ødùKéÜ=·ç–§,…:»dnyÌv¸L¨°¤û–Õ)ìQ[À>fğ>"üm;ïÖr´n]y»ÌûÇ-¥y‘P1¥v1Ì_|ëŞ¦ñì¢ÏËÙÄSBş£‡Jß•8—I><Aq_“^Lı¿*ß¿èy7âàÂ4:¿üaˆ+	»›¬ŠğÎ w	Ü×Øû0c|hÂó—ñì3:qŠç]àÿ%E(¹~°¬ÊÙA®ï^]­‹s¿¶¡^æ©_)w¯«—Yj÷¬<Ó7AzÓOœ_×(lÈEœ¥^°‹Á>."î%ıøŸ8oˆoºI–‘çëd}-´ómãS!oK”ñÄúºÇªüA¢,]ÿºl8ª¢¥ìÏA—º&ÿóhàÉ
.¤#ğóæDş]>kôa'?¤çµ¥š‰/‘®q=Y$Ï–oˆø¼ybˆïG~HÇ|ğF=Oš{ÿ©ò„JŒÀ× …ü+Mºë¬nQù/S#Ìİº¾±'Z\P<8€¼~Éô”Ì)·Ôaık+İ\j~Ïq¸JFñşÅºÄˆïçÈq³˜ÃÂ¼Bİ/±Ó8N&fûùùÊãå•õ~ÿMçè{ sÿy"Œş»¦_¸à]xîê yÅj˜'ÍŒu÷ä>Ê+¥Jı§OêµD5Ş~6‘‚xKãeÆCğò´—b@¦)B>Q™Æ	zé¾×–H7UÊ<»Ò»Ç·º4rr³V¹uÛrâØ×Ö{w-Úô2Ş'$‘_W<Ø~×¸zêÓ/¹Àÿkø{jÚ¥g^PY´@$2½+ö‡Z±íî§Œoı A~
ş¾Q‰ï;x8•µjû¤}‚±C‘d2ùÃªQM¬ËÎoñ³y/½©tÔùÌû²péf¸èÿã®ÒÑ©¥øÅå}£U—Éì‹X&Ä¿âV!îñRZ,ğ@p'µOÚÁª€<Ÿ$-3 ß/Îø¤. !¤ˆû£ìöÓÖÅ!®ÅsÙ_)~ò>°“‰I¬oPK»©Äzó2:ò	Ï2ö{¼¼q=ô*ğ›Mç­€ü­ÅsğÇ}7Ïdg²Xİßw Ú±à÷`Ï0'ğDš`·{'×ïÇë„A´‡½µ	ì•Ş7c»ÛØNÈ#Ùvs+CÈ;x?-?ù„kÏiÕ!DtáÅÆ6x¿ızÇy™áÍmˆŠµÔŞ‹Nô\ØúóŸÜvbµ~êvä=u~¯ióŞmfå+=N·»ÕêŞÿ›ÍŠéLìéß¶•M|‰q'Úf²ûãÂƒk¤ß¾XpñåUƒM gİ¿‚ˆ nZğıÊäş÷~Ò¶eHxï,ıƒ5¢±t4¬ô²ğİ¥£ûJß
¾¼§tôU+Üßm…ûoıâ2<µôD\¸`[ø|<Ç}b¦z£ï×È”†3:Ã™Îà~zæ‚<-IMÀ¿ƒÕy½‘³Ã+ÏÎ¿÷ç©ÿíŠ"hâ:àç§ì©g‹¢~ÍFåÎ³‰¶-vz_A¼zWªÒÀß¸9ÜÒÓ¿e¢¥ï‰­\:æ¹ôBıÅo’dÌkÕ•nÀ¿D]ş‰8p•õÜaÌ[Í½Ê9À>oºbŸê½NùâØÁŠ³¿_ ç“÷›©Ğómğ¾·ªXÂµúíÖ¡âÀÁîõ°cª›`ô¼Â`ÌXyÁ<2¾õªğÙş_Ïõ÷¹1l`!ìkKâòéÄıŒæ1(W¦_ÿ`	©%ıíÖ/ğı^û;2ıœuÑÒwŞ~{ÕzëÇ¯ÕÕÙÅQä/e«”Ï|ŞöÃæQï§ÒáÍ3-Öçf¥~âx<	ß ş,a\ş:Ç¿ÿ:ßœÎÈ®;Éê~¿j`à†/psçI"&ÒëèCˆCéèŒÒ·¬{¬£Ö?´E4Â}+ø?ØÁë¥ï×G4•úàùÿ½²oôó&Ÿü÷7P?*ôª_”+óŞ$% GÈÓpŞdB¿xl®üxêÂ9ÛÖà{æVƒyØ:5·h©‹~'@È†€UMCıŸy]“ïÿ¿8èo~Ûs+ôo~ÇsknÅ™+~.óÔk ïøxöKQcùÀˆ–~ç¡.ßæF¿,¯J+ü°ñŠ±®	ù¾˜S±f»à·K0Ÿ|„[Ó‡y>´æèùXådÜI£uHèw;®b•ÚŠÊŞ"ßªc<ÖıñêxB¿S|ì@ğaÿDØ?Øê“kOò¥$ğ·¾h©xŞ¿*âË}üÒ›¶ââgjñøÀÇV""Šñ·^†²—ÔmØğyB,^Äq2I˜Ò=pisÇ‹ã—ŒÉ¿Í¸~PNFÈ¹Wjñ]È— şdyÆùğš×Ië£EÙ.r‡mîì4hUã‹K	ÜÜt„0„­üy`ªõ°y`wé[i7 ÿ¿¾ß
¼p‚âÿpé‰´=k¢³<¼¸ÆÍ"2¯·ÖæT(x>`[Ç‚²ø19~ö~d‰©¨ªÜµåÓmùš`3~ÏQş^/-¬øÜLß¿ÚIôÆ«ˆo‚İVö"õßí¿íoG–¯©çœXG˜¬7¶öºÿqBè{,òÈWL<[œB4”Gc¿ØŠ…éhWÜ¤ùÿmÌ{9ú~yÌ?ğšÓ»¡vKıçOI¼5@Ïô|A«Õ#€½˜hß*løW˜Üâ^ç¶0Ä­+zü½8â¼Y	v0ZY0RgøæÉòƒèÆÅ‹Œ<™h/Ü8ùÌ›ñU•£nàF'O’OŞZíıFx¦³³F¤)ğùArüß¼Iömº_ÜÑºÕiŠ?Dç ^[ï&Š mgõú-bûÑ¢ˆ&îÀÛ3«³“øá]ˆW˜whW…owñËûÀÏw–¾%Ÿ]–ÅVñÌŠ•)#[·%fÛ¶DS9667Ÿ?ÿ.×…9õc"~÷ğeÓŠ›mWĞrµÛqƒ;ğó&ş‡µ38|¯\±°ñÜ{ûcâò;XÔ†¸G… ^Ÿ–?-G;ğçK ïÕPƒß[WãwìŸc$b<Nò½0¡şÿ½‡!Ş9·ÍF×ãñlW-Ãàxx®ó£]¥!îülï±ÄUşS¾H˜Ÿ<M„<íÀşkîxßŒõô§ñ ìæ¡y<‡qÔĞ£ùŸ™Ú¯
ñ>@ß£Ë€‡nÇZ·á¹6ó ¡vÉ‚_ÛWExš¤-ØAÂ˜ŞÎŒo=·@‹ß\ÿ«p“İ¸v¯'o~øKç·ˆ³„xJ/^¼È^$"=Hæ¢ˆÜ8÷ºƒtÙ{î¼8áP‰ß‹VE7<(Rj§^F Oƒ|è?º,†ão9ä/7ËN§GÌ.Í`Õ¶=ö]A;÷¡,'7¿Ü9ºKG‹ùí5¾š¦sµ;_ş‡lqàæ˜¢ÍÚù*xŞNX©gz½…•8¤ódkb²mÙüì$îs)Â/\±~ãÇ¦½d>.ûBk-é×&±Ùú€ZWbãI¦ç£ß§Kä4)ç‚!®[Ğ¿?%·PÆùëx·T”±İj7ò·ÚïQ`\‹Ÿ¯[d<ŸïÇs,]Á¸â«“KĞŞ¢¬‹Ò…üœú9Ø—¿Ï¹Wy òÿ÷<‡ï½*èüØ^ö ı»ôïØ^Å-ìğ,İ|û-ìë‡üùN˜àº£„üìú·x,‘0.ö_Tº¨´¸Mv{–uqº×pu7X0»¾¥-7÷¯İŠä Ó\}R¯`Dİ™UUÓqÍş×>ø¥Ã¹™5œµrlúë¢~?uı%óoÒHÉ¹·V¶E+ò.µÅw¯¿?]5r©03à«OäW!©Ñ.OÕì«Øœ=÷Å99ÁÛ¦ñİŸÕú~9ßNn÷í
ú¯ùD’’´£V¹½Á5:m{£r{£«}Z]£2¤átÖôõ(w|²³AùrãéÌO^Æû]£Ó·7(ÃÏÅ_£íÏmúä`^~˜/ZâùïpÓÔëĞ¿¾ÁÕnZ±_'é_ı™rÁYxx0Á•¤eì—#å’yàø~ËÈ¡~ÊR¿ùÏNbº2ˆâø‘ÁÈÑ<ÂPWüºÀÃx¾g‹´‡)¹3ºüÿ·U©ùëI	‘8ò ½Kˆ™~ßh‚¾oëèøü\j?ÇúT¨|ñÅ±R*øñcõåwC_ı0˜¿ª_Ø_tû-ZŠöq¿¯xˆ„^éìfêŒæz!N,”a¼’`p ñ},ı$\+lwn·|Ò¯"=Ñ:‘†ıâ}¨Ã}Ü¢,òŸ4Óó©O½CóÀÈîÒSÓWòmaFÄªĞ‘½·¢›ûh—dÜíšÍC¯|ß'ÜU8cæşR›î4´üF¦Ğ^øtyş=eÇ„ë›–ZŸ2–(xoànÀßÇûvù¸/ÆHÕİç>løÎÁØGào|·#n;”çtÓ@6×\öj=â¿cà¾»ş\Ö´™BÖ(‘“Øşt(ÚË”]]íÓ^Æqº.M{¹åè4iÕ´¢y¤WêSrÏæ¿-»ı+ŒÓÇ)/J¹VWA®ÖB^UtXˆÿıø>ÉË“üÑU3§)Âx] ¸àw):+êW>•Ì Ş|IE´D©¹ŞÇêBñÿæÛ–Î`¤qƒ3Ã|às#Góˆ3ã™1k‘İŠ‚ºØ|Ø³zV…%SşXà<cèõÎ.ØËK¡«,*ø;sĞEÈAßÉÆ÷_-<êñDnx)ƒÖùFbÄñÀÿëÍ­8¹®òA-¹Ld:ôÆÑ'[ğn”Øx§Ûü¥†TOtüÅOäsrL¹à=çñLBY|%‰Pœˆ†Xòç‡gÏ~6È®¯nOğM}ÖòòÜÇä!üÜèŠçÊ­Uú.rœÈî“d„/õ]¸´ñÆŠ9¾Ôÿ²O¸ ×Ğ]]Ó¢
™¿»	©Ş¥|p2Mƒë!/ïR5v]2U7*Ãê»Ae€àÒxşÑ5®Ñé¯Ö*CëçÊ©Øø ¬¶kí!¤ötüºeĞ®Ó™¦:Š{;â?¥¡kÓ5Ê0¿oAÌê>şØM¥ş¹
"µKÁ_JR;™SısTÿeà§–¸òÇdş-a[¥´¿"zò†~?Ö¯7c×Lìßğ™+ìòôk1ùŸWÍNe5¸1_Œ„x€v ¸ç0?&óxäyÈCÑğï¢Q»ƒDŞ|Ô8.L‡uÜÒV@û¡77Ëş¦µv§YeEš¡áÏúŞH{D.:M¿?€õ·x¸Yåæ`°ˆO¿Àã ¬NVE|ÑO†,è÷6½»vüÅn=q8^P©y‘¬«‘®s,Ú!9÷Ül–(Fõã‡¯édì?"r®ÿ%D!òî~H›H<7ÁÿŸâõäo'G³s=ÿ„úhİïí[Ógn;Úš¶xıÏøOi¼/ŸAœ<Làÿ/a“w»ÏKUÒ¾jÀ­pÚ¸îÈó¦WêÁß]Y¦:Ú¿Ñ4ìæäM¯ì‚ñOg]¼Cká~tua ”?¤ãEWÖ4œí 6(\r‡¨ÀŞäI_àîÿY¢‘+À_«ëAßPüUXR½Õ‚ŞQÖ™i|6`\G>­ï¢v²o/‡ßq‘õÈr»¸¨ëqm`²„˜ñû¤÷÷@¼€¼û¡$Ó|ğ¶š[ƒuÄoC-ÖŸjˆt^!àŸŒŠˆO`Ü™Æ¸4—Å¿(Ø¡¡yşÊæQûtt“nWLóâÖ·Ì½ÀK_DVTÍïÕå¥ÂzuEàÿP7¤)5gl¿Sw§òĞc¸?<'0S{„x7SËz‡ ~XpFËÀ(5Ñ‘B¾*bh?26±A9Âk‰õŞ§'GH‘İus©¬5?à|£B1"×ôœTŒ7(¯ç??d¿—¢j(ây½n{-úïè´ıAáíwoøn /³§7]«F?í:q-`÷ËN(+IÀî#ïâûT‰Ãş¥`_ª÷Õ4t…æ"®ÀhÈïa…lŞ1ƒñÇÿobç.´“K¦íèçğğÕàï¡=Ø×¥iÓ_-Ôø 2¾\¯ª?sæCöÏ’QJû^¥&&¯vøŒ\©©š~ƒúˆµĞoìÿ…|)²ıÆNÄbs‹ì‹¸òHiú½U\—ğå‚›ä Y3ş×Ÿ¯8Ñ±¬Í³:vÃ¶Ä¯Ÿ'rÀ••téYßË£–úô±ÜÄe÷éÒífÔJ)ìOŠÏc6•şÊA¾yÃø>ø{uT¹¡¾æä.-ÂûğìŒı¬hiÜ€õQ>ÙğU=ÚÉ{‰ë¼¥æ0NÍeæö‹H~ßı(C
Û<EÚ
C]ı>ÖNãà‰ß5Hú¾ƒ}{fXÍµ%¯ã¸^±#„ùxÏµ–—ÆXï}•øÿp®™„üpV©iÖÒ]»9uñ³CA
ù«ehÍ{÷Lw2=r;úá”Ó.ƒß†5œ¿†ù|¿~êß;<üJˆÇé(o7	¨ŠÎöÂ¿êm>¦¹Ë»â„¬¶ë™©¡U+Ñ.ôB{‰;¦c'Õs7O+rÌ·mz™òÄ]\w÷ î¼ÕÚú÷%°NtğäÖb›xóÎÑKj©î˜±5;`®¤Ü¶3ğ“fş:¯¤z³Šû”šsû’IàúyÓ˜ş{Û‡Èë7¶l/ ı#î]È³<‘€Ü˜ş¹¼Uöé¬òÈŞÊ×²"Àqøê¿ÿ8ƒrºò Àÿ‰6ù·*OÙô¶rIµR“’@X’è›sF§ZT0³ˆúmdâSÙW$ÈºÂÃ•±å‘õf|¾¡¥ë‹¨5k.Òö Ñ^f•#¾1Ö YWâ\Í)ğXÏj°šÏ^è'’~à™/%¤Y¹ğŒn˜O6Œ|ø<©uHvË=É¨æŒş–ía2ªY­‹~öû“=ğ{¼Dä®}Š„´¿I.œëb§õfÈø¨Ó2RXµsaEº€mÑYÑeYÏ‚¿?XZ1q¹ú/ÖÆêĞğÿ	Bı/ìeO‚Ä&‹¿?EñÜ§Ÿ=İ‘øÑ6 şú}màN§ãeÇËXÇÿàîïÜem²ş?…}{XSWº÷J6$QìÈMlÎ4$¨˜ª…l
¶Î7¦)`@.‚µ€\6H1ÅééL%S…FÊÅF.kÑZÖQè´
3ST:ÀjA[õ vj=‚A“ï”ÒZö·ŞµCÏ<ç9Ïóıµ½÷ZkïµŞµŞõ®½Ş÷÷;å÷äwr}?ã|Ü/İï’ëk–èÆ£şC¶ÍîÚ¦³Ç®zåÿ‰[MGSöF•…Ú™HÒ\î	…kk@’(Ï­Q$Äı6¬©‰è÷Ät`mq*Ğs©ì9Ö?§}Òù‹æ‚“šÏC“o*ÌG˜w8Æó´>÷ÈHÁ\Ğ·Gxyõğ~?
—UéÛ€í³olãÇÁ]<NúÏÌê»yÿ8G;Ğ@ÜKT÷x´Š”o@ÁÎ¡yıQåşÍ‚êê]«:‚†Ôõì®‘ZÂ»e84U_|Åx2è?ÔÕs¯æÚGF”¯Ì}Õ*ÄWİÄzá¬ò<íşwÕ[Š/ù¼˜ÄŸöÜôı^ÿ˜öXA
ôD%H¹sTu&cA8©ç­Âx2ùŞË|Œê¹Îâõ*êZ²ˆ-tq*ú§.hú)å¢LæâÚµí}ŒÜÊ6Q»Z8×áx¶4Mˆ„²]M›=!O¥dayì3]8ØDÒ”Á¦
÷ÍGf5UzB+O-Ú]á¶™öí&ÿyëáÿäÇ©­ühÊWğÿ·üı>¸Á×M»Ë!ÿÂ½M$ßz¨òím*¹×ñåıöÎ/MJ„–`ùÑZöˆºÕ4^pÚD_·r›ğ<><R° rNÃ™h­üŞ‚çÍ]"7¼şF¬ÿ.µ€—oîGá3x_—‹ç¥ÒäÛHÆŞWáç,g¼}€û™ÜhÈ'úÛ‡ŒĞçPìëğx(Äã¨¡Î÷Æù÷«·’q¡C:Ô‰¿ÛvÑ×J3×KŠY.`°üÜ1ºLIÏ½E|œ£Ë×(Şu¼)fy8B½N¿åÌ›Öoy£B«Ìí¢/ÛÍfsÉP~	J°‹.´ËEÑ‹îvõ¤K€Úõîƒú{íñÁ]š2uv¾6Qø] ²Èß²ÅÉ¤´°mİœõº¬Zä{*ê³‡Ú‰ÃÎóÊ·oU¬Ë
.»ÚĞípôàuÄ©»|Ù!|‚÷G=,Ö#$;MnÜÏ~_aùşùMÉR/'^¾ï§xï§Â<õA´ÅF®yyBYÊãDÚÊAîõ ßİ8ù—ãç0® m"×~ƒ
oşøıø=6’ïÔÂ½¿3—PLÆ§T“	ÆÁú!OL¬¡ŸG6¯C’|lçÇl¹·ÏÓ¼EoŞ»|:î%¡Ïë4ú"ZKÅqWoa½^ağz¢qËqXSıÚ£úô‰Db=>n–xå¯Kõ_?Š´°®D˜ğ>ß½×cáÃì4Dæ7Ö'§É¸á†±Âóó»•íx=‚x¯àç®Õd{ğ'Î|+à?lOöÌMí˜o8¤'÷m‡ n§/Ş¯"xxÓB ßi‡8ãi!«W¿úï²§…Òøäœ@î’@½‰|=ê4û´PÏ¶¢ÌRÔ#¿tzI G#,_*¦‡éÙvÉÎ£”oöeî²wÊ,ÎÓçXÔ›åÎÙV«Ó)ßÖµ¿Y±#Ğ³-ÖÀiÑ_ÿµÿAßz¯%Sóæë”ü°|‡x}P?ÔjÂúùÔGCXm¦£Å‘rQ—ÛõÂ5ÈñıqºäİJòÕ5{Ç	Î×ˆç÷Pè£õ6ş}){›yyÛ°ÜCËÏ¤À8ÙSq*eÖ#×¨i4X‡÷…qç&ğxÈ„ïìY¬¥8îëáÓpNˆú5'G®%ìHÉı8¨pÁ–ï=ÈŸ3{¬Ë¸»°^P:¡ïÃ„ïG¨ ìˆõ÷è‚CX¯lHÁã
Ë}Ñb;¯¢~l_Ş»¥†Æë7NE{ğzqC]-Ê´ãy‹ª~ÜŠå­Lì\ü#,¿P,wz’†xÓ©ñ@äœØ1Íp€”›o;ì™—Œå~Dï9œØ‘d{e¢]íC´!»dY§¡C¤^"<®’C×øÚíuÜÊ1y—ƒàæ±şE`ŸM¿äèÔ–<BÏ¶¬lÎ‚*Úİç•2ô½*¨8ÛkÎ{İî65ç²Ğm¢=êá„Èü|ÿ£fï|ß‹åòòÎ×¯ÄÕğÿŞg«p·²GW†`ı8ÉÈ‡ånã×m"W¢×±üæUœ]ˆ×ñtÊA#ÁÔºş®Éó<¯¿ıŞúËÙäÕ+d˜ZˆX¸—¤§RöîqïQ7bû¨¾VPëxtMŒÇAÕ¢­WÛDW”Ñxáô/îÔô ¥fX¿±~÷ëñîËğ5–ŸO?^ğzáÓOô6¯ØîÂrÜå&z!ÎüwõT¯Ôqìox§I¹»ê7EXÿßX´½j'zY—{2({Ñc¡D¯£{ÎvÑY;~=rNÆráå8Èæ7¯“a¾yÍÏ&ãÁ.Ù7•§Jó¿^Ã89JRÁ€û|y›w<Ù2­´êÓv¯>ñËúAt4=Räˆ3Ó>òm•	ä@îÍÏM¶¹Ûíqœ#µIHâøaş•ŸªÇıŒç×©”Á¥X»Ã$çøş^hãõxÊ>°ûòQÀg{°½¶³g×uøÏ¿ır;®4Û	‹ÊãùÛLÆA½mj=o.y¯UÇe ~7©CŞõÆ–óGŞõjİXãÖ	Ğÿ»‰Pæn|ıä©}`_G{d»+=3-gë‚šßğ´™:f·–{*ïò³Á8 ÑNäÆëƒ¤Î¢õ_~0>šM¹cVe@œ$¿®f™“Üj;à¬éÎÙuñ:¬ÓQ
go²Ènw9_ÃëtfbQ»¨Cö/"O"Ÿ)½ÍóHoó÷“Cñ¼U‘ù›ÈËé ‘S™ßXÿó÷»°<<í‰]IC^=`›J½ãcª<Sòª/Ù;ô¸¾âõ[ºŸĞüuY(ş®¹i8_PÑòL'@2.'-.^ÈRl¬ûgı³vYåÖ³Q×D5±™h4
Ï¿ÙXn{ñµ¡â51½Gç7ˆ—ëé‡xşN±íÜì™ùÆ)}^×±n‘iÖåP7=¢K”l¬ó /ˆÜöyí¹İ»Ïö‡ìªñ¼S{&=ô:ùlöÈ©kØÃóÿ#Û~ÖºñTE3~ŸZâDz^îë÷>³6‚s
[©;`£ı¸í©š<Še­Ö&Q›}TWiÖ”¦‹Ç²ÀŸë}awK›è ÚÙ«S@ª×¯Òbı¤Ì°×fù|îîÄÄ<±Â
ü³ybe$ªW7í4ğ›ÑôGôÀkIJJ§ôÎ’ìì<kÅë2 Ãë²ğ)wÁµµE ÀåÄ¯¤ R3¡x¨O/!©®—ğSËàÚ£ ‰s and treat them like plugins
    root.walkAtRules("layer", (layerRule)=>{
        extractVariantAtRules(layerRule);
        if (layerRule.params === "base") {
            for (let node of layerRule.nodes){
                layerPlugins.push(function({ addBase  }) {
                    addBase(node, {
                        respectPrefix: false
                    });
                });
            }
            layerRule.remove();
        } else if (layerRule.params === "components") {
            for (let node of layerRule.nodes){
                layerPlugins.push(function({ addComponents  }) {
                    addComponents(node, {
                        respectPrefix: false,
                        preserveSource: true
                    });
                });
            }
            layerRule.remove();
        } else if (layerRule.params === "utilities") {
            for (let node of layerRule.nodes){
                layerPlugins.push(function({ addUtilities  }) {
                    addUtilities(node, {
                        respectPrefix: false,
                        preserveSource: true
                    });
                });
            }
            layerRule.remove();
        }
    });
    return layerPlugins;
}
function resolvePlugins(context, root) {
    let corePluginList = Object.entries({
        ..._corePlugins.variantPlugins,
        ..._corePlugins.corePlugins
    }).map(([name, plugin])=>{
        if (!context.tailwindConfig.corePlugins.includes(name)) {
            return null;
        }
        return plugin;
    }).filter(Boolean);
    let userPlugins = context.tailwindConfig.plugins.map((plugin)=>{
        if (plugin.__isOptionsFunction) {
            plugin = plugin();
        }
        return typeof plugin === "function" ? plugin : plugin.handler;
    });
    let layerPlugins = collectLayerPlugins(root);
    // TODO: This is a workaround for backwards compatibility, since custom variants
    // were historically sorted before screen/stackable variants.
    let beforeVariants = [
        _corePlugins.variantPlugins["pseudoElementVariants"],
        _corePlugins.variantPlugins["pseudoClassVariants"],
        _corePlugins.variantPlugins["ariaVariants"],
        _corePlugins.variantPlugins["dataVariants"]
    ];
    let afterVariants = [
        _corePlugins.variantPlugins["supportsVariants"],
        _corePlugins.variantPlugins["directionVariants"],
        _corePlugins.variantPlugins["reducedMotionVariants"],
        _corePlugins.variantPlugins["prefersContrastVariants"],
        _corePlugins.variantPlugins["darkVariants"],
        _corePlugins.variantPlugins["printVariant"],
        _corePlugins.variantPlugins["screenVariants"],
        _corePlugins.variantPlugins["orientationVariants"]
    ];
    return [
        ...corePluginList,
        ...beforeVariants,
        ...userPlugins,
        ...afterVariants,
        ...layerPlugins
    ];
}
function registerPlugins(plugins, context) {
    let variantList = [];
    let variantMap = new Map();
    context.variantMap = variantMap;
    let offsets = new _offsets.Offsets();
    context.offsets = offsets;
    let classList = new Set();
    let pluginApi = buildPluginApi(context.tailwindConfig, context, {
        variantList,
        variantMap,
        offsets,
        classList
    });
    for (let plugin of plugins){
        if (Array.isArray(plugin)) {
            for (let pluginItem of plugin){
                pluginItem(pluginApi);
            }
        } else {
            plugin === null || plugin === void 0 ? void 0 : plugin(pluginApi);
        }
    }
    // Make sure to record bit masks for every variant
    offsets.recordVariants(variantList, (variant)=>variantMap.get(variant).length);
    // Build variantMap
    for (let [variantName, variantFunctions] of variantMap.entries()){
        context.variantMap.set(variantName, variantFunctions.map((variantFunction, idx)=>[
                offsets.forVariant(variantName, idx),
                variantFunction
            ]));
    }
    var _context_tailwindConfig_safelist;
    let safelist = ((_context_tailwindConfig_safelist = context.tailwindConfig.safelist) !== null && _context_tailwindConfig_safelist !== void 0 ? _context_tailwindConfig_safelist : []).filter(Boolean);
    if (safelist.length > 0) {
        let checks = [];
        for (let value of safelist){
            if (typeof value === "string") {
                context.changedContent.push({
                    content: value,
                    extension: "html"
                });
                continue;
            }
            if (value instanceof RegExp) {
                _log.default.warn("root-regex", [
                    "Regular expressions in `safelist` work differently in Tailwind CSS v3.0.",
                    "Update your `safelist` configuration to eliminate this warning.",
                    "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
                ]);
                continue;
            }
            checks.push(value);
        }
        if (checks.length > 0) {
            let patternMatchingCount = new Map();
            let prefixLength = context.tailwindConfig.prefix.length;
            let checkImportantUtils = checks.some((check)=>check.pattern.source.includes("!"));
            for (let util of classList){
                let utils = Array.isArray(util) ? (()=>{
                    let [utilName, options] = util;
                    var _options_values;
                    let values = Object.keys((_options_values = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values !== void 0 ? _options_values : {});
                    let classes = values.map((value)=>(0, _nameClass.formatClass)(utilName, value));
                    if (options === null || options === void 0 ? void 0 : options.supportsNegativeValues) {
                        // This is the normal negated version
                        // e.g. `-inset-1` or `-tw-inset-1`
                        classes = [
                            ...classes,
                            ...classes.map((cls)=>"-" + cls)
                        ];
                        // This is the negated version *after* the prefix
                        // e.g. `tw--inset-1`
                        // The prefix is already attached to util name
                        // So we add the negative after the prefix
                        classes = [
                            ...classes,
                            ...classes.map((cls)=>cls.slice(0, prefixLength) + "-" + cls.slice(prefixLength))
                        ];
                    }
                    if (options.types.some(({ type  })=>type === "color")) {
                        classes = [
                            ...classes,
                            ...classes.flatMap((cls)=>Object.keys(context.tailwindConfig.theme.opacity).map((opacity)=>`${cls}/${opacity}`))
                        ];
                    }
                    if (checkImportantUtils && (options === null || options === void 0 ? void 0 : options.respectImportant)) {
                        classes = [
                            ...classes,
                            ...classes.map((cls)=>"!" + cls)
                        ];
                    }
                    return classes;
                })() : [
                    util
                ];
                for (let util of utils){
                    for (let { pattern , variants =[]  } of checks){
                        // RegExp with the /g flag are stateful, so let's reset the last
                        // index pointer to reset the state.
                        pattern.lastIndex = 0;
                        if (!patternMatchingCount.has(pattern)) {
                            patternMatchingCount.set(pattern, 0);
                        }
                        if (!pattern.test(util)) continue;
                        patternMatchingCount.set(pattern, patternMatchingCount.get(pattern) + 1);
                        context.changedContent.push({
                            content: util,
                            extension: "html"
                        });
                        for (let variant of variants){
                            context.changedContent.push({
                                content: variant + context.tailwindConfig.separator + util,
                                extension: "html"
                            });
                        }
                    }
                }
            }
            for (let [regex, count] of patternMatchingCount.entries()){
                if (count !== 0) continue;
                _log.default.warn([
                    `The safelist pattern \`${regex}\` doesn't match any Tailwind CSS classes.`,
                    "Fix this pattern or remove it from your `safelist` configuration.",
                    "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
                ]);
            }
        }
    }
    var _context_tailwindConfig_darkMode, _concat_;
    let darkClassName = (_concat_ = [].concat((_context_tailwindConfig_darkMode = context.tailwindConfig.darkMode) !== null && _context_tailwindConfig_darkMode !== void 0 ? _context_tailwindConfig_darkMode : "media")[1]) !== null && _concat_ !== void 0 ? _concat_ : "dark";
    // A list of utilities that are used by certain Tailwind CSS utilities but
    // that don't exist on their own. This will result in them "not existing" and
    // sorting could be weird since you still require them in order to make the
    // host utilities work properly. (Thanks Biology)
    let parasiteUtilities = [
        prefix(context, darkClassName),
        prefix(context, "group"),
        prefix(context, "peer")
    ];
    context.getClassOrder = function getClassOrder(classes) {
        // Sort classes so they're ordered in a deterministic manner
        let sorted = [
            ...classes
        ].sort((a, z)=>{
            if (a === z) return 0;
            if (a < z) return -1;
            return 1;
        });
        // Non-util classes won't be generated, so we default them to null
        let sortedClassNames = new Map(sorted.map((className)=>[
                className,
                null
            ]));
        // Sort all classes in order
        // Non-tailwind classes won't be generated and will be left as `null`
        let rules = (0, _generateRules.generateRules)(new Set(sorted), context);
        rules = context.offsets.sort(rules);
        let idx = BigInt(parasiteUtilities.length);
        for (const [, rule] of rules){
            let candidate = rule.raws.tailwind.candidate;
            var _sortedClassNames_get;
            // When multiple rules match a candidate
            // always take the position of the first one
            sortedClassNames.set(candidate, (_sortedClassNames_get = sortedClassNames.get(candidate)) !== null && _sortedClassNames_get !== void 0 ? _sortedClassNames_get : idx++);
        }
        return classes.map((className)=>{
            var _sortedClassNames_get;
            let order = (_sortedClassNames_get = sortedClassNames.get(className)) !== null && _sortedClassNames_get !== void 0 ? _sortedClassNames_get : null;
            let parasiteIndex = parasiteUtilities.indexOf(className);
            if (order === null && parasiteIndex !== -1) {
                // This will make sure that it is at the very beginning of the
                // `components` layer which technically means 'before any
                // components'.
                order = BigInt(parasiteIndex);
            }
            return [
                className,
                order
            ];
        });
    };
    // Generate a list of strings for autocompletion purposes, e.g.
    // ['uppercase', 'lowercase', ...]
    context.getClassList = function getClassList(options = {}) {
        let output = [];
        for (let util of classList){
            if (Array.isArray(util)) {
                var _utilOptions_types;
                let [utilName, utilOptions] = util;
                let negativeClasses = [];
                var _utilOptions_modifiers;
                let modifiers = Object.keys((_utilOptions_modifiers = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.modifiers) !== null && _utilOptions_modifiers !== void 0 ? _utilOptions_modifiers : {});
                if (utilOptions === null || utilOptions === void 0 ? void 0 : (_utilOptions_types = utilOptions.types) === null || _utilOptions_types === void 0 ? void 0 : _utilOptions_types.some(({ type  })=>type === "color")) {
                    var _context_tailwindConfig_theme_opacity;
                    modifiers.push(...Object.keys((_context_tailwindConfig_theme_opacity = context.tailwindConfig.theme.opacity) !== null && _context_tailwindConfig_theme_opacity !== void 0 ? _context_tailwindConfig_theme_opacity : {}));
                }
                let metadata = {
                    modifiers
                };
                let includeMetadata = options.includeMetadata && modifiers.length > 0;
                var _utilOptions_values;
                for (let [key, value] of Object.entries((_utilOptions_values = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.values) !== null && _utilOptions_values !== void 0 ? _utilOptions_values : {})){
                    // Ignore undefined and null values
                    if (value == null) {
                        continue;
                    }
                    let cls = (0, _nameClass.formatClass)(utilName, key);
                    output.push(includeMetadata ? [
                        cls,
                        metadata
                    ] : cls);
                    if ((utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.supportsNegativeValues) && (0, _negateValue.default)(value)) {
                        let cls = (0, _nameClass.formatClass)(utilName, `-${key}`);
                        negativeClasses.push(includeMetadata ? [
                            cls,
                            metadata
                        ] : cls);
                    }
                }
                output.push(...negativeClasses);
            } else {
                output.push(util);
            }
        }
        return output;
    };
    // Generate a list of available variants with meta information of the type of variant.
    context.getVariants = function getVariants() {
        let result = [];
        for (let [name, options] of context.variantOptions.entries()){
            if (options.variantInfo === VARIANT_INFO.Base) continue;
            var _options_values;
            result.push({
                name,
                isArbitrary: options.type === Symbol.for("MATCH_VARIANT"),
                values: Object.keys((_options_values = options.values) !== null && _options_values !== void 0 ? _options_values : {}),
                hasDash: name !== "@",
                selectors ({ modifier , value  } = {}) {
                    let candidate = "__TAILWIND_PLACEHOLDER__";
                    let rule = _postcss.default.rule({
                        selector: `.${candidate}`
                    });
                    let container = _postcss.default.root({
                        nodes: [
                            rule.clone()
                        ]
                    });
                    let before = container.toString();
                    var _context_variantMap_get;
                    let fns = ((_context_variantMap_get = context.variantMap.get(name)) !== null && _context_variantMap_get !== void 0 ? _context_variantMap_get : []).flatMap(([_, fn])=>fn);
                    let formatStrings = [];
                    for (let fn of fns){
                        var _options_values;
                        let localFormatStrings = [];
                        var _options_values_value;
                        let api = {
                            args: {
                                modifier,
                                value: (_options_values_value = (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[value]) !== null && _options_values_value !== void 0 ? _options_values_value : value
                            },
                            separator: context.tailwindConfig.separator,
                            modifySelectors (modifierFunction) {
                                // Run the modifierFunction over each rule
                                container.each((rule)=>{
                                    if (rule.type !== "rule") {
                                        return;
                                    }
                                    rule.selectors = rule.selectors.map((selector)=>{
                                        return modifierFunction({
                                            get className () {
                                                return (0, _generateRules.getClassNameFromSelector)(selector);
                                            },
                                            selector
                                        });
                                    });
                                });
                                return container;
                            },
                            format (str) {
                                localFormatStrings.push(str);
                            },
                            wrap (wrapper) {
                                localFormatStrings.push(`@${wrapper.name} ${wrapper.params} { & }`);
                            },
                            container
                        };
                        let ruleWithVariant = fn(api);
                        if (localFormatStrings.length > 0) {
                            formatStrings.push(localFormatStrings);
                        }
                        if (Array.isArray(ruleWithVariant)) {
                            for (let variantFunction of ruleWithVariant){
                                localFormatStrings = [];
                                variantFunction(api);
                                formatStrings.push(localFormatStrings);
                            }
                        }
                    }
                    // Reverse engineer the result of the `container`
                    let manualFormatStrings = [];
                    let after = container.toString();
                    if (before !== after) {
                        // Figure out all selectors
                        container.walkRules((rule)=>{
                            let modified = rule.selector;
                            // Rebuild the base selector, this is what plugin authors would do
                            // as well. E.g.: `${variant}${separator}${className}`.
                            // However, plugin authors probably also prepend or append certain
                            // classes, pseudos, ids, ...
                            let rebuiltBase = (0, _postcssselectorparser.default)((selectors)=>{
                                selectors.walkClasses((classNode)=>{
                                    classNode.value = `${name}${context.tailwindConfig.separator}${classNode.value}`;
                                });
                            }).processSync(modified);
                            // Now that we know the original selector, the new selector, and
                            // the rebuild part in between, we can replace the part that plugin
                            // authors need to rebuild with `&`, and eventually store it in the
                            // collectedFormats. Similar to what `format('...')` would do.
                            //
                            // E.g.:
                            //                   variant: foo
                            //                  selector: .markdown > p
                            //      modified (by plugin): .foo .foo\\:markdown > p
                            //    rebuiltBase (internal): .foo\\:markdown > p
                            //                    format: .foo &
                            manualFormatStrings.push(modified.replace(rebuiltBase, "&").replace(candidate, "&"));
                        });
                        // Figure out all atrules
                        container.walkAtRules((atrule)=>{
                            manualFormatStrings.push(`@${atrule.name} (${atrule.params}) { & }`);
                        });
                    }
                    var _options_values1;
                    let isArbitraryVariant = !(value in ((_options_values1 = options.values) !== null && _options_values1 !== void 0 ? _options_values1 : {}));
                    var _options_INTERNAL_FEATURES;
                    let internalFeatures = (_options_INTERNAL_FEATURES = options[INTERNAL_FEATURES]) !== null && _options_INTERNAL_FEATURES !== void 0 ? _options_INTERNAL_FEATURES : {};
                    let respectPrefix = (()=>{
                        if (isArbitraryVariant) return false;
                        if (internalFeatures.respectPrefix === false) return false;
                        return true;
                    })();
                    formatStrings = formatStrings.map((format)=>format.map((str)=>({
                                format: str,
                                respectPrefix
                            })));
                    manualFormatStrings = manualFormatStrings.map((format)=>({
                            format,
                            respectPrefix
                        }));
                    let opts = {
                        candidate,
                        context
                    };
                    let result = formatStrings.map((formats)=>(0, _formatVariantSelector.finalizeSelector)(`.${candidate}`, (0, _formatVariantSelector.formatVariantSelector)(formats, opts), opts).replace(`.${candidate}`, "&").replace("{ & }", "").trim());
                    if (manualFormatStrings.length > 0) {
                        result.push((0, _formatVariantSelector.formatVariantSelector)(manualFormatStrings, opts).toString().replace(`.${candidate}`, "&"));
                    }
                    return result;
                }
            });
        }
        return result;
    };
}
/**
 * Mark as class as retroactively invalid
 *
 *
 * @param {string} candidate
 */ function markInvalidUtilityCandidate(context, candidate) {
    if (!context.classCache.has(candidate)) {
        return;
    }
    // Mark this as not being a real utility
    context.notClassCache.add(candidate);
    // Remove it from any candidate-specific caches
    context.classCache.delete(candidate);
    context.applyClassCache.delete(candidate);
    context.candidateRuleMap.delete(candidate);
    context.candidateRuleCache.delete(candidate);
    // Ensure the stylesheet gets rebuilt
    context.stylesheetCache = null;
}
/**
 * Mark as class as retroactively invalid
 *
 * @param {import('postcss').Node} node
 */ function markInvalidUtilityNode(context, node) {
    let candidate = node.raws.tailwind.candidate;
    if (!candidate) {
        return;
    }
    for (const entry of context.ruleCache){
        if (entry[1].raws.tailwind.candidate === candidate) {
            context.ruleCache.delete(entry);
        // context.postCssNodeCache.delete(node)
        }
    }
    markInvalidUtilityCandidate(context, candidate);
}
function createContext(tailwindConfig, changedContent = [], root = _postcss.default.root()) {
    var _tailwindConfig_blocklist;
    let context = {
        disposables: [],
        ruleCache: new Set(),
        candidateRuleCache: new Map(),
        classCache: new Map(),
        applyClassCache: new Map(),
        // Seed the not class cache with the blocklist (which is only strings)
        notClassCache: new Set((_tailwindConfig_blocklist = tailwindConfig.blocklist) !== null && _tailwindConfig_blocklist !== void 0 ? _tailwindConfig_blocklist : []),
        postCssNodeCache: new Map(),
        candidateRuleMap: new Map(),
        tailwindConfig,
        changedContent: changedContent,
        variantMap: new Map(),
        stylesheetCache: null,
        variantOptions: new Map(),
        markInvalidUtilityCandidate: (candidate)=>markInvalidUtilityCandidate(context, candidate),
        markInvalidUtilityNode: (node)=>markInvalidUtilityNode(context, node)
    };
    let resolvedPlugins = resolvePlugins(context, root);
    registerPlugins(resolvedPlugins, context);
    return context;
}
let contextMap = _sharedState.contextMap;
let configContextMap = _sharedState.configContextMap;
let contextSourcesMap = _sharedState.contextSourcesMap;
function getContext(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies) {
    let sourcePath = result.opts.from;
    let isConfigFile = userConfigPath !== null;
    _sharedState.env.DEBUG && console.log("Source path:", sourcePath);
    let existingContext;
    if (isConfigFile && contextMap.has(sourcePath)) {
        existingContext = contextMap.get(sourcePath);
    } else if (configContextMap.has(tailwindConfigHash)) {
        let context = configContextMap.get(tailwindConfigHash);
        contextSourcesMap.get(context).add(sourcePath);
        contextMap.set(sourcePath, context);
        existingContext = context;
    }
    let cssDidChange = (0, _cacheInvalidation.hasContentChanged)(sourcePath, root);
    // If there's already a context in the cache and we don't need to
    // reset the context, return the cached context.
    if (existingContext) {
        let [contextDependenciesChanged, mtimesToCommit] = trackModified([
            ...contextDependencies
        ], getFileModifiedMap(existingContext));
        if (!contextDependenciesChanged && !cssDidChange) {
            return [
                existingContext,
                false,
                mtimesToCommit
            ];
        }
    }
    // If this source is in the context map, get the old context.
    // Remove this source from the context sources for the old context,
    // and clean up that context if no one else is using it. This can be
    // called by many processes in rapid succession, so we check for presence
    // first because the first process to run this code will wipe it out first.
    if (contextMap.has(sourcePath)) {
        let oldContext = contextMap.get(sourcePath);
        if (contextSourcesMap.has(oldContext)) {
            contextSourcesMap.get(oldContext).delete(sourcePath);
            if (contextSourcesMap.get(oldContext).size === 0) {
                contextSourcesMap.delete(oldContext);
                for (let [tailwindConfigHash, context] of configContextMap){
                    if (context === oldContext) {
                        configContextMap.delete(tailwindConfigHash);
                    }
                }
                for (let disposable of oldContext.disposables.splice(0)){
                    disposable(oldContext);
                }
            }
        }
    }
    _sharedState.env.DEBUG && console.log("Setting up new context...");
    let context = createContext(tailwindConfig, [], root);
    Object.assign(context, {
        userConfigPath
    });
    let [, mtimesToCommit] = trackModified([
        ...contextDependencies
    ], getFileModifiedMap(context));
    // ---
    // Update all context tracking state
    configContextMap.set(tailwindConfigHash, context);
    contextMap.set(sourcePath, context);
    if (!contextSourcesMap.has(context)) {
        contextSourcesMap.set(context, new Set());
    }
    contextSourcesMap.get(context).add(sourcePath);
    return [
        context,
        true,
        mtimesToCommit
    ];
}
