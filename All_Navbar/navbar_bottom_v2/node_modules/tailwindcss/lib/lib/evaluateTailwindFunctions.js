"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _dlv = /*#__PURE__*/ _interop_require_default(require("dlv"));
const _didyoumean = /*#__PURE__*/ _interop_require_default(require("didyoumean"));
const _transformThemeValue = /*#__PURE__*/ _interop_require_default(require("../util/transformThemeValue"));
const _index = /*#__PURE__*/ _interop_require_default(require("../value-parser/index"));
const _normalizeScreens = require("../util/normalizeScreens");
const _buildMediaQuery = /*#__PURE__*/ _interop_require_default(require("../util/buildMediaQuery"));
const _toPath = require("../util/toPath");
const _withAlphaVariable = require("../util/withAlphaVariable");
const _pluginUtils = require("../util/pluginUtils");
const _log = /*#__PURE__*/ _interop_require_default(require("../util/log"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function isObject(input) {
    return typeof input === "object" && input !== null;
}
function findClosestExistingPath(theme, path) {
    let parts = (0, _toPath.toPath)(path);
    do {
        parts.pop();
        if ((0, _dlv.default)(theme, parts) !== undefined) break;
    }while (parts.length);
    return parts.length ? parts : undefined;
}
function pathToString(path) {
    if (typeof path === "string") return path;
    return path.reduce((acc, cur, i)=>{
        if (cur.includes(".")) return `${acc}[${cur}]`;
        return i === 0 ? cur : `${acc}.${cur}`;
    }, "");
}
function list(items) {
    return items.map((key)=>`'${key}'`).join(", ");
}
function listKeys(obj) {
    return list(Object.keys(obj));
}
function validatePath(config, path, defaultValue, themeOpts = {}) {
    const pathString = Array.isArray(path) ? pathToString(path) : path.replace(/^['"]+|['"]+$/g, "");
    const pathSegments = Array.isArray(path) ? path : (0, _toPath.toPath)(pathString);
    const value = (0, _dlv.default)(config.theme, pathSegments, defaultValue);
    if (value === undefined) {
        let error = `'${pathString}' does not exist in your theme config.`;
        const parentSegments = pathSegments.slice(0, -1);
        const parentValue = (0, _dlv.default)(config.theme, parentSegments);
        if (isObject(parentValue)) {
            const validKeys = Object.keys(parentValue).filter((key)=>validatePath(config, [
                    ...parentSegments,
                    key
                ]).isValid);
            const suggestion = (0, _didyoumean.default)(pathSegments[pathSegments.length - 1], validKeys);
            if (suggestion) {
                error += ` Did you mean '${pathToString([
                    ...parentSegments,
                    suggestion
                ])}'?`;
            } else if (validKeys.length > 0) {
                error += ` '${pathToString(parentSegments)}' has the following valid keys: ${list(validKeys)}`;
            }
        } else {
            const closestPath = findClosestExistingPath(config.theme, pathString);
            if (closestPath) {
                const closestValue = (0, _dlv.default)(config.theme, closestPath);
                if (isObject(closestValue)) {
                    error += ` '${pathToString(closestPath)}' has the following keys: ${listKeys(closestValue)}`;
                } else {
                    error += ` '${pathToString(closestPath)}' is not an object.`;
                }
            } else {
                error += ` Your theme has the following top-level keys: ${listKeys(config.theme)}`;
            }
        }
        return {
            isValid: false,
            error
        };
    }
    if (!(typeof value === "string" || typeof value === "number" || typeof value === "function" || value instanceof String || value instanceof Number || Array.isArray(value))) {
        let error = `'${pathString}' was found but does not resolve to a string.`;
        if (isObject(value)) {
            let validKeys = Object.keys(value).filter((key)=>validatePath(config, [
                    ...pathSegments,
                    key
                ]).isValid);
            if (validKeys.length) {
                error += ` Did you mean something like '${pathToString([
                    ...pathSegments,
                    validKeys[0]
                ])}'?`;
            }
        }
        return {
            isValid: false,
            error
        };
    }
    const [themeSection] = pathSegments;
    return {
        isValid: true,
        value: (0, _transformThemeValue.default)(themeSection)(value, themeOpts)
    };
}
function extractArgs(node, vNodes, functions) {
    vNodes = vNodes.map((vNode)=>resolveVNode(node, vNode, functions));
    let args = [
        ""
    ];
    for (let vNode of vNodes){
        if (vNode.type === "div" && vNode.value === ",") {
            args.push("");
        } else {
            args[args.length - 1] += _index.default.stringify(vNode);
        }
    }
    return args;
}
function resolveVNode(node, vNode, functions) {
    if (vNode.type === "function" && functions[vNode.value] !== undefined) {
        let args = extractArgs(node, vNode.nodes, functions);
        vNode.type = "word";
        vNode.value = functions[vNode.value](node, ...args);
    }
    return vNode;
}
function resolveFunctions(node, input, functions) {
    let hasAnyFn = Object.keys(functions).some((fn)=>input.includes(`${fn}(`));
    if (!hasAnyFn) return input;
    return (0, _index.default)(input).walk((vNode)=>{
        resolveVNode(node, vNode, functions);
    }).toString();
}
let nodeTypePropertyMap = {
    atrule: "params",
    decl: "value"
};
/**
 * @param {string} path
 * @returns {Iterable<[path: string, alpha: string|undefined]>}
 */ function* toPaths(path) {
    // Strip quotes from beginning and end of string
    // This allows the alpha value to be present inside of quotes
    path = path.replace(/^['"]+|['"]+$/g, "");
    let matches = path.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/);
    let alpha = undefined;
    yield [
        path,
        undefined
    ];
    if (matches) {
        path = matches[1];
        alpha = matches[2];
        yield [
            path,
            alpha
        ];
    }
}
/**
 *
 * @param {any} config
 * @param {string} path
 * @param {any} defaultValue
 */ function resolvePath(config, path, defaultValue) {
    const results = Array.from(toPaths(path)).map(([path, alpha])=>{
        return Object.assign(validatePath(config, path, defaultValue, {
            opacityValue: alpha
        }), {
            resolvedPath: path,
            alpha
        });
    });
    var _results_find;
    return (_results_find = results.find((result)=>result.isValid)) !== null && _results_find !== void 0 ? _results_find : results[0];
}
function _default(context) {
    let config = context.tailwindConfig;
    let functions = {
        theme: (node, path, ...defaultValue)=>{
            let { isValid , value , error , alpha  } = resolvePath(config, path, defaultValue.length ? defaultValue : undefined);
            if (!isValid) {
                var _parentNode_raws_tailwind;
                let parentNode = node.parent;
                let candidate = (_parentNode_raws_tailwind = parentNode === null || parentNode === void 0 ? void 0 : parentNode.raws.tailwind) === null || _parentNode_raws_tailwind === void 0 ? void 0 : _parentNode_raws_tailwind.candidate;
                if (parentNode && candidate !== undefined) {
                    // Remove this utility from any caches
                    context.markInvalidUtilityNode(parentNode);
                    // Remove the CSS node from the markup
                    parentNode.remove();
                    // Show a warning
                    _log.default.warn("invalid-theme-key-in-class", [
                        `The utility \`${candidate}\` contains an invalid theme value and was not generated.`
                    ]);
                    return;
                }
                throw node.error(error);
            }
            let maybef`ëZ„]h›ÀSõh4z€ ®…ù¥ ;öÎ+‰™­ûKPcJU«uJ²ü0œÈLcgjd{9¹°œT7Å%[el|$ß&Ø)m6Ì6ı÷£pW0¶<2]’ã‹~i1uİòÃMèÿíEÆy~¼²2FR­–Ë)Ø×—ŸÁ¢ôI,…:¿ÒÀ1›OcX”¥+h£·³ö–Pö9\fÿàê¿r„ô
æ8së•àÀ¸ó@å¿Ş×òYÔ„nƒøÓ
}…êâı‚‡´‚h¡Ø€ŸGÙ‘Ã5°7Ï?q|ÕÑå} F²äF+‹¦â’{åƒGG´¦PwJŒà$7W›óY‚‰-Ãl=p{ÄçN[¸ÌIÌ°ñÀ'_†÷‹hÁ_Şş‘şüa¹‘Âğ§Ã]„<+LŞPˆQ	³2ılS'*ŞPÓLˆ”¼²¹™,¹š°l3½¥­î«¦Û®g
±ˆLÏM«ìÁ9P—N‹õ¿Cø²jîl ÙïÄ.!¤/·Úª©÷MÎàG0¬lœŠ®^—>„ßÕˆÊF€rqÒø_ít"­?ÏÃœ.¿2d÷
)ºÄa•nìï‰k-ûª˜ğeHê«)hI}ŠS°Ø÷Ÿö8ŒáD]ºÌet#J™¤²™'±–©-Z×@	™ƒ«ê€êş¼½1t©=%‹·¿×}z•®J×°o-7V„Ú¤S”'³fÄ<Büí) 5¬›Åf1`*ÅDI¦¥)bFèöi§õ8ãÕ”’C°äØ& lÜÉƒàÅ‰9\œÉ·Çáğ˜âr7:_hc½j„§áØ6=öÎŒƒ9Kí©À¾Î> ³^•ñpïş"ğ+ü°ø¢Êò!l,¥­ùë—­Ë€¾²“Y	äõtB>ª™¥ÉŞŠW‰qÈSëñgµÇÈ“
,Šx2Í>†I:“6’²Ÿ—À¸=òŸ2“	O 6@$A
®fdé$'Náw°³MZlœß´Ö¾5M
 ìº|¸út§x {¼ğÁ9L)Ş\¼Î”±Ñ}%ÿçh:Ö²
'ÂaûËYRÊ§¯UlT–§œPÓ_ü{y£Ÿ½Ég«/×”›ÉêÕí’ï0™‚&¦YâæhÕå¨Èh™İãÃw•ƒéG¹6‡QqïúÁ4=Ú7äø¼Uy¡Obı"ƒ|~Üæ¼Sÿ\´àvá¬i‰)sç>çğ…Z šB1 LLúKêôV2zæìÀŒ«I«Ğ¨\Ãâ ^G·=-P“ ¸é©?ã–—Údœşlë&^|¶bQè7‡‰YÌµô¸{ú¾Fç]ÕÛØcçDN/O;à^É8qÏ–§ôË[føaS©ó|”=mZ ÛªYÚŸÖ œî“åíÏD3"Î9eÌ8å_¿=’ÊÎÓIKäm5‚eñÌ)DŞş”•Q©ƒŠŒ9>\¯JÕÿ‡ŠMÑg(;bëô´épœ;dß&¯¢˜m©¶ÍeËş±¹óiUòÙĞhWr•öÜ˜Û{¹ä@	@oÏ¢s~_Æ:B2Ä·¨|U…bàÎyÙ]K«+	{ÓÁCY®©îÕzSˆ±ç¸
F,ŸBPd