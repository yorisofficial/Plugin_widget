/* eslint max-len: 0 */

import {File} from "../index";
import {
  flowAfterParseClassSuper,
  flowAfterParseVarHead,
  flowParseExportDeclaration,
  flowParseExportStar,
  flowParseIdentifierStatement,
  flowParseImportSpecifier,
  flowParseTypeAnnotation,
  flowParseTypeParameterDeclaration,
  flowShouldDisallowExportDefaultSpecifier,
  flowShouldParseExportDeclaration,
  flowShouldParseExportStar,
  flowStartParseFunctionParams,
  flowStartParseImportSpecifiers,
  flowTryParseExportDefaultExpression,
  flowTryParseStatement,
} from "../plugins/flow";
import {
  tsAfterParseClassSuper,
  tsAfterParseVarHead,
  tsIsDeclarationStart,
  tsParseExportDeclaration,
  tsParseExportSpecifier,
  tsParseIdentifierStatement,
  tsParseImportEqualsDeclaration,
  tsParseImportSpecifier,
  tsParseMaybeDecoratorArguments,
  tsParseModifiers,
  tsStartParseFunctionParams,
  tsTryParseClassMemberWithIsStatic,
  tsTryParseExport,
  tsTryParseExportDefaultExpression,
  tsTryParseStatementContent,
  tsTryParseTypeAnnotation,
  tsTryParseTypeParameters,
} from "../plugins/typescript";
import {
  eat,
  eatTypeToken,
  IdentifierRole,
  lookaheadType,
  lookaheadTypeAndKeyword,
  match,
  next,
  nextTokenStart,
  nextTokenStartSince,
  popTypeContext,
  pushTypeContext,
} from "../tokenizer";
import {ContextualKeyword} from "../tokenizer/keywords";
import {Scope} from "../tokenizer/state";
import { TokenType as tt} from "../tokenizer/types";
import {charCodes} from "../util/charcodes";
import {getNextContextId, input, isFlowEnabled, isTypeScriptEnabled, state} from "./base";
import {
  parseCallExpressionArguments,
  parseExprAtom,
  parseExpression,
  parseExprSubscripts,
  parseFunctionBodyAndFinish,
  parseIdentifier,
  parseMaybeAssign,
  parseMethod,
  parseObj,
  parseParenExpression,
  parsePropertyName,
} from "./expression";
import {
  parseBindingAtom,
  parseBindingIdentifier,
  parseBindingList,
  parseImportedIdentifier,
} from "./lval";
import {
  canInsertSemicolon,
  eatContextual,
  expect,
  expectContextual,
  hasFollowingLineBreak,
  hasPrecedingLineBreak,
  isContextual,
  isLineTerminator,
  isLookaheadContextual,
  semicolon,
  unexpected,
} from "./util";

export function parseTopLevel() {
  parseBlockBody(tt.eof);
  state.scopes.push(new Scope(0, state.tokens.length, true));
  if (state.scopeDepth !== 0) {
    throw new Error(`Invalid scope depth at end of file: ${state.scopeDepth}`);
  }
  return new File(state.tokens, state.scopes);
}

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

export function parseStatement(declaration) {
  if (isFlowEnabled) {
    if (flowTryParseStatement()) {
      return;
    }
  }
  if (match(tt.at)) {
    parseDecorators();
  }
  parseStatementContent(declaration);
}

function parseStatementContent(declaration) {
  if (isTypeScriptEnabled) {
    if (tsTryParseStatementContent()) {
      return;
    }
  }

  const starttype = state.type;

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
    case tt._break:
    case tt._continue:
      parseBreakContinueStatement();
      return;
    case tt._debugger:
      parseDebuggerStatement();
      return;
    case tt._do:
      parseDoStatement();
      return;
    case tt._for:
      parseForStatement();
      return;
    case tt._function:
      if (lookaheadType() === tt.dot) break;
      if (!declaration) unexpected();
      parseFunctionStatement();
      return;

    case tt._class:
      if (!declaration) unexpected();
      parseClass(true);
      return;

    case tt._if:
      parseIfStatement();
      return;
    case tt._return:
      parseReturnStatement();
      return;
    case tt._switch:
      parseSwitchStatement();
      return;
    case tt._throw:
      parseThrowStatement();
      return;
    case tt._try:
      parseTryStatement();
      return;

    case tt._let:
    case tt._const:
      if (!declaration) unexpected(); // NOTE: falls through to _var

    case tt._var:
      parseVarStatement(starttype !== tt._var);
      return;

    case tt._while:
      parseWhileStatement();
      return;
    case tt.braceL:
      parseBlock();
      return;
    case tt.semi:
      parseEmptyStatement();
      return;
    case tt._export:
    case tt._import: {
      const nextType = lookaheadType();
      if (nextType === tt.parenL || nextType === tt.dot) {
        break;
      }
      next();
      if (starttype === tt._import) {
        parseImport();
      } else {
        parseExport();
      }
      return;
    }
    case tt.name:
      if (state.contextualKeyword === ContextualKeyword._async) {
        const functionStart = state.start;
        // peek ahead and see if next token is a function
        const snapshot = state.snapshot();
        next();
        if (match(tt._function) && !canInsertSemicolon()) {
          expect(tt._function);
          parseFunction(functionStart, true);
          return;
        } else {
          state.restoreFromSnapshot(snapshot);
        }
      } else if (
        state.contextualKeyword === ContextualKeyword._using &&
        !hasFollowingLineBreak() &&
        // Statements like `using[0]` and `using in foo` aren't actual using
        // declarations.
        lookaheadType() === tt.name
      ) {
        parseVarStatement(true);
        return;
      } else if (startsAwaitUsing()) {
        expectContextual(ContextualKeyword._await);
        parseVarStatement(true);
        return;
      }
    default:
      // Do nothing.
      break;
  }

  // If the statement does not start with a statement keyword or a
  // brace, it's an ExpressionStatement or LabeledStatement. We
  // simply start parsing an expression, and afterwards, if the
  // next token is a colon and the expression was a simple
  // Identifier node, we switch to interpreting it as a label.
  const initialTokensLength = state.tokens.length;
  parseExpression();
  let simpleName = null;
  if (state.tokens.length === initialTokensLength + 1) {
    const token = state.tokens[state.tokens.length - 1];
    if (token.type === tt.name) {
      simpleName = token.contextualKeyword;
    }
  }
  if (simpleName == null) {
    semicolon();
    return;
  }
  if (eat(tt.colon)) {
    parseLabeledStatement();
  } else {
    // This was an identifier, so we might want to handle flow/typescript-specific cases.
    parseIdentifierStatement(simpleName);
  }
}

/**
 * Determine if we're positioned at an `await using` declaration.
 *
 * Note that this can happen either in place of a regular variable declaration
 * or in a loop body, and in both places, there are similar-looking cases where
 * we need to return false.
 *
 * Examples returning true:
 * await using foo = bar();
 * for (await using a of b) {}
 *
 * Examples returning false:
 * await using
 * await using + 1
 * await using instanceof T
 * for (await using;;) {}
 *
 * For now, we early return if we don't see `await`, then do a simple
 * backtracking-based lookahead for the `using` and identifier tokens. In the
 * future, this could be optimized with a character-based approach.
 */
function startsAwaitUsing() {
  if (!isContextual(ContextualKeyword._await)) {
    return false;
  }
  const snapshot = state.snapshot();
  // await
  next();
  if (!isContextual(ContextualKeyword._using) || hasPrecedingLineBreak()) {
    state.restoreFromSnapshot(snapshot);
    return false;
  }
  // using
  next();
  if (!match(tt.name) || hasPrecedingLineBreak()) {
    state.restoreFromSnapshot(snapshot);
    return false;
  }
  state.restoreFromSnapshot(snapshot);
  return true;
}

export function parseDecorators() {
  while (match(tt.at)) {
    parseDecorator();
  }
}

function parseDecorator() {
  next();
  if (eat(tt.parenL)) {
    parseExpression();
    expect(tt.parenR);
  } else {
    parseIdentifier();
    while (eat(tt.dot)) {
      parseIdentifier();
    }
    parseMaybeDecoratorArguments();
  }
}

function parseMaybeDecoratorArguments() {
  if (isTypeScriptEnabled) {
    tsParseMaybeDecoratorArguments();
  } else {
    baseParseMaybeDecoratorArguments();
  }
}

export function baseParseMaybeDecoratorArguments() {
  if (eat(tt.parenL)) {
    parseCallExpressionArguments();
  }
}

function parseBreakContinueStatement() {
  next();
  if (!isLineTerminator()) {
    parseIdentifier();
    semicolon();
  }
}

function parseDebuggerStatement() {
  next();
  semicolon();
}

function parseDoStatement() {
  next();
  parseStatement(false);
  expect(tt._while);
  parseParenExpression();
  eat(tt.semi);
}

function parseForStatement() {
  state.scopeDepth++;
  const startTokenIndex = state.tokens.length;
  parseAmbiguousForStatement();
  const endTokenIndex = state.tokens.length;
  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));
  state.scopeDepth--;
}

/**
 * Determine if this token is a `using` declaration (explicit resource
 * management) as part of a loop.
 * https://github.com/tc39/proposal-explicit-resource-management
 */
function isUsingInLoop() {
  if (!isContextual(ContextualKeyword._using)) {
    return false;
  }
  // This must be `for (using of`, where `using` is the name of the loop
  // variable.
  if (isLookaheadContextual(ContextualKeyword._of)) {
    return false;
  }
  return true;
}

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.
function parseAmbiguousForStatement() {
  next();

  let forAwait = false;
  if (isContextual(ContextualKeyword._await)) {
    forAwait = true;
    next();
  }
  expect(tt.parenL);

  if (match(tt.semi)) {
    if (forAwait) {
      unexpected();
    }
    parseFor();
    return;
  }

  const isAwaitUsing = startsAwaitUsing();
  if (isAwaitUsing || match(tt._var) || match(tt._let) || match(tt._const) || isUsingInLoop()) {
    if (isAwaitUsing) {
      expectContextual(ContextualKeyword._await);
    }
    next();
    parseVar(true, state.type !== tt._var);
    if (match(tt._in) || isContextual(ContextualKeyword._of)) {
      parseForIn(forAwait);
      return;
    }
    parseFor();
    return;
  }

  parseExpression(true);
  if (match(tt._in) || isContextual(ContextualKeyword._of)) {
    parseForIn(forAwait);
    return;
  }
  if (forAwait) {
    unexpected();
  }
  parseFor();
}

function parseFunctionStatement() {
  const functionStart = state.start;
  next();
  parseFunction(functionStart, true);
}

function parseIfStatement() {
  next();
  parseParenExpression();
  parseStatement(false);
  if (eat(tt._else)) {
    parseStatement(false);
  }
}

function parseReturnStatement() {
  next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (!isLineTerminator()) {
    parseExpression();
    semicolon();
  }
}

function parseSwitchStatement() {
  next();
  parseParenExpression();
  state.scopeDepth++;
  const startTokenIndex = state.tokens.length;
  expect(tt.braceL);

  // Don't bother validation; just go through any sequence of cases, defaults, and statements.
  while (!match(tt.braceR) && !state.error) {
    if (match(tt._case) || match(tt._default)) {
      const isCase = match(tt._case);
      next();
      if (isCase) {
        parseExpression();
      }
      expect(tt.colon);
    } else {
      parseStatement(true);
    }
  }
  next(); // Closing brace
  const endTokenIndex = state.tokens.length;
  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));
  state.scopeDepth--;
}

function parseThrowStatement() {
  next();
  parseExpression();
  semicolon();
}

function parseCatchClauseParam() {
  parseBindingAtom(true /* isBlockScope */);

  if (isTypeScriptEnabled) {
    tsTryParseTypeAnnotation();
  }
}

function parseTryStatement() {
  next();

  parseBlock();

  if (match(tt._catch)) {
    next();
    let catchBindingStartTokenIndex = null;
    if (match(tt.parenL)) {
      state.scopeDepth++;
      catchBindingStartTokenIndex = state.tokens.length;
      expect(tt.parenL);
      parseCatchClauseParam();
      expect(tt.parenR);
    }
    parseBlock();
    if (catchBindingStartTokenIndex != null) {
      // We need a special scope for the catch binding which includes the binding itself and the
      // catch block.
      const endTokenIndex = state.tokens.length;
      state.scopes.push(new Scope(catchBindingStartTokenIndex, endTokenIndex, false));
      state.scopeDepth--;
    }
  }
  if (eat(tt._finally)) {
    parseBlock();
  }
}

export function parseVarStatement(isBlockScope) {
  next();
  parseVar(false, isBlockScope);
  semicolon();
}

function parseWhileStatement() {
  next();
  parseParenExpression();
  parseStatement(false);
}

function parseEmptyStatement() {
  next();
}

function parseLabeledStatement() {
  parseStatement(true);
}

/**
 * Parse a statement starting with an identifier of the given name. Subclasses match on the name
 * to handle statements like "declare".
 */
function parseIdentifierStatement(contextualKeyword) {
  if (isTypeScriptEnabled) {
    tsParseIdentifierStatement(contextualKeyword);
  } else if (isFlowEnabled) {
    flowParseIdentifierStatement(contextualKeyword);
  } else {
    semicolon();
  }
}

// Parse a semicolon-enclosed block of statements.
export function parseBlock(isFunctionScope = false, contextId = 0) {
  const startTokenIndex = state.tokens.length;
  state.scopeDepth++;
  expect(tt.braceL);
  if (contextId) {
    state.tokens[state.tokens.length - 1].contextId = contextId;
  }
  parseBlockBody(tt.braceR);
  if (contextId) {
    state.tokens[state.tokens.length - 1].contextId = contextId;
  }
  const endTokenIndex = state.tokens.length;
  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, isFunctionScope));
  state.scopeDepth--;
}

export function parseBlockBody(end) {
  while (!eat(end) && !state.error) {
    parseStatement(true);
  }
}

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

function parseFor() {
  expect(tt.semi);
  if (!match(tt.semi)) {
    parseExpression();
  }
  expect(tt.semi);
  if (!match(tt.parenR)) {
    parseExpression();
  }
  expect(tt.parenR);
  parseStatement(false);
}

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

function parseForIn(forAwait) {
  if (forAwait) {
    eatContextual(ContextualKeyword._of);
  } else {
    next();
  }
  parseExpression();
  expect(tt.parenR);
  parseStatement(false);
}

// Parse a list of variable declarations.

function parseVar(isFor, isBlockScope) {
  while (true) {
    parseVarHead(isBlockScope);
    if (eat(tt.eq)) {
      const eqIndex = state.tokens.length - 1;
      parseMaybeAssign(isFor);
      state.tokens[eqIndex].rhsEndIndex = state.tokens.length;
    }
    if (!eat(tt.comma)) {
      break;
    }
  }
}

function parseVarHead(isBlockScope) {
  parseBindingAtom(isBlockScope);
  if (isTypeScriptEnabled) {
    tsAfterParseVarHead();
  } else if (isFlowEnabled) {
    flowAfterParseVarHead();
  }
}

// Parse a function declaration or literal (depending on the
// `isStatement` parameter).

export function parseFunction(
  functionStart,
  isStatement,
  optionalId = false,
) {
  if (match(tt.star)) {
    next();
  }

  if (isStatement && !optionalId && !match(tt.name) && !match(tt._yield)) {
    unexpected();
  }

  let nameScopeStartTokenIndex = null;

  if (match(tt.name)) {
    // Expression-style functions should limit their name's scope to the function body, so we make
    // a new function scope to enforce that.
    if (!isStatement) {
      nameScopeStartTokenIndex = state.tokens.length;
      state.scopeDepth++;
    }
    parseBindingIdentifier(false);
  }

  const startTokenIndex = state.tokens.length;
  state.scopeDepth++;
  parseFunctionParams();
  parseFunctionBodyAndFinish(functionStart);
  const endTokenIndex = state.tokens.length;
  // In addition to the block scope of the function body, we need a separate function-style scope
  // that includes the params.
  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));
  state.scopeDepth--;
  if (nameScopeStartTokenIndex !== null) {
    state.scopes.push(new Scope(nameScopeStartTokenIndex, endTokenIndex, true));
    state.scopeDepth--;
  }
}

export function parseFunctionParams(
  allowModifiers = false,
  funcContextId = 0,
) {
  if (isTypeScriptEnabled) {
    tsStartParseFunctionParams();
  } else if (isFlowEnabled) {
    flowStartParseFunctionParams();
  }

  expect(tt.parenL);
  if (funcContextId) {
    state.tokens[state.tokens.length - 1].contextId = funcContextId;
  }
  parseBindingList(
    tt.parenR,
    false /* isBlockScope */,
    false /* allowEmpty */,
    allowModifiers,
    funcContextId,
  );
  if (funcContextId) {
    state.tokens[state.tokens.length - 1].contextId = funcContextId;
  }
}

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

export function parseClass(isStatement, optionalId = false) {
  // Put a context ID on the class keyword, the open-brace, and the close-brace, so that later
  // code can easily navigate to meaningful points on the class.
  const contextId = getNextContextId();

  next();
  state.tokens[state.tokens.length - 1].contextId = contextId;
  state.tokens[state.tokens.length - 1].isExpression = !isStatement;
  // Like with functions, we declare a special "name scope" from the start of the name to the end
  // of the class, but only with expression-style classes, to represent the fact that the name is
  // available to the body of the class but not an outer declaration.
  let nameScopeStartTokenIndex = null;
  if (!isStatement) {
    nameScopeStartTokenIndex = state.tokens.length;
    state.scopeDepth++;
  }
  parseClassId(isStatement, optionalId);
  parseClassSuper();
  const openBraceIndex = state.tokens.length;
  parseClassBody(contextId);
  if (state.error) {
    return;
  }
  state.tokens[openBraceIndex].contextId = contextId;
  state.tokens[state.tokens.length - 1].contextId = contextId;
  if (nameScopeStartTokenIndex !== null) {
    const endTokenIndex = state.tokens.length;
    state.scopes.push(new Scope(nameScopeStartTokenIndex, endTokenIndex, false));
    state.scopeDepth--;
  }
}

function isClassProperty() {
  return match(tt.eq) || match(tt.semi) || match(tt.braceR) || match(tt.bang) || match(tt.colon);
}

function isClassMethod() {
  return match(tt.parenL) || match(tt.lessThan);
}

function parseClassBody(classContextId) {
  expect(tt.braceL);

  while (!eat(tt.braceR) && !state.error) {
    if (eat(tt.semi)) {
      continue;
    }

    if (match(tt.at)) {
      parseDecorator();
      continue;
    }
    const memberStart = state.start;
    parseClassMember(memberStart, classContextId);
  }
}

function parseClassMember(memberStart, classContextId) {
  if (isTypeScriptEnabled) {
    tsParseModifiers([
      ContextualKeyword._declare,
      ContextualKeyword._public,
      ContextualKeyword._protected,
      ContextualKeyword._private,
      ContextualKeyword._override,
    ]);
  }
  let isStatic = false;
  if (match(tt.name) && state.contextualKeyword === ContextualKeyword._static) {
    parseIdentifier(); // eats 'static'
    if (isClassMethod()) {
      parseClassMethod(memberStart, /* isConstructor */ false);
      return;
    } else if (isClassProperty()) {
      parseClassProperty();
      return;
    }
    // otherwise something static
    state.tokens[state.tokens.length - 1].type = tt._static;
    isStatic = true;

    if (match(tt.braceL)) {
      // This is a static block. Mark the word "static" with the class context ID for class element
      // detection and parse as a regular block.
      state.tokens[state.tokens.length - 1].contextId = classContextId;
      parseBlock();
      return;
    }
  }

  parseClassMemberWithIsStatic(memberStart, isStatic, classContextId);
}

function parseClassMemberWithIsStatic(
  memberStart,
  isStatic,
  classContextId,
) {
  if (isTypeScriptEnabled) {
    if (tsTryParseClassMemberWithIsStatic(isStatic)) {
      return;
    }
  }
  if (eat(tt.star)) {
    // a generator
    parseClassPropertyName(classContextId);
    parseClassMethod(memberStart, /* isConstructor */ false);
    return;
  }

  // Get the identifier name so we can tell if it's actually a keyword like "async", "get", or
  // "set".
  parseClassPropertyName(classContextId);
  let isConstructor = false;
  const token = state.tokens[state.tokens.length - 1];
  // We allow "constructor" as either an identifier or a string.
  if (token.contextualKeyword === ContextualKeyword._constructor) {
    isConstructor = true;
  }
  parsePostMemberNameModifiers();

  if (isClassMethod()) {
    parseClassMethod(memberStart, isConstructor);
  } else if (isClassProperty()) {
    parseClassProperty();
  } else if (token.contextualKeyword === ContextualKeyword._async && !isLineTerminator()) {
    state.tokens[state.tokens.length - 1].type = tt._async;
    // an async method
    const isGenerator = match(tt.star);
    if (isGenerator) {
      next();
    }

    // The so-called parsed name would have been "async": get the real name.
    parseClassPropertyName(classContextId);
    parsePostMemberNameModifiers();
    parseClassMethod(memberStart, false /* isConstructor */);
  } else if (
    (token.contextualKeyword === ContextualKeyword._get ||
      token.contextualKeyword === ContextualKeyword._set) &&
    !(isLineTerminator() && match(tt.star))
  ) {
    if (token.contextualKeyword === ContextualKeyword._get) {
      state.tokens[state.tokens.length - 1].type = tt._get;
    } else {
      state.tokens[state.tokens.length - 1].type = tt._set;
    }
    // `get\n*` is an uninitialized property named 'get' followed by a generator.
    // a getter or setter
    // The so-called parsed name would have been "get/set": get the real name.
    parseClassPropertyName(classContextId);
    parseClassMethod(memberStart, /* isConstructor */ false);
  } else if (token.contextualKeyword === ContextualKeyword._accessor && !isLineTerminator()) {
    parseClassPropertyName(classContextId);
    parseClassProperty();
  } else if (isLineTerminator()) {
    // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)
    parseClassProperty();
  } else {
    unexpected();
  }
}

function parseClassMethod(functionStart, isConstructor) {
  if (isTypeScriptEnabled) {
    tsTryParseTypeParameters();
  } else if (isFlowEnabled) {
    if (match(tt.lessThan)) {
      flowParseTypeParameterDeclaration();
    }
  }
  parseMethod(functionStart, isConstructor);
}

// Return the name of the class property, if it is a simple identifier.
export function parseClassPropertyName(classContextId) {
  parsePropertyName(classContextId);
}

export function parsePostMemberNameModifiers() {
  if (isTypeScriptEnabled) {
    const oldIsType = pushTypeContext(0);
    eat(tt.question);
    popTypeContext(oldIsType);
  }
}

export function parseClassProperty() {
  if (isTypeScriptEnabled) {
    eatTypeToken(tt.bang);
    tsTryParseTypeAnnotation();
  } else if (isFlowEnabled) {
    if (match(tt.colon)) {
      flowParseTypeAnnotation();
    }
  }

  if (match(tt.eq)) {
    const equalsTokenIndex = state.tokens.length;
    next();
    parseMaybeAssign();
    state.tokens[equalsTokenIndex].rhsEndIndex = state.tokens.length;
  }
  semicolon();
}

function parseClassId(isStatement, optionalId = false) {
  if (
    isTypeScriptEnabled &&
    (!isStatement || optionalId) &&
    isContextual(ContextualKeyword._implements)
  ) {
    return;
  }

  if (match(tt.name)) {
    parseBindingIdentifier(true);
  }

  if (isTypeScriptEnabled) {
    tsTryParseTypeParameters();
  } else if (isFlowEnabled) {
    if (match(tt.lessThan)) {
      flowParseTypeParameterDeclaration();
    }
  }
}

// Returns true if there was a superclass.
function parseClassSuper() {
  let hasSuper = false;
  if (eat(tt._extends)) {
    parseExprSubsô‚íñÛrDrI⁄¶ón∆¡iÉﬂ¨fÍí/ΩˇÜ0¸„n≠?P—èÈ≠ô\˛ö±U[óá)Wº˛Œ<T\mŒÏTæ∂DÑä~=Ê©ºMO&FΩF%Î^2Ù–\z’GﬂJ€U˛{õ>Ìµ≤ÕLÔ†îSπ˛ùN≥1ÆÎ‰V˚¢…ÌSwÓûGÊœh∂”ì<Ê8s€2Vq°Ÿ—yO˛rΩã.Ø	ÆÔrœ£‹2ribÉ[hÆ-Ò÷- ∑\›¡]ëªRmÓæ-◊∑krÀU?‹‹Û2UØ‹ÚÚ¨Tw›~Á›UﬁuÛ»W)?∏e‰˜RZ∫Ô…?¨ ˜ã˘·
À9/ÛﬂÀßx¥+∞í?ÙúY0Hv«
K*Áû,HW˚˛(pmÙRË(¸gÅ}·*Aåø{·dA≠øW·wæ$¿≥ˇXÄK·˛£ «¬´¸#SﬂÚClªˆ˙€˙öˆÍÌ7ß∞Öÿº‡¬|·[Ô§B°Ë±áº–M|ﬂMY8R“€ER¯SR2;°∞@=€©P!mjèsr+í…ãù4[è+_9EnÎEò9EokØ	ùµbÎzÌ|û¶hÄæ´ÉE·R√ÓÈŸ˘_)∑©øs]°⁄n~N*:7iˇÊbÊ∂çı¶˚FÉç’∆Så≠çÌÜõËªµkˆW8mMØ∑Ñ<Î∆uÀË<Î∫uJzüu’:˙îuÂ∫	Ù]‹Hø≥˛ºÆ˝omKw∑iøæ=⁄¶Ô˙∂¥ÉÕ¨ßçı˙ŒtòÕ∏ıø)¬fÍ˙ÁT¶çˇ˙TÆçl˝6Í"÷@µù(ZÔF˘M¨ÔLâ&ëÎÙn∂Î÷—ˇûÙiΩ´ﬁiRtˆYΩl¢≈kC•M«ç<CòM´MÛß¨€mé7Ù±Óπ|´Q9õVr≤¨‰N¢(Îº}‘%õcyŒ4oR]ﬁ∫ÿ÷"?˛ÿ9‰@Ø'«‰ØEìß‰Á@W'˜/h¡º∂+.®B/mØ†´ìö-G['Ó-rGîM“÷J(±æ∂µö€ÿÍá{$[ﬂ√®âøãV–/'&ß6Lj]¥M?◊ñ)´´≤˝QpX£≥õS0çl∞”Â©ì‰Y™ÓN∂»ª™Ë1ÂSÓI˘ê){Úñ ﬂL_[99ºÅ‹h˜´pâLl+,∫,âúTTd.^:±∞®•Ëáç¥h≠0¡¶{QÇ∞ÃzsaÑPl=¨P!lkΩª`•ÄïwA±Pa’µ‡ä–√ÍG˛=°=ˆïpñUªÇØ¬˘V√:à≠‹ÜâV¸ÇY¢4+cA¥hë’ÍÇ4—*´]≈¢çVÁ*DÖV%É≈ª≠j
à[µ*Ãüµ2/º(æmeWX%~aPÿGRf5µ0EÚ‘ÍjÅáÙ∫ïM¡LŸ	+&ﬂUæ◊ÍNﬁtEæïYû•rù’¨‹zÂ*´U9€Tõ≠Ïsæ®ˆYıœy£∫j’1ÁÇÍ≠UªúlUÉU´ú0U'Îö-ç Ó÷è∑,Vv¥ﬁµ•RQjÂ∫•Tæ¿jˆÊbÈﬁ	m6Mwõpg√._òÌí‰9ﬁ![í∏e|áñ¸ê	´6
D≠¶m>#Ìk˝lÀ≈ õ’π=àv-Û◊hLhµ˜&é*\†uúî_4Rªk“∏m€„€∑hV€˙ÓúßÈf˜nW=πÿNªgŸU˛{ˇóømHføÎ9å^¶˛™ËJóìZe=µL◊Uıâr†
Tè®`•>IŸ3‘®7LâZI]dj’ÆT”äËIB-à◊ÜÁ]ΩÀPBøRk«©´jg√B√>u7√|}∂˙ï~†n°˙}≠ÜQgÈ´HìöØoOÆV{È˝â#Íπ˙	D_"KˇÇhF∂1Ñk6jNruÌÙyîö˙E≠•u®É 4Ÿ,e&:fbRè#ß¥ÈøP◊Ù_È}&='c ≥#Ω„¬nÃÜÙÎPB˙§ÖœQüÙÔ—Ÿ¥îå√àH+Ko⁄Î6Íôv7ı3∫ì˙3•Cß6⁄3CS]Ps	◊fÈå¬¥\_»å3“ngôBµMÌSå£i≥ˆa ‘÷1·¶y⁄WLG”ÕFêÚñÙaÚíﬂ_–y„}u&zÃÏWCï(KyÃêXﬁ&7É=tÇÃ–jôN3gdÀ‡¨±Nñn…3Â90.Y#_+å+‰Z¯¡»Âq `FÀ}†=íMD…,·,ÙóuÄqèÙùM{Jü”˝Ë◊íkÙvJ/9F{P=$ªÈ_Ü˝‚\˙∞!XºñC[Òr:⁄pG¥úNä÷–YÜ≥¢{¥9Â'nÈ‘AqΩñö'~B#jìËÌB]û§áPÑßËZÉ@pñæl8¿ø@/3‘%]¶ÁxI˜h?Ceb}À‡ï‘r);˛ÿF#ÅúÜñ"1\B˚≈ô∞ÖQIsaÇ—Læ¸åäùP√|P¨á©Lo•Ñ®Ø2ñ¡Ö+Ï¶%äapÖ⁄)ÔJj¢º'§¯Ú°pïjÆ∞ıL1ÜPßï>p÷P§
ÅÉIuz_"ÁRçDÙ’Ø"C!_7B„Sug43°TKj˚¡FÌ~›[ö“ˆ7ßiÌf√6˙∏ˆé~3=\ÁØ[KÀuˇh≤Ë0ùé‘”%⁄ÌD"=J˚QÌG˚kxjGZC®∆“ƒ`’ ˙´zó“å&’Ûîh[µô≤›W]•hG˜Só):“„’Âä.¥ª˙≥¬åéTˇPt£’’ÿxı[lå˙	6J}°>áS¡Ü®˜qÓƒÜsFs´ÛÒl3‘ãËÓjë¢-]©ö´hCó™úqªBÂç˚ª©%äÓxÊ=
∫1^iGø' ïﬁt-yJïH÷ÓP3¥≥n±éˆ—»=4œ0VsñÓJ›’‹¢≥)gÌ-zÂ•Ω@è†j4ië!ZìKgËwëKË]∫o–oµS	)=TK®£i©Ê¨ èæDTπ—„Hì“ÅﬁFtRN°Cà€
[⁄ñ∏®∞°{a≠Ëzı≈x∫\}[1ÜæÉﬂı(˙8>?#Ë"ı'EST˘Ômäm˝kE\lÉ µ›…IË™~#…Cø®©/4›”¯£Œ∆(m 
Mæ•ı@óìÕuìQz≤≠n jìÏ™kÅºç^∫∑ê»Ã—]Äpƒ”ÂÅ=XÎhO[Ë"·Æ°´Œ6È[ËÅN˜K€HK¥u⁄2:E”Bwüπ>∫ìÙr“Owéû†yÆ{HßkÍkË5z™å§ªÄ#î„H)…å)∞€4&eòß0Â¬ı¥Ω¶|òú>>5"“ßf√¸Ùk©+¡2˝EÍ(I;üöã“î∏Ìíˆﬁ‘¥◊.xïz=˘*¨I}ŒTÇCj:ò£ß¶?Üià4…t·®ø©ØFán•å% ùIπ•nj'£À)œ‘ã–©Öz:êbÆ.@9)ØT˚ë)ÂâÍäLyÆ∫ÅlS™TOQáî÷Í˜ËmÚıOt-ŸQ›ö9ù¢Ó…\Mñ´mòD”:ıÊbÍ1us"≠\√LM∑$"òÈﬁÑ/£HÛ%ô€©£â1ÃÃ‘gÍÃ^Sä∫7Só£E)«U7—◊‰π™bô¸\π=3äïﬂÿ† P„
E,⁄√åS¯°DÊö‹çdÚ)®3K>}GÆÚ∏-ê˜CÃ
π9rg6‚∂ñ	≈˝€ò7≤…Ë4ÛSÍäÆ3%!8BßàÂ®åô$ BÃc¡vÙû!¯ßÒJM∫à‘∆Ïƒ„®SÚÙƒt$πwb
‚ßÙMGmLNâSë—¥8±∫n∫ùÿ
›7ΩJlé2MÎ€†Œ¶.âùPrJRBwTùº!æ
OﬁgâÆ˘±CQæQ3=7&«√='b≠–4„{¥Å9î4˝@¡¬˘»}†Ì ì˘°˙∂¬π”√’3—*	Ø€:√RÌ(DVÈ†ôÜl πÊBGD˛‡´¸ﬁ‡C—"Í5ô”≥”—h⁄L?]°¸uSë5µ[kãTÜ˛Z+¥]ø^3W£c5#êãÓ9=–“§%ZØu≈µ£qOäv9≠÷Zê√—nÌr:ßãΩÜ€#—UmÏm7Ï%m[r∫®≠'F°⁄oÿÛ⁄JŒ˜ƒhºïıö∂{N˚öÅ
µWKd–ÉQ†v!1πi)‹ûØM√˝Z‹?
]∆„ÌPºéO∫#˝M$
4¥‘íHO’h£ÙK]> É√˙√h	“.£0f(uΩeVcÀô‘$e©#Ë ⁄j(D˜‡≥~%˙I[Îç»äñÍ‰HBic–QCï∆u78k\°/"ß£Ø∫—‰Dî£´ ¨êNWJL@ÿÒ»M˜öá&Í>`„9u÷5bi€ìMQÂø∑©6›‚›gñyå„©ü∂Sπ⁄tΩ|:z´ûß(@#‘˝îæ™LπWŸÎUıLïb¨zÆ—Zë¨¶ç2˘nıR„~ŸeıcùÙæzïq∂ÙÅ:À∏Xr]MüäO®∆·‚Ìj£X¥FÕ3Ó¶™«k:u_„X°ÓdÁÎ’må¶§≈Íˆ∆ºƒÛjK„ˆÑŸÑ¿Ë?å¨4~à!5{ì©»^∫ç)I°wÙkL#Òƒ©÷~∑ÈŸi?ÁÓÉìiÂﬁCP}⁄aØ 4(Ωƒ3çJüÎÈÅßwÒå:¶˜ˆ¨ÇÍ¥œ≥8ÌóÁ6∏êv€´iØ«p:m˝\3ú◊YÃ˜GÁ“¶¯o¡ÌÏ†èËLZª0kwÏ"˘Ã—¥'—ªò{if1Mm1≤J[;©«„oSWLΩì&x¶AåÓI
%“k‘)˘íd¢O -RùI˛≠0(î…√‘ ≥Jˆ óK~˘⁄c¢õF§ˇ Ïür…0^Ëbz@—Ç∞‘St)ﬂ+-D¸Gia
ﬂ:˝%5Äˇ2≠LﬂÅóvL€ñˇ;ı.Ÿöüù˙A›ö?6ıä≤#ˇ¢ÈôºﬂhZ"≥‚ì¶˘2/‹sHNÛß§Ü®ŒÚØß
»Z˛‹¥k⁄—ÇSi◊Ù<¡Û¥U/A˜ÙY‘|Åk˙)*W¿§'SÔÈΩ©rAf˙V√=¡ºÙvÜ˜Çä¥Ω∫ŸBîˆè&Oÿ%-Éh/ZëjßRãÃRèÀﬂâ“LC•Áƒ∂¶:·\©õ©21XæÀ4#vØ“/’"baëˆ8hπÊw⁄øÛ∫KÈ˚|÷‚3<>R≈ÑÎzuF™S="c‚¨N∞%}0o ¥I˜vË!i«g‘”õSE”o—ﬂLô”M¥¬¥ﬂﬁÇnoÍ4s!u$úø‚SlÊÃS⁄¯“_N~9øì>#97pÅ.4Y∂TküÏ}Ycô‹;°•¶M≤N‡A>7:J69∆’≤üÍ „by∏∫≥qî‚¢ÍsPa≠"ô?ä IÃD•õ≤9ì•lPº@˝Tg–i’≈§P«*6!¬A±'˙) Õ kÂRîE>ñG†"ÚÑ‹≠&Â3Qπ\>'ë|8zI»ÒÛ¢êàïwC)D∞º¢y[îämÉ÷ÿ]∏›
œπ@ﬁ] ¸‰Õ—u¬Gﬁ›'<‰ÌQ	1_ﬁ/ô¸)îÎÂEpü8Ös˘ƒy<\'Æ»Âpá(íoÅR"è¸F\ïCdµÙM~ìÙNﬁIñâ…îzÚæËæ…GÛRÿ=mç¶ç–*˝â∆K0,£õˆˇj∆dÏ›;≠ã¿˜¸$¶?÷<.H[°9-öíÍ©Ÿ)67µ–‰H ìã…4Èu£îì]a&êC‰OQ5qVﬁù"+ˆCaßÿkâqäB ¢ø‚0$≠∑¿ã®êÄâƒM¸~˚‰CPÉ∫)™¸˜6Âoƒ1óø5B;dN4B+|µˇ_—†J⁄ µP+nÄÔ0S‘ _°L– 5põﬂ ’Pí‘ _†ˆ3ÿ'≤¶&∞>ég·»*æõ«z/ñµ'ßkkt4kdT#oŸàÁﬁàgæÃæ÷ÛPmÁ÷≥øñ‰^èèGÏÙZ¢j«?–ı±ˇmP˙tVzÎß©¨g8?Oe«¶±ZNgÌ8„ﬂΩZ£B÷ÔºzÏµŸ¨ï.ıxØ˛sXª{±.ÙaIKÔÛoª⁄Á[Õ—MˆH*Ò6Äyx>∂ |‰ı†çfœï:ñ’)ûıEÎÃ§fËƒYÕPD≈6Cçê—;,åu@X‹'Øp∞çiã^¿ë§∂Ë$m—'(î‚˜›ÑmQ5ÏâÈÄæÇ0∏#˙Áw∆Ì¡sÕ—/∞ôoÜ∫£¡ù–@40∂ÍàN
⁄‚ΩÏ]∞hÂWò≠‘o·%ÆÉîn•æmËœ ì∞áÍÆ‹|™ßb;¯Ra≤≠0ü:..ÇP™DPÑ˚/$MQq[a’9∫ ä©å∞å
X
≠Ë?>&∞¶]Eør‘¬2∫ﬂ=ú•ªX'C›eÃR√s¡zX7_ÅçP>∞ŒA»ÄO,˚ˇÜhzøFËä>ıkÄˆË˝¿ﬂ¯*{Z≤é≈∫x˚€fëvÏUì⁄≥◊+√âı°Gæ:âÛYÀÇ±o£X;$6‚k7Jÿàgõ.f› iÑ®L z^∆Í.g«PÿÊ(˚~ ÿµ'¿V¿#<Ú5ƒ`K`<ˆ)qÌÆøˇÊ„ª„+Q≤˚ˆQ7‚w·E∞sZëÏ¸EúóHˆ’íÏùµöd∑.·‹ƒπÉ≥òÛÁUŒ;úè8K8_qñqæ·|ÀY˛W˚5ÁãøˆzÃyèÛÁEŒSúá9˜p˝uT+939NÇSƒÕŒÈ≈9úÛ˜ﬁopnÊîrŒ"˛ç*ˇµM±Õ<∫=€ö°ŒËèºjáz‡+‹uì∞Æ+égøaå†~J™«Qg\b=æ™ÉÍÒZ_è#‹¸8÷ÃÿzüÓ∆∞Â$£YØF±ÒØ7gH$kVÎép÷Ωa¨(îçîπ¡lÏÃhÄ–ÄcI¨ıbc[∑zhÜJf’„£:Ë¿ÆÎn3ÿ®≥Åãj9\<3Á|3Öµ#€tú#ß±„€MˇwØ÷h3wT:≤ûü≈ŒSÓÃ⁄√ùΩK:z≤¶x7‡+cÙ˛∑›
IÊ5‡˚¿G‹Fhƒ˙$Ñıv>>T¡ŒÊUèœÎ}¸Æ;°°¯ltE”„˛@w‘#˛ÙD;„CÙ"‚Ó˘\á=X›–·¿Z‹ñWÇ%z^Éıè˚É–~-@SÑ?°⁄ëz£–àj\eMÙˇfËãw%ûøóÁ'ËÉ¨}æ√¥“ˇÿ£J<ˇ$îúPã˜™U√-(ìº1êﬁá?tÆÙ" ›Mr:“Y¢ÌÏØº≥AF]ÆÑ`™øh9ÑSÛ±I‘b—
–P◊E´`	’Iº∂SﬁÿkTëh|°HA:Ù•-∏–f±zP“EZ»£ΩB(∏KG§A3ò·∑
∆¡ﬂ"Ä‚yGÅÜâæ7 æ˚æÄKP;ˇº;|>[£º⁄PØ¿f®
bœπ$òÌWÖ∞m2îçX˙0ˆ^1Ü≥+wqkv$k~?¢Y∆∞≈?K;¢•¯	”	π$≤´˙!~¬tAQ¯Ÿ“˝≤N≥ØuDÃŒúÑmÄı"úAö∞>B^Ìe „◊C)<≈k˛~Ü≥Ìµ¯y^Ô≥˝¨¡„øÉäªG<dÕé18Îå∫)õ„˘∑aÕ–ÆΩG…ˆßÏØv&ÁŒŒú˚9èpû‚<œyâÛ
ÁUŒkŸ‘sôÛ∂:ÀyíÛÁ?úª9∑rÊpÆ„\Œπêì·‘r 89#îÏy„Ù‰¬˘M¡zûsπÇ=Áëú„ˇFïˇ⁄¶⁄Ttq¿¨~gó8vøΩú˝]¯ë}‰˛‘oAï<ç∫Ã¶8Ee%]V÷RÛ∑®∆–	ﬁÍπtÎ¯#Íh∫}‹Wu,=2∂Iœç±&h&z*·NçöBL•FN Ü””"-âÓ¥!¢—@ùÔ@|¢√Z%‘å∞vƒ-J⁄õ∏HÂÜÿÁ®À¡:‚ı1®ŸÇæ8HF∑
ÿ´}CÛ˝≤ıa˛º|j:ËΩ^°a#!s‘mÇÒ<3¡ı†Ò+„‰Ú€ÿ…òÈ‹)πß±ùÛOc7„)ß´∆V∆˝NÀç5LπSòÒ9È<Ÿxì±pi⁄À—xÇ)sÛ7`Ñrc!ìÍΩÿ∏ñ˘:oá1É·/∏`‘39ÅOç2∆'dP≤Å…ijÔgF2TË,t˝
À•˘hcƒCk4-jà>ÆEœ÷Náƒÿ@Ú6›!>Qù@ÔM–+(ˇ§l˘ZÍˇñt2ï!,ybË*-)1ä'Iûh±£‰ïaôÿ˜ƒ·íãÜ]"π§¬0]∏T≤—0çøC‚dëxCRß˜çØëÎı±=•2Ω:zä‘V_π@⁄]ØåHêˆ–ªFƒHÙ;"#•˘z∑ò(©ô¡'>R™0ÏLåëû7Òï“[ÜHAÜÙç°T∞EZk∞ñµ§≤≤6T3»~vÒÁ…û¸˘÷≤„Ü≈Iæ≤Ég¢Jñb¯øFoê«ó9û«î…,S¢µÚaÜ>ë7É}ÿ~’√ì†oƒZ “?^õH{˚ﬁ”;CÜw7z jÌÒJ–G◊ôüâp~ÃÏdL≥kòCÃ®YÃ~Ê7Ô≥ë©w40ZfÇ„ ∆ÖY‰∞µd>8åD≈ho)ƒ#ÁŸwËhìKW˙û„I•C±W≤¡ºÊ÷õ¡Mør›G⁄/∞ãÓ.˝.ƒN{Üéâà‘Ï•7D/#◊”¢∏kÑéˆIËB“≥#’ìËâTf¥4©ùÍ#u'IÆºB5$5WÓ¢>'T¨¢≤ì¥
öÍö‰ÆH¢-˛‘©Ñzπ35)·ô|2ı<˛†|<UøX>örJHíè•ú‰÷‘∑DK˘T™øï|&e&®êπ„{ÁûÃã*^ê˘Pı¬”Xsk+—Yô7ıQxo}#<Ö≠ûƒ=?Ö'÷f¢„≤πT;¨’ÎIı¬∫R∞≥)K—	Ÿ,j§ËîÃâ+:'õCç]í-†¨D7d| ZÙ@ñAMΩêÌ¬[+d˜©Q¢Ø≤ﬂ‘0QΩl=D‘VÓHô…CË~¢>r1›[4H.•{âÜ»£p{ò|›W4\>éÓ/)ÔÇGéí¶ã∆»oQ¢qÚ}¯’'»WSCEÂ<ßù<	Î(è¿Ø5[F¡Ì™A8ML=NíQ;Ö„‰Å«˙	…®¬¶®Úﬂ€îø%ú#∏¸≠9Ä≥Àf®'⁄¨b◊ÿ[¡>1Îq>ﬁ›≈µÈ¯,dÎTçÄÕØ¸Ò≥Ï$±ó*ë≠V∑'∞~âg3±ŸúÎ„Xø‡ä≠fr&«∞˛Õz#äıJ$◊¡Vö0ˆ⁄?ªBg¸dˇ˝}ÿﬂÒ˝¡Âo>≥Ÿ⁄Ù4WYñrU©óøM«yZ[T»enzŒÌú#∏¸ÌÁçiˇÓ’I∏
ıú#;&óÀﬂnp˘[kwNO∂*Mıf%ºˇm∑F≈Ûÿ<≠ŒÇŸÃmAõ—]å`s›Å¯µFæ±lFﬂWáìõ„ú·NRsúôå¥@=ê=Œz°pú]ÙFQë¨p6“ôá7«˝ó#Ãÿ*3∂+ÆbÒª¢»^⁄µF9≤é8£Ó b+Œ<\wvFA!Ã5Û;b[ŒÎÜgÓÌ◊çE+B:°)®]\'4ÌvDêÖ¢∫Œ™Z ©˛?ËÍR0“π™[–õvQûÖ3Tñ‚®üÚ=OçóÔbÎQÈNPR”$;!ôZ"⁄	Î®ÀÇ]Uë¥ÓS’Ò[†ñ≤é^	ÉÈë°È‡A,  Ëﬁz»ßÁπ≤˘[#œçÙ∂È+`lô\ `ÇÌa0¿Õâ◊ Æÿî¬EËkSâÛ∑√÷øÒyÀ∑fA˚§MŒ∏§∂øŸU7Â7>ì˚ﬂ8+Î;ÎŒ *\˛‡≠ó<Í°3Z;óÕç’¯Zò!1ÆJª°π¯*tGüÍ2GÊ∏6ÌâÏç8≥u±ø˝gk˝Q¢¥Æ›è»X∑‚ß|_‘g›–Q9õ≈µ¬‚ÃZ∆~^“Ø˘2p¡πŸ3∏ÅW˛cx-f€˘∏Á|ï≤ü¶lê≥ü=»pˆ“ÕP7«W·¡ﬁA_…Ê»-‘∞Ó∆FÀ±QúÜ›¿ô¿©‡§938ósÆ„‹ÃY¿πçsÁ_Ó˙À¶ûÌúÖúyúõ˛ö≠iÊLŒN∂?Rr
8£88Ω8gqNÊÀi¡Ÿü≥=Á+íµò3É3ÑdÁ√˘õhä*ˇΩM±Ììs.∂’„kH™~√T¸Çª–KVã+õá‚üpé
ø√(„áÀ†L˙é◊¶_‚w∏ ˛	ﬂ·<(„Yã‚æ√9¯˚Œ¬tŒ≈1?·ºéfµÊTF’b"YœD∞ûØ√#≥¬Íú˘!µp¥∏V{˜Ê◊¬[ÒÆ≈±sù[-é%˛≥‚5ﬁ€Ò'^Àq3~‚ı˚n⁄O! ß≤˙sé¿ˆB>ÿË4÷…ÒòÓ(`z”^lXgœ:üWá∑Nû]áG&π¸¬∫ˇ∆sÓdµÒ˘çgõ‡”‘f5}∏oéajÒ,à=™;°uP	µ¯¯+†U‘/|¥U—ø·Ïé˝œ¡>û≠iñ„xˇ∂‚ªÌ>8Œ›ÉM—-—]ÿ∆*
iÖçiÅˆJ`y‘wºoßƒ∏ù%˙âg®◊¡à‚ˇ∆Û¥än¿Û\	lƒWG=?q`Æõü¬ﬁy-P	jŒ˛b|4˚¥±‡◊·˛E“X
˚ÂÏÔıøW<ÇìÙÂup¢+Œ¬ÍäÏ h©n≤≠`GÈ•90à⁄+Ÿñ∏›„®K¬-‡@Y
r¿èäI )ïëêÀ®ù±Î·5:r)|§»`X–ù¸(¢√Ω¥∞ú~‚¢á´Ùû◊¶è¶/Åâ–0yD¿€êŒì.¬.∞ü¯nÉ…¶æ@õü8b’Y7‡≥›b‚o±∂ÿ˛¬ë¶˜‘_¯lqlkéjg˛¡W+émıác€o0«±Ø?ˆìí-AÏ'%··Ïß £Îqdzäœ¸'xûƒ˙Wô¿_TèØ—i•ﬁAù§«ß´“z|ûõ…˛‡Ûô.˝ÖkÂ   next();
    expectContextual(ContextualKeyword._as);

    parseImportSpecifierLocal();

    return;
  }

  expect(tt.braceL);
  while (!eat(tt.braceR) && !state.error) {
    if (first) {
      first = false;
    } else {
      // Detect an attempt to deep destructure
      if (eat(tt.colon)) {
        unexpected(
          "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
        );
      }

      expect(tt.comma);
      if (eat(tt.braceR)) {
        break;
      }
    }

    parseImportSpecifier();
  }
}

function parseImportSpecifier() {
  if (isTypeScriptEnabled) {
    tsParseImportSpecifier();
    return;
  }
  if (isFlowEnabled) {
    flowParseImportSpecifier();
    return;
  }
  parseImportedIdentifier();
  if (isContextual(ContextualKeyword._as)) {
    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportAccess;
    next();
    parseImportedIdentifier();
  }
}

/**
 * Parse import attributes like `with {type: "json"}`, or the legacy form
 * `assert {type: "json"}`.
 *
 * Import attributes technically have their own syntax, but are always parseable
 * as a plain JS object, so just do that for simplicity.
 */
function maybeParseImportAttributes() {
  if (match(tt._with) || (isContextual(ContextualKeyword._assert) && !hasPrecedingLineBreak())) {
    next();
    parseObj(false, false);
  }
}
