/* eslint max-len: 0 */

import {
  eat,
  lookaheadType,
  lookaheadTypeAndKeyword,
  match,
  next,
  popTypeContext,
  pushTypeContext,

} from "../tokenizer/index";
import {ContextualKeyword} from "../tokenizer/keywords";
import {TokenType, TokenType as tt} from "../tokenizer/types";
import {input, state} from "../traverser/base";
import {
  baseParseMaybeAssign,
  baseParseSubscript,
  baseParseSubscripts,
  parseArrow,
  parseArrowExpression,
  parseCallExpressionArguments,
  parseExprAtom,
  parseExpression,
  parseFunctionBody,
  parseIdentifier,
  parseLiteral,

} from "../traverser/expression";
import {
  baseParseExportStar,
  parseExport,
  parseExportFrom,
  parseExportSpecifiers,
  parseFunctionParams,
  parseImport,
  parseStatement,
} from "../traverser/statement";
import {
  canInsertSemicolon,
  eatContextual,
  expect,
  expectContextual,
  isContextual,
  isLookaheadContextual,
  semicolon,
  unexpected,
} from "../traverser/util";

function isMaybeDefaultImport(lookahead) {
  return (
    (lookahead.type === tt.name || !!(lookahead.type & TokenType.IS_KEYWORD)) &&
    lookahead.contextualKeyword !== ContextualKeyword._from
  );
}

function flowParseTypeInitialiser(tok) {
  const oldIsType = pushTypeContext(0);
  expect(tok || tt.colon);
  flowParseType();
  popTypeContext(oldIsType);
}

function flowParsePredicate() {
  expect(tt.modulo);
  expectContextual(ContextualKeyword._checks);
  if (eat(tt.parenL)) {
    parseExpression();
    expect(tt.parenR);
  }
}

function flowParseTypeAndPredicateInitialiser() {
  const oldIsType = pushTypeContext(0);
  expect(tt.colon);
  if (match(tt.modulo)) {
    flowParsePredicate();
  } else {
    flowParseType();
    if (match(tt.modulo)) {
      flowParsePredicate();
    }
  }
  popTypeContext(oldIsType);
}

function flowParseDeclareClass() {
  next();
  flowParseInterfaceish(/* isClass */ true);
}

function flowParseDeclareFunction() {
  next();
  parseIdentifier();

  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  expect(tt.parenL);
  flowParseFunctionTypeParams();
  expect(tt.parenR);

  flowParseTypeAndPredicateInitialiser();

  semicolon();
}

function flowParseDeclare() {
  if (match(tt._class)) {
    flowParseDeclareClass();
  } else if (match(tt._function)) {
    flowParseDeclareFunction();
  } else if (match(tt._var)) {
    flowParseDeclareVariable();
  } else if (eatContextual(ContextualKeyword._module)) {
    if (eat(tt.dot)) {
      flowParseDeclareModuleExports();
    } else {
      flowParseDeclareModule();
    }
  } else if (isContextual(ContextualKeyword._type)) {
    flowParseDeclareTypeAlias();
  } else if (isContextual(ContextualKeyword._opaque)) {
    flowParseDeclareOpaqueType();
  } else if (isContextual(ContextualKeyword._interface)) {
    flowParseDeclareInterface();
  } else if (match(tt._export)) {
    flowParseDeclareExportDeclaration();
  } else {
    unexpected();
  }
}

function flowParseDeclareVariable() {
  next();
  flowParseTypeAnnotatableIdentifier();
  semicolon();
}

function flowParseDeclareModule() {
  if (match(tt.string)) {
    parseExprAtom();
  } else {
    parseIdentifier();
  }

  expect(tt.braceL);
  while (!match(tt.braceR) && !state.error) {
    if (match(tt._import)) {
      next();
      parseImport();
    } else {
      unexpected();
    }
  }
  expect(tt.braceR);
}

function flowParseDeclareExportDeclaration() {
  expect(tt._export);

  if (eat(tt._default)) {
    if (match(tt._function) || match(tt._class)) {
      // declare export default class ...
      // declare export default function ...
      flowParseDeclare();
    } else {
      // declare export default [type];
      flowParseType();
      semicolon();
    }
  } else if (
    match(tt._var) || // declare export var ...
    match(tt._function) || // declare export function ...
    match(tt._class) || // declare export class ...
    isContextual(ContextualKeyword._opaque) // declare export opaque ..
  ) {
    flowParseDeclare();
  } else if (
    match(tt.star) || // declare export * from ''
    match(tt.braceL) || // declare export {} ...
    isContextual(ContextualKeyword._interface) || // declare export interface ...
    isContextual(ContextualKeyword._type) || // declare export type ...
    isContextual(ContextualKeyword._opaque) // declare export opaque type ...
  ) {
    parseExport();
  } else {
    unexpected();
  }
}

function flowParseDeclareModuleExports() {
  expectContextual(ContextualKeyword._exports);
  flowParseTypeAnnotation();
  semicolon();
}

function flowParseDeclareTypeAlias() {
  next();
  flowParseTypeAlias();
}

function flowParseDeclareOpaqueType() {
  next();
  flowParseOpaqueType(true);
}

function flowParseDeclareInterface() {
  next();
  flowParseInterfaceish();
}

// Interfaces

function flowParseInterfaceish(isClass = false) {
  flowParseRestrictedIdentifier();

  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  if (eat(tt._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (!isClass && eat(tt.comma));
  }

  if (isContextual(ContextualKeyword._mixins)) {
    next();
    do {
      flowParseInterfaceExtends();
    } while (eat(tt.comma));
  }

  if (isContextual(ContextualKeyword._implements)) {
    next();
    do {
      flowParseInterfaceExtends();
    } while (eat(tt.comma));
  }

  flowParseObjectType(isClass, false, isClass);
}

function flowParseInterfaceExtends() {
  flowParseQualifiedTypeIdentifier(false);
  if (match(tt.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}

function flowParseInterface() {
  flowParseInterfaceish();
}

function flowParseRestrictedIdentifier() {
  parseIdentifier();
}

function flowParseTypeAlias() {
  flowParseRestrictedIdentifier();

  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  flowParseTypeInitialiser(tt.eq);
  semicolon();
}

function flowParseOpaqueType(declare) {
  expectContextual(ContextualKeyword._type);
  flowParseRestrictedIdentifier();

  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  // Parse the supertype
  if (match(tt.colon)) {
    flowParseTypeInitialiser(tt.colon);
  }

  if (!declare) {
    flowParseTypeInitialiser(tt.eq);
  }
  semicolon();
}

function flowParseTypeParameter() {
  flowParseVariance();
  flowParseTypeAnnotatableIdentifier();

  if (eat(tt.eq)) {
    flowParseType();
  }
}

export function flowParseTypeParameterDeclaration() {
  const oldIsType = pushTypeContext(0);
  // istanbul ignore else: this condition is already checked at all call sites
  if (match(tt.lessThan) || match(tt.typeParameterStart)) {
    next();
  } else {
    unexpected();
  }

  do {
    flowParseTypeParameter();
    if (!match(tt.greaterThan)) {
      expect(tt.comma);
    }
  } while (!match(tt.greaterThan) && !state.error);
  expect(tt.greaterThan);
  popTypeContext(oldIsType);
}

function flowParseTypeParameterInstantiation() {
  const oldIsType = pushTypeContext(0);
  expect(tt.lessThan);
  while (!match(tt.greaterThan) && !state.error) {
    flowParseType();
    if (!match(tt.greaterThan)) {
      expect(tt.comma);
    }
  }
  expect(tt.greaterThan);
  popTypeContext(oldIsType);
}

function flowParseInterfaceType() {
  expectContextual(ContextualKeyword._interface);
  if (eat(tt._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (eat(tt.comma));
  }
  flowParseObjectType(false, false, false);
}

function flowParseObjectPropertyKey() {
  if (match(tt.num) || match(tt.string)) {
    parseExprAtom();
  } else {
    parseIdentifier();
  }
}

function flowParseObjectTypeIndexer() {
  // Note: bracketL has already been consumed
  if (lookaheadType() === tt.colon) {
    flowParseObjectPropertyKey();
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
  expect(tt.bracketR);
  flowParseTypeInitialiser();
}

function flowParseObjectTypeInternalSlot() {
  // Note: both bracketL have already been consumed
  flowParseObjectPropertyKey();
  expect(tt.bracketR);
  expect(tt.bracketR);
  if (match(tt.lessThan) || match(tt.parenL)) {
    flowParseObjectTypeMethodish();
  } else {
    eat(tt.question);
    flowParseTypeInitialiser();
  }
}

function flowParseObjectTypeMethodish() {
  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  expect(tt.parenL);
  while (!match(tt.parenR) && !match(tt.ellipsis) && !state.error) {
    flowParseFunctionTypeParam();
    if (!match(tt.parenR)) {
      expect(tt.comma);
    }
  }

  if (eat(tt.ellipsis)) {
    flowParseFunctionTypeParam();
  }
  expect(tt.parenR);
  flowParseTypeInitialiser();
}

function flowParseObjectTypeCallProperty() {
  flowParseObjectTypeMethodish();
}

function flowParseObjectType(allowStatic, allowExact, allowProto) {
  let endDelim;
  if (allowExact && match(tt.braceBarL)) {
    expect(tt.braceBarL);
    endDelim = tt.braceBarR;
  } else {
    expect(tt.braceL);
    endDelim = tt.braceR;
  }

  while (!match(endDelim) && !state.error) {
    if (allowProto && isContextual(ContextualKeyword._proto)) {
      const lookahead = lookaheadType();
      if (lookahead !== tt.colon && lookahead !== tt.question) {
        next();
        allowStatic = false;
      }
    }
    if (allowStatic && isContextual(ContextualKeyword._static)) {
      const lookahead = lookaheadType();
      if (lookahead !== tt.colon && lookahead !== tt.question) {
        next();
      }
    }

    flowParseVariance();

    if (eat(tt.bracketL)) {
      if (eat(tt.bracketL)) {
        flowParseObjectTypeInternalSlot();
      } else {
        flowParseObjectTypeIndexer();
      }
    } else if (match(tt.parenL) || match(tt.lessThan)) {
      flowParseObjectTypeCallProperty();
    } else {
      if (isContextual(ContextualKeyword._get) || isContextual(ContextualKeyword._set)) {
        const lookahead = lookaheadType();
        if (lookahead === tt.name || lookahead === tt.string || lookahead === tt.num) {
          next();
        }
      }

      flowParseObjectTypeProperty();
    }

    flowObjectTypeSemicolon();
  }

  expect(endDelim);
}

function flowParseObjectTypeProperty() {
  if (match(tt.ellipsis)) {
    expect(tt.ellipsis);
    if (!eat(tt.comma)) {
      eat(tt.semi);
    }
    // Explicit inexact object syntax.
    if (match(tt.braceR)) {
      return;
    }
    flowParseType();
  } else {
    flowParseObjectPropertyKey();
    if (match(tt.lessThan) || match(tt.parenL)) {
      // This is a method property
      flowParseObjectTypeMethodish();
    } else {
      eat(tt.question);
      flowParseTypeInitialiser();
    }
  }
}

function flowObjectTypeSemicolon() {
  if (!eat(tt.semi) && !eat(tt.comma) && !match(tt.braceR) && !match(tt.braceBarR)) {
    unexpected();
  }
}

function flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {
  if (!initialIdAlreadyParsed) {
    parseIdentifier();
  }
  while (eat(tt.dot)) {
    parseIdentifier();
  }
}

function flowParseGenericType() {
  flowParseQualifiedTypeIdentifier(true);
  if (match(tt.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}

function flowParseTypeofType() {
  expect(tt._typeof);
  flowParsePrimaryType();
}

function flowParseTupleType() {
  expect(tt.bracketL);
  // We allow trailing commas
  while (state.pos < input.length && !match(tt.bracketR)) {
    flowParseType();
    if (match(tt.bracketR)) {
      break;
    }
    expect(tt.comma);
  }
  expect(tt.bracketR);
}

function flowParseFunctionTypeParam() {
  const lookahead = lookaheadType();
  if (lookahead === tt.colon || lookahead === tt.question) {
    parseIdentifier();
    eat(tt.question);
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
}

function flowParseFunctionTypeParams() {
  while (!match(tt.parenR) && !match(tt.ellipsis) && !state.error) {
    flowParseFunctionTypeParam();
    if (!match(tt.parenR)) {
      expect(tt.comma);
    }
  }
  if (eat(tt.ellipsis)) {
    flowParseFunctionTypeParam();
  }
}

// The parsing of types roughly parallels the parsing of expressions, and
// primary types are kind of like primary expressions...they're the
// primitives with which other types are constructed.
function flowParsePrimaryType() {
  let isGroupedType = false;
  const oldNoAnonFunctionType = state.noAnonFunctionType;

  switch (state.type) {
    case tt.name: {
      if (isContextual(ContextualKeyword._interface)) {
        flowParseInterfaceType();
        return;
      }
      parseIdentifier();
      flowParseGenericType();
      return;
    }

    case tt.braceL:
      flowParseObjectType(false, false, false);
      return;

    case tt.braceBarL:
      flowParseObjectType(false, true, false);
      return;

    case tt.bracketL:
      flowParseTupleType();
      return;

    case tt.lessThan:
      flowParseTypeParameterDeclaration();
      expect(tt.parenL);
      flowParseFunctionTypeParams();
      expect(tt.parenR);
      expect(tt.arrow);
      flowParseType();
      return;

    case tt.parenL:
      next();

      // Check to see if this is actually a grouped type
      if (!match(tt.parenR) && !match(tt.ellipsis)) {
        if (match(tt.name)) {
          const token = lookaheadType();
          isGroupedType = token !== tt.question && token !== tt.colon;
        } else {
          isGroupedType = true;
        }
      }

      if (isGroupedType) {
        state.noAnonFunctionType = false;
        flowParseType();
        state.noAnonFunctionType = oldNoAnonFunctionType;

        // A `,` or a `) =>` means this is an anonymous function type
        if (
          state.noAnonFunctionType ||
          !(match(tt.comma) || (match(tt.parenR) && lookaheadType() === tt.arrow))
        ) {
          expect(tt.parenR);
          return;
        } else {
          // Eat a comma if there is one
          eat(tt.comma);
        }
      }

      flowParseFunctionTypeParams();

      expect(tt.parenR);
      expect(tt.arrow);
      flowParseType();
      return;

    case tt.minus:
      next();
      parseLiteral();
      return;

    case tt.string:
    case tt.num:
    case tt._true:
    case tt._false:
    case tt._null:
    case tt._this:
    case tt._void:
    case tt.star:
      next();
      return;

    default:
      if (state.type === tt._typeof) {
        flowParseTypeofType();
        return;
      } else if (state.type & TokenType.IS_KEYWORD) {
        next();
        state.tokens[state.tokens.length - 1].type = tt.name;
        return;
      }
  }

  unexpected();
}

function flowParsePostfixType() {
  flowParsePrimaryType();
  while (!canInsertSemicolon() && (match(tt.bracketL) || match(tt.questionDot))) {
    eat(tt.questionDot);
    expect(tt.bracketL);
    if (eat(tt.bracketR)) {
      // Array type
    } else {
      // Indexed access type
      flowParseType();
      expect(tt.bracketR);
    }
  }
}

function flowParsePrefixType() {
  if (eat(tt.question)) {
    flowParsePrefixType();
  } else {
    flowParsePostfixType();
  }
}

function flowParseAnonFunctionWithoutParens() {
  flowParsePrefixType();
  if (!state.noAnonFunctionType && eat(tt.arrow)) {
    flowParseType();
  }
}

function flowParseIntersectionType() {
  eat(tt.bitwiseAND);
  flowParseAnonFunctionWithoutParens();
  while (eat(tt.bitwiseAND)) {
    flowParseAnonFunctionWithoutParens();
  }
}

function flowParseUnionType() {
  eat(tt.bitwiseOR);
  flowParseIntersectionType();
  while (eat(tt.bitwiseOR)) {
    flowParseIntersectionType();
  }
}

function flowParseType() {
  flowParseUnionType();
}

export function flowParseTypeAnnotation() {
  flowParseTypeInitialiser();
}

function flowParseTypeAnnotatableIdentifier() {
  parseIdentifier();
  if (match(tt.colon)) {
    flowParseTypeAnnotation();
  }
}

export function flowParseVariance() {
  if (match(tt.plus) || match(tt.minus)) {
    next();
    state.tokens[state.tokens.length - 1].isType = true;
  }
}

// ==================================
// Overrides
// ==================================

export function flowParseFunctionBodyAndFinish(funcContextId) {
  // For arrow functions, `parseArrow` handles the return type itself.
  if (match(tt.colon)) {
    flowParseTypeAndPredicateInitialiser();
  }

  parseFunctionBody(false, funcContextId);
}

export function flowParseSubscript(
  startTokenIndex,
  noCalls,
  stopState,
) {
  if (match(tt.questionDot) && lookaheadType() === tt.lessThan) {
    if (noCalls) {
    ~‡|Ã,-•À%hwØn@†“€,ç›á8N‰ç¸¯ĞÇp~4\x8.+‚Â²€y"–ËÆ±Ü76äfx,—z=Ùì\Î¾œ|Ù¸œO,ÕĞÙœœ#üÕH›:'÷‘uwÄ‘à¹d›Ë¡:s°\ğçœæáò".¯œ"t`nYŸcóArÃ:8=ÉøÜ\~xö£Gpâ
€Ÿƒÿ4KY® bò‚Bp’Ùi¶ÄI¶ãÈÓla9‡Â\`.-
?õåë4Ze®BQ²¢`Å9g®ç]¬8çÊ¹] ‹ƒ¹C\8™ÑOÎèíæÁy}€Ğ¾ğúp~°J©×^/ /<¥à+,É•AŒ¼Ş`~ğÈ: ¬4ˆPšB–¹^­¨ƒÌ…@ë€zˆ¨…
Ñõğ„qFˆA¶ÂÁÂåÒ™›<œ3#˜À"à¡Ş\‡şHè.
<’³ -ˆâxxË ıg…mFÀâÊ‚••SˆõúBx®+/{ÊÉº<J©<Wè	t…”ç*BÊ+p•à©¤1•¸Ê*ÀÊÀªJ\5„JHQ]¶«ÀªPVM åµÀjA×†TÖæêÀ®¤¼X=ğºÕ¸úÈ©¾ìk o} eÁp  ÔkÌ5ÕT>¦1°)B°Š¸ò¦\3pê)ÖŒk«8ÕÍ¹r(‡–2k.³hğ–rÉQŞ’k±r­eİškİv`[ğ6\;ˆhE¹·‡zÚ;€·‡Ï"Ûa·ã:uonëÄu†eáº€u§Øº|TwåºAºËház@"=áé
ì
Şº×,õ£70½Áz÷Aè	Şå”õ§v?®?d °?p dp0|}Áûà†À7HÙPğa°ú"Ä€ÅÂ78|G¤é72BÆ‘Ğ£€a4A*ªGsc ±ÜXY&ó±\d7NÖã†qã†áœq°& Œƒ=ƒĞlø$êéNÙd°p mi“ § LŸ ‹rÚ§pSaS §âÓ€Fàtè©Üx¦‚S=ƒ›	6zp&7››ÃÍE˜ÃÍãæÃšË-€P>—[\È-’}‹Áæ—@pKá¥1K¹eK¹åğ¯@ÌJàXK¹U«ÁÖÀ³’[½’[\ÿzÄ¬n€ln‚·z·õÀ­Ğ«¸màë[¸íğPÜ½Û	¾¸ivÁŞ¾gİ{)®l·)·Ã»¸›Ûk/¬]Ü>ğİÜ~ÈNYïƒ?ø>î bö ‚ïçâñ°À÷ãe½‹³m°wá,6Èb (BV `%B'B¯à‰ÀDÜá!Ø‰Üa¤8ŒÜ`}M‚½	HÓ…7	HSCüQ MwÇÆuÅCåNÀ> vá Ø)àIøNË¾ãĞ' ÇÀ“wœêdîä4wV?Ëı!ÛÉ2;Nñî<ä,wAÖ!€—€gN€]Oá.©÷2wúwxÖUğk'p•IĞG¹ëÀ$àUèMĞI`7ò:ğ*wzpêÁMÈ-î6ü×ÁoËx‹KE¸–
~ì.âo /Ãsö=ğÛàw¸û÷Àîƒ?àBS|ışûÜcè‡À'²ıÇ=y|ß#àShj=‚÷%Ø+¤{Š³İ£÷ıŠ{ûğôø^©7üğ"ôkî-ø;ğ4àyè÷ÀwÀ>"şR¼ûöŒûÿ;àgè/ğ=Cx	öOÀo²~Ç}Gx‡<¿ÂJGø[BìW £ùÆ±š¯ğJ°YÍwLéÒ9†ÑHH•ÆeÑdÑpğfÑ¤áÚŞàüY4Yá{Ëe…|ä²i¨Í³i²ƒQOV°ì`_Às ÎÖX/9ğ—\N`N£&—|L.ˆÒes€77e¹Áó äË‡ø\Ğy5Nšü2£:7$¬¼š°ój
B‚ÏIÖNÂ°
#M~MXÀ@Ê¢5ÅŠË¼¸ÆYSÚYã‚ø¢à.@9µ+4µ]5n®w´»Æ>7¤pó£^/po ‡Æ1_po ·ÆOSÚONëæ]
º$Ú¥¡K‚•A
pªË — ğÒ`¥ÀJkÀ `¼xRAŒF+HÑ Ë@| "qZÙÒA´@H0	O¼xaˆV×jXY‡ äBÀõ
KçôxùdO:üÃÒkšPMÄ‡6hLà¡à& Ic†Ë ‰7M°ÌĞQ‘B$<QĞ¼Æ
´@óÀ²+P€UÁ
V\ ‹Ğ”G ¬<x°Šˆ`Q]QS	¾Ê°ª +hª«Àª†˜Ê@šªÒTƒUUÖU5·ØêšY[XIR]a*XM`MuMMØµÀkjjƒW§ì[[æµ5uÀëB×…®#ë:å{ô½5}cMßT;Ú¿ŠE_€[ÿ«¼¹ÎiSG~?íÄä—ßG’ß=eŠÉïšK0.Œ«ü~™¾Wö’ß!ûÊïıíoé;cå-1}?¬ÿóMp¸üŞ7‚‰”ß÷òò•Ğí
ô»áõXågj°ÊwNè‚š¬²£«lÑ¨Î*[2jC×b•/ŞÑG©^‡U¾óR|Ç0; §Aƒ‚L¡yC‚÷ƒ´ïİz ôpèşĞ[ ·A†‚ï„î!°{@W‚îİR<RÒöjHğ‰ĞU¡BWã”-¥À½YeÛ«|±ĞŸU¾äÉ*[p¾@°–·‰x°Ê6º5D`•-t‹ÕtKİZQ;Ã¶
º•†nß¨nßü@¿;D·g¨ÛJè–º5‡nç¡Û{ÚØ·Q<<…,ÂAÏ¡C/¬€<ƒ=zd6d«lÕX	=2	2
2Ò22k/³V6Ññ±1–æf¬²m„ní [‡è–ºÍˆn¢[A"ìÛ=èÖ ³SM·èä±§Ëk?†~Í“ng¢ùÑ­Líù/€DÛÏÙÂ~kí×Ô€Uê ­´îÑ/½\`”_x õï¼½şÑºGëıÁZ÷h£_¥õîL†:—‡Sê[^{£u-Ÿ½¾ÑºFë™§Ô³s4?{=£ulôhH,„ĞúOë.dd2dd&§\#½V9Ç(×ÚrQ®“^ßEFÙÂD×ì&ää2ä6ä:ää*ää
mOöû¡;bî@R!){»Wœ· ÄR²é¡‹C
@âaƒÎI ?Î*÷Iï¹¨½,hÙÌ†²—[ÆsÓ:O·AÑúO·OÑö@/ƒn™:eo'ô'Îèw±èÌÒ!Ùh‚p¬ò?âägé‹NeUè¬¬²=nÒ°Êé³§ßÀ¢[åè6:'ø³@òAòBrBò@r@r±Êw¡s³Ê×‹Xå›\t{ı†%ı–,ıÍúCnt›İæF·.Ñ­Lt[mã´o¦möÂ´ ÛÄè·¿èö8ºMLÙ°¤ôÑŒ²•¯«ô%´_¡Ûå&Øûšåô¾PvMX¥ÿYiÊ*}R­Ïôº9¥¯ÊÒ™öAĞ÷àïhÏ	Éa9¥cøNûTVéëº³Jß§ƒ?z7Än†D@}ğU€…ì¯))á!ab„”…X t£•òÇDAGB>€†|‚Ü¦ıä+ä$ò"±J»ÑÒş¢‡Ü‡Ñ€‡@Î€¦mrò ròr’Lû<ÈKÈÈ+È)ÈSÈÈcÈ#ÈMÈiH*ä"ää
äí#Xå[Éôk«WYåçØè­Ğ/Ó_ú£¿]Cè†~şBıeº~šnã¤Ûïf0Ê÷e¯³ÊVDº=ïx%VÙ¦X…U¶:Ò­tÛ_eØI¬òÓ7tK ıÍúÍû#¬òÅÒĞo o!¯!‰C´Óº¹Å*í•¶Óıö¶zUú‡ZÆ´¯€Æ)?ÈCÅ§—½/¡¿ĞÛŞ·Ğ_—¡Û*ûÙûúeZúK4ô'éWé7ÿéVBÂ(?“8œQ¾»N_€ö¿t‹(İâHû^Ú§}e”íƒä;„ftûê2FÙÊI·yÒmKeÛ#ı9ú9ô‡w60ÊÿzE¿ÕO·ËÒ¯KÓ/¼B!>¬2®†a•±–½Å!E!~¬2&ƒ¸±Ê8íqa•±»$ÄâÌ*ã9ÛK@×â”ñ¾6§ŒÿMéØoŸ4€ M3è@è®ĞQĞÍi]‡.	…D@ô´İĞvDë5¤¼ıºËÙ¯])k¿uNÎ*ókßn	Í³Ê|€•V/ƒhzˆUÆÎ0V;é¸i7³ÊøYÚÊşC;qÊÚº§Œ¥tmŞ†SÆÒÎtiiEçGœ2¾vç”9 ´ïÈ)sƒhèt>Åı˜[ÑyUMH/:—¢c"¤$ÒRÒRRRRSæ`ôØöãhtL ãı±O:–Ğñ€–İ*KÇƒ7Œ2—¢[jéx@ÇwŒ2Ÿ¢[}éœô=£Ì«è|ÊƒQæ§tnú‰QæUŒ2Oug”m±t®J·ÜÒmÆtû2³ÒíÇtË2İÂL·(Óù+İ¶L·ÄÒ-ÈiŒ²uö-£l«¥[j?2Ê~Ò­¹t+3ıMOú%|:ß¥ß†¦?»Eç½ôW·Z1?æ½t«ìcFùŠûŒòrªé–dú›eë÷gF™¾†¼`”ù İrû
ò’Qæ†t>èÉ)sB:|Û‹Sæ„Şœ2|@Ë
|øRÚ–À·³?æİ>°§²Ê¼;Î]Xeş=2Ò‘UæàC 3h…L§ui×A@¯§íƒSæt¾Y¼$§Ì7é<sm¯°KAüìuÉzôFÈ.V·èøEÇ,:Fía•ñ©«Œ%téGë «Ì÷ûC¶²Ê€®ú@6³Êú /d«¬ÚC@BAC†²Êü-û1ŸË)s::ŸÅ)s»‘œ2·› ™™Æ)ó¼©œ2×›Î)ó½Ùœ2ß£ó¾Y“8Ç1ÈQV™?`•9V0§Ì«X¹Ë¤¨|şöË¡rÍ¢+°¡yö“×mªJdÂ±Ê±–o£Ü…©¡.ÆŞ9·‘M+K¤Ã7±ë‹Ê–Ãİ„¡µr¬"ÏU–Ä,OÅQ•²Ïé!¤"}CÉ³†•¥¥ÛÚ•'ØUJŒ-³Î ¯×”˜|_Å|3OÙ$¡a˜‹±7†¼l[Aâ‹$:Õylïé*ä#Æ±Y–‘wªI©SŠ$¶yÓWìç*ÄÂ?Ğq'ùØ±‰´4^“Xã­˜´ŞCØ|VåÛJŞN­.‘êN‰×4ÛÅàrnÂK¤_oy7¹–äŞ–MÌÿ‘ˆ®&OÁÑèb<â¾•<\_VâËfIìBˆyŠ¸!Fb<â¶…<ÜPV"q¯Å1õÖˆ{x
QHM»\:h”ÄØTqÇå¬‰wN¹İşzĞJrÑf”˜gErò”XÏâ%ôGú§e—‘CG$ÒkµØ|à#ñÓz/a+ü-kÈñÃÁ?y§˜â^81®½‡°ù¼­=Ÿl;á-1'‡Šsc¼ÉWá1üÌ"ëOzJLJ1©ƒ$¾Ìç-¼C>ß:M s’]$æàÛ)[¢SUo!$ÜÅøµıd2ÿ´‹Dîdz&æ­â)ø‡£KbÏ8ÓÁ”YhÔ&6ñz©şäâ²?ú~ÄE­¼…ŞÈçÛ¬ÒAÉß¢æ¿•æ?·'i«äÏ«ùïE>o7µ%Õ•ëçÕëÿÿ‡µH=åúyõú_#Ÿ§›“¥|xµ|BL([Cª”¯–ÙDŒ×N×%ş(22•q-kâC”ø¯ŸmBJ)åÏ«åßù¹]“U#¯>ÇÕÔ«)ŠçZ>‹µÅèb<÷ÍÈgùË*ÄA©'Vµ\Aú•¯ªÇ©5$^ëdmıq›hÜ„§H?ğm’½cSZ­j=t0»Ç|nFr¨.1_
[M%úŠd”«ài&Æ6_ºÜÍkÓúÏ«õßˆôí¿ yÛU”–N)lıòà¡­­›«Ğéë}Eœš =v°Z:ïºä*¬€¿ÓçV$wK´£\¯ùËÑC#i»ëƒ|¾¬IŠ”¯-‘áßøi:KŸh7a¹¹±Õ³²¤P¥Ú’(=âã‚úY‚Ç¹ó‘¾åqgÒ®ˆI¿²ÖVß
ñW‡”º‡9û|iE\Úê$róÿêa(_÷„Ÿ°ş._»m­a>òq—øùK
ËÃ¾‡uü6Š8vA»{Ï/^1Š÷eJ
Ù¸¯Ä±cM‰äzÈ)Ëõ8ãÖ°V_ú¼-«Hâ¡Ë|‡İûùSŞşBEãú°–_ú‘|-*KLƒ§|‹ ¯¿í'TF>>Æ‚õ+IL›<¿ô	_õ†#}Å71¤D¥r?ï,?¡skÚ?a=Òó/zwky‰	ÙÉÊa,â/ì5ÎÓİïEÊ„Z$æÌL¾c«bÖÓü…÷Æaş7úm0/ñ§×ğ¡ü­š>~î`,r¼)ç‰ôçZò¿úX«,ñtáÕÂòìëGjC½ºÛ„_?ÓbmQŞO¨‡ôÙV Ñy‰ôİRË-È:âµ¿0(¼L7o0éœO˜aÛ,…;W±fs÷–!=CÛ]>«Üîü
ë­ßÓı…á^a²?O9Ù_*­ªu~	?øŒ\»‘d¦’MÍ'‹	çm4†,VÎkSÏ[Æ–§|Ù¬\§¨^g¤/:ìWîKTï«©Z˜¿çx’¬”ƒ¨–Ã*¤×ŸDÎ+å&ªå¶ÕÔ3¬bî	ä®Rş¢ZşßwšBn)å/ªåÿÒ43¬Aö	ä©òEõ9z›ñÜ³Ä‘—ÊsÕçŞÌì`l•e<y¥ÔQ­'-¾#7ˆ¼Uê›¨Ö·%HßJŞ*õMTëÛ
ó¶°.šä™RoEµŞ^2ë“e¹£ÔsQ­çgOËĞ{dÒ.Õvñş^)ÄiçJ”C®Äs“¢.Õ.%ì4­+Sİr‡¸ü1"Sú¦ €æÇ$ëÊ!Rj‡ì‰ÛÆ´,}ä/Ì2Mèå¸ƒd7WJ­ä˜8øÊ‚¨·2ÂQÓĞ€®Üt’gîN‰xL¼u2«X/±´Ó|§L_f,q˜°IZÚ-GâŒ;£lsÎ¯Lo‡±=HÁşG$&Õ1ñÔµQb¡›e„êæÈÀî¸¯\ó7£>|#:´ã·Ú™šÅiÚ‘üã%Æï½ø¥wñåö !ÄÜ38.[CâÓì‚$v~/öÈ/¦¯Æ˜“ƒz ·Å§%2ù±òU?şàı`a¬É[;·`	‹<'‰Ï’Än¹VŠÇGmÌ‚vRîJ$²òM<—“b®©©â¿@a£yWğ”‘¤zdªDüæ‹[G~«ŒNš'kû3cˆûø‹yp]4Õké¢Îš
jG±]IH·ûÓô¨¸pB¸¨9 ÜÌıµã]HıÀ+9YY¼Ûù¤ÚM+Œ2×Å2’hã‰™PS|8${âÑıBª¹¯n”s0é¬½#1eÏÚ>ÌX"%Pxa­‰&u¢Ó$²¤‘¡é$V+"›ÿĞb§SßJÌ©jbÖ¾û-÷'„ëLt±.$ÖåœÜÛ”O¿¦[ÍŞúØBá„„?‘ı'':%nz(¼5{é×’™º»ô¼–ç«ÅõÇ¤ÊéW¾¶‰NtBo¤r_üûº§ï‹ûZb¼Oï‹Wïë¶9¡[!3ÙnºEË“WËó„y¸!6KKÛò‹œ×®#Åei!_¼ôó[É	ëyú¼xõyµ2¯2ôÊU…ªz‹>/^}^ëÌ/}sÔ#×šœ£õWëÃHs½ĞÁš6dgÛ×´ÜxµÜ‚Ì·ôÃ˜‰$vbº|Ş±>›-	ôÂF“§~êç^—$&ñ&_Uª,~Ú,ø™Ob™äiÿ$Zo­j½­bŞ:œ™LvO~CËŸWË­éıhÔ“wqÛiı·ªõÿ…i\èt´—´¹Ûh{±ªí%»9wØXv¹5õ¼Ä˜Røùe7X:jñw&¡İ}VÚUmw‡MB§x^"/w¬ íÚª¶ëm&ç°ÙáÈg¥ıZÕö;é·G¦’»g‡g7Û™¤Ğ©Y’´ù[i»ãÕv×ÚÔ%t\$eõ‰÷ÚËWMçÍáÁ‚—išaTöµäÉüD‰”Iå¥¸=|HÅ@ÁÍT8tZá$’º÷€ÄÚÂwqÏn(_ké°™lÛøL"³u|Ñ€ó|÷:¡„éˆ~b¡$r<á¼Dô“ø=Íœ¬—Ç	GÂyÃ4ŸËäÈ¹$‰_Cøç/=­Òà@avx¸aT‘ãdmÚÅ%¾Lz1kûfÁ‚-|¿~ŒÇ%²á\ŠÄ´.Æ¿¾«³Î~(ŒOĞÇz¦Ø”òóÕÏ
·^ª„qÍ]ë°•Än}/ûwİ¸ÆsuB1üENØdÿüÒîV¿„`Ìİõ'”óŠ?ÎëÒßã"©«œWTÏ;>œéê}™˜”ëÕëŸK7(ÇfR])Q-ÓW]¯BGH¨R¢ZGÃ%m×ÂGˆ«R¢Z'Ãƒ´196ÿµésÕçâcŠÖÌ¶†R‹¨>Sƒ`kÑzä–aM¦|Ú›Wû7Î[“Ü)¿/SúGæ¼5ê’;–ÿı¤HN¿çº	“àqoL®–Z$‘]kÄÃÍ
[[^´ğ{5!§KÌÉt¿ïM”v	kL’
O—È‘‘b™7¾Ö#µ‚…g¦¼¹k7#kfg*·…&ï2*5&;rÍÈÒqS¸ÁÚèb°°é³¶mGfe™‹v±Û–0>ÒZªœVh¿<ßĞ,Èô|]M¦2²Ÿ›¯øZ­‡h…â4ŸùóH'%‹šÏ•p\Ï¦å¤r=ÖŸåá¥ËØ½ŠTU®‡W¯g6Ò»[EÂ•ûâÕûª¿×Ù•D§”ÃŸõ¶ZøùÒ!·V¥ÜxµÜò ½õázâ®<—?ÛË-ãNÿš/6¥üyµü÷óz6~µ…¸(ÏëÏv×şôcÉ˜,æ—Ä»O&EÆü¼œÙçİĞdS¥Â™ÖÅ]<y|¸†¬jéiıÛÅ£‚ï÷ÑI×šLëÜ.¢ÿ·Øv¤]œF"iÉbÚäo‘M±îóİîóuZGÒ½i6‰)°C´,¸hK>ã.¼öŸYêeŸ²ÄÚÓI"İmbøÏ„	Ü…Ş%ø~XÖŠô¬š+Óú·‹ÇµÒÏw6&1rKâ—yb1©–˜g¸‡Ğ­ôò€;›Ş•seZÿvñ`ïjBú"}Æun7Õ&ı„¼™Ö³]<ZºT‘ÄXóIÌªúbL×Yâ‹|Â¹Ò>Ág.T!ƒ¢œ2­s»xÔ
Ş“'Ì3­[»xäÕ®½Nz˜
I¹eK]´M\_ÍSXUºšvÎ}¤/ši=ÛÅã–<2XCZ÷õ¯•(ú´÷bJ÷Ô‘{Á$6Ø9Óºµ‹GŒ®#ò¥äcù‘WHCœw2=ï[–§â6ñ4Î»²ô¬
7-dŒ©`¦õi”}JE2÷Kª4à¯İ›%¶qòş(İ\¯½X™ŒRî—ÿq¿UõÇk‘8¥Üøå¶@_`w#2¡bn‰ÑÍç+ª-Zñ\z–Îf(°§1§”?ÿ£üŸëóïnL&*ÏËúãyé+[’ÉÊs·şxîıYç·'Se—È…í¼­ÂEÛ³dwASjß‰Ìh—%Óz³‹Çƒfj[²`¬Fâ»áçîßœJëU¶PfH™8„¡õŸWë¿“¯k¨¦ÏBÒ®u¶LëM<ÇĞì×“E3­+»x”½İñ,‰PG"	õÅ©ë>‰e¯z
§uº°[mÿ X“KÌĞâİ“‰©iî‚N»s†ì|TUbbÅ®3³&ñğ„´Kív–¸ut\I±D–b‰ıÜ…(]!ãƒá§ÈŠ—Õ$fò[jŞÒ‰ÎXÏÕEŸ.N ±o*Èõaâ'§ÄAK¼„6úaÏæÃÿ®ºìÏWG›Ø–sø	ÆÇ»7‘¦J>5ŸúÆ{I«Håzxõz…©'—A¹^½úñÆëç“r_¼z_yıäôV¥xµZ‚uRM¤xxËLíºPh=Só—UI–æc2õë=L“ßT&Ù†4ÀsÙ#fË7&jôC7¡VhSï—VÂv(ñ5÷ŠßŞ³¨æ*|51™ïÔ!#¦dê
#Ÿ­÷¬¤ÀøH‰é¹Bìd.Æ;­u"Âz˜ü/7'ºU1É¢e¢«°]ÿÑTìX{â² S{ï«ïarÜŞƒTÉ·$Sû=ÒÃ´÷F$É½½­Ä;Îg:n)˜»„°*ìˆéÊÑ
Ä8í®`w±FÒpşæ!·±‡éñÖ*¤ìxô'âkÛøKø³óJıáïõº<É:r•ÄôØ.œç*nßâ,<2xš$Ô!†»­%fV~1­xG¾_ıâBwc²IşûÕ"ü|jVñs”Î#Ÿ]wÊ’"I3%fÀLqm?“e}½bÂì0O³Û…Ñ$¼”(1ïâEgÿ×bı«E…4ıisÌç¦¤ğø£’hy'È×RÜ•\T0‡&›³.DÚ9n”ÈÈ0ñÆ¼œ‰k˜¢BzÈ)óû5ˆÇ©µ©~Dl0÷`T½å…[X²ÙqkRÕ	ëÄ[·m¢ş¹¸	GC>™˜Ø82<+î+õZüËb¿("$èN™™Ø¡$6ëŠLı[‚®‡‰Ò¬ËáŸa~üí–X/Âşï¦ûGšóÓIS?T,ÒÇÂ»¾)"t4ú™_ìkC*½!1mÄ‹.µùå
	=ŒÉætZ>Ÿ)g¸<œ¯q«˜pÎxÆ$ûÓÂ?5ÜY×™_4¼ü>JúôAã^ rÏ¼Öü‹¹izó›êÈæwÓ$¦X4/î©É›,…]x²ùiåõ$ñQsú\x¦hG¾/‹><Ùô˜_Nâ_N’ÈD=¿¦r¿áeÁîgNpŞLR’·I|ßC¼¸k„åx·ÂÂÔğ3æçu¶’İcsÑú`QëC@xÓçİäÁ±ù’¸d2ıËËİ\Å„¥á^æÁ˜¿=™yHâ}à_Ïl$ŞºTTèjJ6ğL /÷wÅzg8ß°~QşÁ<ga~x’éx©xrq¤;­‡¼Zç ÿ“w×Iºg{yƒcN±³—³PÑänWğ0I$ñ‹Öñ]î¶Y\ŞtÈ´¿Är9Ö‹¶#^mGÙL=Lãsï!i=«HDØÍŞ|;êÌ7!şzŞgÈÅ€š™úÛ¹¦ê¦öNûÉçæ1™úísHá±“<IF2“ï0LL«ê*ä70…º­%ã2#ÅÍ=L.Úùä×©™Æ©Nğ{—œF.„ì•Lù—óaw‹§.:Îæ*f÷€dgé³RØ›x>iüG±SÁb‚¿ù´9[ãd±ã‰\óçËº:$z^DXn>eÎ]y
Ù›õ0æ†eøƒ³â*ÔçmæO&‡šÈÖ<K3§›q^fĞÀ¿Ôó4äÃá©çi4ığ¸¿Ôó4ówÓùóÛ‰%µj¦¿Û¼*ó$àÄ£!¤DRC‰<½!®½É|ì'\x˜ğrñÛ”éï?ú e¶¿é@ò®A?¼éœx8v$¯VR¸t.ààó$hk¦¿/eÕ~(½şm+’}Mw‰	=&Ÿ°„ŸØÇO8ü,pÇë¶$ÿÊJ’èpT|xs3?`^IÓ–Øÿ¼)¶2Rûîï´¸Î¯YSR(£‹+süAGRnjŞLï2è®—Úù²Éµ¥½ÄŞ'&kñ&ø	—´5—|ê@r­Z#‘Ib½3ù§}…uÁÁÁ4}½$¦ÎÑ:¬¿{€/îw]ğæ·íH$Âï›UKà½ã|…#ÚËA¾ÆÇEë0y%¦Â§
>B@p¬vË»®ÄiÇ*‰7¤ˆ]ö¬ãÓ÷û…µ©Áã¾w%ì˜³õµ¸¾by~Úo¡]PAİîÍIî½C%fÙ]qFÏ¯–Su}pŞ=Ús7Û¯x«DV_O–œÇó!>Â•àÚØoí‰fúÿw/Dë-Wşà-œ¨{xr(1Üo'ë#qÔü–‰ó¼OÓ÷;ÏíF‰ÙsE_2€wìå-t6éÄ§ˆ×ª`‰hSÄôA|ĞJ/aY_Èá']H¡¤8‰™}IÌ£ÍÎ/íí%<
rğÕ@’÷àX‰¯u_¼:dªåÚ ä¿Aÿ¨)¼
×™°[Ìÿ8–ï÷ÌSøÜ#dí»hâ°iªÄ~)&¬óâ7öfíÔŸ¼XMji5 ºáàãFÄis=‰œß.Z&Äğ#â=…WÁëCß®O|.,“˜é;Åçû:ğŞ=…ÛÁœ>é~KRø Æë³Å¢Ë7ò)y=«nuHÒİF¤èöÊXwì«-ZÎIÃ<G[K—|«ñØ!‰S‰ÅlçÏzybÓ5äÌ­hâj«"1.ûÄ¬sùèToá•¶±öôÍÆ¤xb‰a—‹Í÷â¿OòèªèD¢R"$²rŒX$õ>ÿ ¼—P)$Pwõb4ñI®-‘²óÄ©«îóEGz_uuµ	Ï:‚‡¦I¢pHì¿5™ÏóŞGø¤œr¥5ñ¾2DbmeyÂÏ|„íºúÁgn·%nç'Kbàr1Û‰[|ÁF¾‚M·3è±Ø’D<#’Øh¶xÔë3¿=ÎGhÒ?øù¶Äò"Fb*kÔ×X]?xoBƒ%µ'a£¾g>Mãƒ¯û+B
ØĞÔ}†ûŞ@œ›+»um_oA§wÒ^½Ü…ø\î$1›ŠMò²VS¡¤¾gpÊ5øOÕˆy¤xõgu_é+äĞ_
L=×ƒ]ÀümjÑÙã.¿¬­—06Ä¢K¹Ö™xÃóagÈf9Ñ[¨¥Ïª½y±)u¹™Ä4+/òU
Y«Œõvé·&§¶%%×—øÉKÅºËò¥ü„oº7.v%%/·À¼}¬Ø«qk÷h?¡¨~UÀé;mIñÃ%±Ã±vü;~ÄM?!Wˆ%àÒõî$è Vb>®+/Nç?®/)ø†d+óàdOb¼%‰uÆŠÅKä¶–]RğÓ_-}ıRORa]!‰ß»EÌ>+›µ÷ı’B•‰¥®\éLô™ş®nIñr´©|ØSb:Ï›YŸİ+)¸ê“ıŸ'ö'–»Õ3ıİ>Hß±ä‡MıIƒ[È§m#1¤—»µØ’ÂıYÿO«{“´ü3¼Ø£¿æ{ÿd¢½ÛYbÖToO+l]9ßOØ¡wx’Ø˜®–“˜o•Åç­AK
	ú¥¾OîCº–ˆo xn¾³õæL?á•şe™o3ú/‰	;6ó°Î<PRøª÷FúŞ¤ë#ôïØšö³~=\Rèd¨ëÿmZ7Ò!­F¦÷õ.^òü$­R¦÷&¾¡a.é±É×¸Ù›mƒSİ­»P“óJÉéèäôI×ı­äïz¦ä÷^“Ètå¼õ¼©¡-ü¿uŸNæ(çıó=ÎûĞê^ŸM"k•òùó}Ğô0Ÿœÿkå}M•îVÇ14ÿ	¥>Ô‰#k•ræÕrvÏÿyd±)ÏåÏ÷P¹Œ#K¦Ç!#”ë·¨× ty©o]'ÙJ¹ñj¹U3”zbGv)ÏWŸ{!ãÿ+¾³ÈJ=ùóıW]ãGÿ'QsÉåyñêóöºÔÿÉd¯Rßxµ¾