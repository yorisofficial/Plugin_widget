"use strict";Object.defineProperty(exports, "__esModule", {value: true});/* eslint max-len: 0 */

var _index = require('../index');
















var _flow = require('../plugins/flow');


















var _typescript = require('../plugins/typescript');












var _tokenizer = require('../tokenizer');
var _keywords = require('../tokenizer/keywords');
var _state = require('../tokenizer/state');
var _types = require('../tokenizer/types');
var _charcodes = require('../util/charcodes');
var _base = require('./base');












var _expression = require('./expression');





var _lval = require('./lval');












var _util = require('./util');

 function parseTopLevel() {
  parseBlockBody(_types.TokenType.eof);
  _base.state.scopes.push(new (0, _state.Scope)(0, _base.state.tokens.length, true));
  if (_base.state.scopeDepth !== 0) {
    throw new Error(`Invalid scope depth at end of file: ${_base.state.scopeDepth}`);
  }
  return new (0, _index.File)(_base.state.tokens, _base.state.scopes);
} exports.parseTopLevel = parseTopLevel;

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

 function parseStatement(declaration) {
  if (_base.isFlowEnabled) {
    if (_flow.flowTryParseStatement.call(void 0, )) {
      return;
    }
  }
  if (_tokenizer.match.call(void 0, _types.TokenType.at)) {
    parseDecorators();
  }
  parseStatementContent(declaration);
} exports.parseStatement = parseStatement;

function parseStatementContent(declaration) {
  if (_base.isTypeScriptEnabled) {
    if (_typescript.tsTryParseStatementContent.call(void 0, )) {
      return;
    }
  }

  const starttype = _base.state.type;

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
    case _types.TokenType._break:
    case _types.TokenType._continue:
      parseBreakContinueStatement();
      return;
    case _types.TokenType._debugger:
      parseDebuggerStatement();
      return;
    case _types.TokenType._do:
      parseDoStatement();
      return;
    case _types.TokenType._for:
      parseForStatement();
      return;
    case _types.TokenType._function:
      if (_tokenizer.lookaheadType.call(void 0, ) === _types.TokenType.dot) break;
      if (!declaration) _util.unexpected.call(void 0, );
      parseFunctionStatement();
      return;

    case _types.TokenType._class:
      if (!declaration) _util.unexpected.call(void 0, );
      parseClass(true);
      return;

    case _types.TokenType._if:
      parseIfStatement();
      return;
    case _types.TokenType._return:
      parseReturnStatement();
      return;
    case _types.TokenType._switch:
      parseSwitchStatement();
      return;
    case _types.TokenType._throw:
      parseThrowStatement();
      return;
    case _types.TokenType._try:
      parseTryStatement();
      return;

    case _types.TokenType._let:
    case _types.TokenType._const:
      if (!declaration) _util.unexpected.call(void 0, ); // NOTE: falls through to _var

    case _types.TokenType._var:
      parseVarStatement(starttype !== _types.TokenType._var);
      return;

    case _types.TokenType._while:
      parseWhileStatement();
      return;
    case _types.TokenType.braceL:
      parseBlock();
      return;
    case _types.TokenType.semi:
      parseEmptyStatement();
      return;
    case _types.TokenType._export:
    case _types.TokenType._import: {
      const nextType = _tokenizer.lookaheadType.call(void 0, );
      if (nextType === _types.TokenType.parenL || nextType === _types.TokenType.dot) {
        break;
      }
      _tokenizer.next.call(void 0, );
      if (starttype === _types.TokenType._import) {
        parseImport();
      } else {
        parseExport();
      }
      return;
    }
    case _types.TokenType.name:
      if (_base.state.contextualKeyword === _keywords.ContextualKeyword._async) {
        const functionStart = _base.state.start;
        // peek ahead and see if next token is a function
        const snapshot = _base.state.snapshot();
        _tokenizer.next.call(void 0, );
        if (_tokenizer.match.call(void 0, _types.TokenType._function) && !_util.canInsertSemicolon.call(void 0, )) {
          _util.expect.call(void 0, _types.TokenType._function);
          parseFunction(functionStart, true);
          return;
        } else {
          _base.state.restoreFromSnapshot(snapshot);
        }
      } else if (
        _base.state.contextualKeyword === _keywords.ContextualKeyword._using &&
        !_util.hasFollowingLineBreak.call(void 0, ) &&
        // Statements like `using[0]` and `using in foo` aren't actual using
        // declarations.
        _tokenizer.lookaheadType.call(void 0, ) === _types.TokenType.name
      ) {
        parseVarStatement(true);
        return;
      } else if (startsAwaitUsing()) {
        _util.expectContextual.call(void 0, _keywords.ContextualKeyword._await);
        parseVarStatement(true);
        return;
      }
    default:
      // Do nothing.
      break;
  }

  // If the statement does not start with a statement keyword or a
  // brace, it's an ExpressionStatement or LabeledStatement. We
  // simply start parsing an expression, and afterwards, if the
  // next token is a colon and the expression was a simple
  // Identifier node, we switch to interpreting it as a label.
  const initialTokensLength = _base.state.tokens.length;
  _expression.parseExpression.call(void 0, );
  let simpleName = null;
  if (_base.state.tokens.length === initialTokensLength + 1) {
    const token = _base.state.tokens[_base.state.tokens.length - 1];
    if (token.type === _types.TokenType.name) {
      simpleName = token.contextualKeyword;
    }
  }
  if (simpleName == null) {
    _util.semicolon.call(void 0, );
    return;
  }
  if (_tokenizer.eat.call(void 0, _types.TokenType.colon)) {
    parseLabeledStatement();
  } else {
    // This was an identifier, so we might want to handle flow/typescript-specific cases.
    parseIdentifierStatement(simpleName);
  }
}

/**
 * Determine if we're positioned at an `await using` declaration.
 *
 * Note that this can happen either in place of a regular variable declaration
 * or in a loop body, and in both places, there are similar-looking cases where
 * we need to return false.
 *
 * Examples returning true:
 * await using foo = bar();
 * for (await using a of b) {}
 *
 * Examples returning false:
 * await using
 * await using + 1
 * await using instanceof T
 * for (await using;;) {}
 *
 * For now, we early return if we don't see `await`, then do a simple
 * backtracking-based lookahead for the `using` and identifier tokens. In the
 * future, this could be optimized with a character-based approach.
 */
function startsAwaitUsing() {
  if (!_util.isContextual.call(void 0, _keywords.ContextualKeyword._await)) {
    return false;
  }
  const snapshot = _base.state.snapshot();
  // await
  _tokenizer.next.call(void 0, );
  if (!_util.isContextual.call(void 0, _keywords.ContextualKeyword._using) || _util.hasPrecedingLineBreak.call(void 0, )) {
    _base.state.restoreFromSnapshot(snapshot);
    return false;
  }
  // using
  _tokenizer.next.call(void 0, );
  if (!_tokenizer.match.call(void 0, _types.TokenType.name) || _util.hasPrecedingLineBreak.call(void 0, )) {
    _base.state.restoreFromSnapshot(snapshot);
    return false;
  }
  _base.state.restoreFromSnapshot(snapshot);
  return true;
}

 function parseDecorators() {
  while (_tokenizer.match.call(void 0, _types.TokenType.at)) {
    parseDecorator();
  }
} exports.parseDecorators = parseDecorators;

function parseDecorator() {
  _tokenizer.next.call(void 0, );
  if (_tokenizer.eat.call(void 0, _types.TokenType.parenL)) {
    _expression.parseExpression.call(void 0, );
    _util.expect.call(void 0, _types.TokenType.parenR);
  } else {
    _expression.parseIdentifier.call(void 0, );
    while (_tokenizer.eat.call(void 0, _types.TokenType.dot)) {
      _expression.parseIdentifier.call(void 0, );
    }
    parseMaybeDecoratorArguments();
  }
}

function parseMaybeDecoratorArguments() {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsParseMaybeDecoratorArguments.call(void 0, );
  } else {
    baseParseMaybeDecoratorArguments();
  }
}

 function baseParseMaybeDecoratorArguments() {
  if (_tokenizer.eat.call(void 0, _types.TokenType.parenL)) {
    _expression.parseCallExpressionArguments.call(void 0, );
  }
} exports.baseParseMaybeDecoratorArguments = baseParseMaybeDecoratorArguments;

function parseBreakContinueStatement() {
  _tokenizer.next.call(void 0, );
  if (!_util.isLineTerminator.call(void 0, )) {
    _expression.parseIdentifier.call(void 0, );
    _util.semicolon.call(void 0, );
  }
}

function parseDebuggerStatement() {
  _tokenizer.next.call(void 0, );
  _util.semicolon.call(void 0, );
}

function parseDoStatement() {
  _tokenizer.next.call(void 0, );
  parseStatement(false);
  _util.expect.call(void 0, _types.TokenType._while);
  _expression.parseParenExpression.call(void 0, );
  _tokenizer.eat.call(void 0, _types.TokenType.semi);
}

function parseForStatement() {
  _base.state.scopeDepth++;
  const startTokenIndex = _base.state.tokens.length;
  parseAmbiguousForStatement();
  const endTokenIndex = _base.state.tokens.length;
  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, false));
  _base.state.scopeDepth--;
}

/**
 * Determine if this token is a `using` declaration (explicit resource
 * management) as part of a loop.
 * https://github.com/tc39/proposal-explicit-resource-management
 */
function isUsingInLoop() {
  if (!_util.isContextual.call(void 0, _keywords.ContextualKeyword._using)) {
    return false;
  }
  // This must be `for (using of`, where `using` is the name of the loop
  // variable.
  if (_util.isLookaheadContextual.call(void 0, _keywords.ContextualKeyword._of)) {
    return false;
  }
  return true;
}

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.
function parseAmbiguousForStatement() {
  _tokenizer.next.call(void 0, );

  let forAwait = false;
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._await)) {
    forAwait = true;
    _tokenizer.next.call(void 0, );
  }
  _util.expect.call(void 0, _types.TokenType.parenL);

  if (_tokenizer.match.call(void 0, _types.TokenType.semi)) {
    if (forAwait) {
      _util.unexpected.call(void 0, );
    }
    parseFor();
    return;
  }

  const isAwaitUsing = startsAwaitUsing();
  if (isAwaitUsing || _tokenizer.match.call(void 0, _types.TokenType._var) || _tokenizer.match.call(void 0, _types.TokenType._let) || _tokenizer.match.call(void 0, _types.TokenType._const) || isUsingInLoop()) {
    if (isAwaitUsing) {
      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._await);
    }
    _tokenizer.next.call(void 0, );
    parseVar(true, _base.state.type !== _types.TokenType._var);
    if (_tokenizer.match.call(void 0, _types.TokenType._in) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._of)) {
      parseForIn(forAwait);
      return;
    }
    parseFor();
    return;
  }

  _expression.parseExpression.call(void 0, true);
  if (_tokenizer.match.call(void 0, _types.TokenType._in) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._of)) {
    parseForIn(forAwait);
    return;
  }
  if (forAwait) {
    _util.unexpected.call(void 0, );
  }
  parseFor();
}

function parseFunctionStatement() {
  const functionStart = _base.state.start;
  _tokenizer.next.call(void 0, );
  parseFunction(functionStart, true);
}

function parseIfStatement() {
  _tokenizer.next.call(void 0, );
  _expression.parseParenExpression.call(void 0, );
  parseStatement(false);
  if (_tokenizer.eat.call(void 0, _types.TokenType._else)) {
    parseStatement(false);
  }
}

function parseReturnStatement() {
  _tokenizer.next.call(void 0, );

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (!_util.isLineTerminator.call(void 0, )) {
    _expression.parseExpression.call(void 0, );
    _util.semicolon.call(void 0, );
  }
}

function parseSwitchStatement() {
  _tokenizer.next.call(void 0, );
  _expression.parseParenExpression.call(void 0, );
  _base.state.scopeDepth++;
  const startTokenIndex = _base.state.tokens.length;
  _util.expect.call(void 0, _types.TokenType.braceL);

  // Don't bother validation; just go through any sequence of cases, defaults, and statements.
  while (!_tokenizer.match.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
    if (_tokenizer.match.call(void 0, _types.TokenType._case) || _tokenizer.match.call(void 0, _types.TokenType._default)) {
      const isCase = _tokenizer.match.call(void 0, _types.TokenType._case);
      _tokenizer.next.call(void 0, );
      if (isCase) {
        _expression.parseExpression.call(void 0, );
      }
      _util.expect.call(void 0, _types.TokenType.colon);
    } else {
      parseStatement(true);
    }
  }
  _tokenizer.next.call(void 0, ); // Closing brace
  const endTokenIndex = _base.state.tokens.length;
  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, false));
  _base.state.scopeDepth--;
}

function parseThrowStatement() {
  _tokenizer.next.call(void 0, );
  _expression.parseExpression.call(void 0, );
  _util.semicolon.call(void 0, );
}

function parseCatchClauseParam() {
  _lval.parseBindingAtom.call(void 0, true /* isBlockScope */);

  if (_base.isTypeScriptEnabled) {
    _typescript.tsTryParseTypeAnnotation.call(void 0, );
  }
}

function parseTryStatement() {
  _tokenizer.next.call(void 0, );

  parseBlock();

  if (_tokenizer.match.call(void 0, _types.TokenType._catch)) {
    _tokenizer.next.call(void 0, );
    let catchBindingStartTokenIndex = null;
    if (_tokenizer.match.call(void 0, _types.TokenType.parenL)) {
      _base.state.scopeDepth++;
      catchBindingStartTokenIndex = _base.state.tokens.length;
      _util.expect.call(void 0, _types.TokenType.parenL);
      parseCatchClauseParam();
      _util.expect.call(void 0, _types.TokenType.parenR);
    }
    parseBlock();
    if (catchBindingStartTokenIndex != null) {
      // We need a special scope for the catch binding which includes the binding itself and the
      // catch block.
      const endTokenIndex = _base.state.tokens.length;
      _base.state.scopes.push(new (0, _state.Scope)(catchBindingStartTokenIndex, endTokenIndex, false));
      _base.state.scopeDepth--;
    }
  }
  if (_tokenizer.eat.call(void 0, _types.TokenType._finally)) {
    parseBlock();
  }
}

 function parseVarStatement(isBlockScope) {
  _tokenizer.next.call(void 0, );
  parseVar(false, isBlockScope);
  _util.semicolon.call(void 0, );
} exports.parseVarStatement = parseVarStatement;

function parseWhileStatement() {
  _tokenizer.next.call(void 0, );
  _expression.parseParenExpression.call(void 0, );
  parseStatement(false);
}

function parseEmptyStatement() {
  _tokenizer.next.call(void 0, );
}

function parseLabeledStatement() {
  parseStatement(true);
}

/**
 * Parse a statement starting with an identifier of the given name. Subclasses match on the name
 * to handle statements like "declare".
 */
function parseIdentifierStatement(contextualKeyword) {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsParseIdentifierStatement.call(void 0, contextualKeyword);
  } else if (_base.isFlowEnabled) {
    _flow.flowParseIdentifierStatement.call(void 0, contextualKeyword);
  } else {
    _util.semicolon.call(void 0, );
  }
}

// Parse a semicolon-enclosed block of statements.
 function parseBlock(isFunctionScope = false, contextId = 0) {
  const startTokenIndex = _base.state.tokens.length;
  _base.state.scopeDepth++;
  _util.expect.call(void 0, _types.TokenType.braceL);
  if (contextId) {
    _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
  }
  parseBlockBody(_types.TokenType.braceR);
  if (contextId) {
    _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
  }
  const endTokenIndex = _base.state.tokens.length;
  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, isFunctionScope));
  _base.state.scopeDepth--;
} exports.parseBlock = parseBlock;

 function parseBlockBody(end) {
  while (!_tokenizer.eat.call(void 0, end) && !_base.state.error) {
    parseStatement(true);
  }
} exports.parseBlockBody = parseBlockBody;

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

function parseFor() {
  _util.expect.call(void 0, _types.TokenType.semi);
  if (!_tokenizer.match.call(void 0, _types.TokenType.semi)) {
    _expression.parseExpression.call(void 0, );
  }
  _util.expect.call(void 0, _types.TokenType.semi);
  if (!_tokenizer.match.call(void 0, _types.TokenType.parenR)) {
    _expression.parseExpression.call(void 0, );
  }
  _util.expect.call(void 0, _types.TokenType.parenR);
  parseStatement(false);
}

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

function parseForIn(forAwait) {
  if (forAwait) {
    _util.eatContextual.call(void 0, _keywords.ContextualKeyword._of);
  } else {
    _tokenizer.next.call(void 0, );
  }
  _expression.parseExpression.call(void 0, );
  _util.expect.call(void 0, _types.TokenType.parenR);
  parseStatement(false);
}

// Parse a list of variable declarations.

function parseVar(isFor, isBlockScope) {
  while (true) {
    parseVarHead(isBlockScope);
    if (_tokenizer.eat.call(void 0, _types.TokenType.eq)) {
      const eqIndex = _base.state.tokens.length - 1;
      _expression.parseMaybeAssign.call(void 0, isFor);
      _base.state.tokens[eqIndex].rhsEndIndex = _base.state.tokens.length;
    }
    if (!_tokenizer.eat.call(void 0, _types.TokenType.comma)) {
      break;
    }
  }
}

function parseVarHead(isBlockScope) {
  _lval.parseBindingAtom.call(void 0, isBlockScope);
  if (_base.isTypeScriptEnabled) {
    _typescript.tsAfterParseVarHead.call(void 0, );
  } else if (_base.isFlowEnabled) {
    _flow.flowAfterParseVarHead.call(void 0, );
  }
}

// Parse a function declaration or literal (depending on the
// `isStatement` parameter).

 function parseFunction(
  functionStart,
  isStatement,
  optionalId = false,
) {
  if (_tokenizer.match.call(void 0, _types.TokenType.star)) {
    _tokenizer.next.call(void 0, );
  }

  if (isStatement && !optionalId && !_tokenizer.match.call(void 0, _types.TokenType.name) && !_tokenizer.match.call(void 0, _types.TokenType._yield)) {
    _util.unexpected.call(void 0, );
  }

  let nameScopeStartTokenIndex = null;

  if (_tokenizer.match.call(void 0, _types.TokenType.name)) {
    // Expression-style functions should limit their name's scope to the function body, so we make
    // a new function scope to enforce that.
    if (!isStatement) {
      nameScopeStartTokenIndex = _base.state.tokens.length;
      _base.state.scopeDepth++;
    }
    _lval.parseBindingIdentifier.call(void 0, false);
  }

  const startTokenIndex = _base.state.tokens.length;
  _base.state.scopeDepth++;
  parseFunctionParams();
  _expression.parseFunctionBodyAndFinish.call(void 0, functionStart);
  const endTokenIndex = _base.state.tokens.length;
  // In addition to the block scope of the function body, we need a separate function-style scope
  // that includes the params.
  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, true));
  _base.state.scopeDepth--;
  if (nameScopeStartTokenIndex !== null) {
    _base.state.scopes.push(new (0, _state.Scope)(nameScopeStartTokenIndex, endTokenIndex, true));
    _base.state.scopeDepth--;
  }
} exports.parseFunction = parseFunction;

 function parseFunctionParams(
  allowModifiers = false,
  funcContextId = 0,
) {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsStartParseFunctionParams.call(void 0, );
  } else if (_basoÒÕY{Éd¾`¿Pi¨sÎ<İÒØ6‹¿yÿğü7:pÿş<¾¿¹İÿ_c°Îúægşİ_‡·ÿ½of²Y¿@Wàø†İ¯Ïg¬o²œ9ÛŸü¾ ÿ‰–ÿ–KHÄõ4ÏĞ^ÏÃùü¸v½C}@3Z3Ò×ó¢GŠ¢I½Ãş¤Ş§“ş¶“ş¾<t ö÷Èx_‚fÀõÔGæ©PkYÍû‡öäª+;êß–ÀõŸåƒ”B”NÀüÈwWá…>¸‚j_²úÿ‹8ò	™L…lFD'ı•mQw+v@üİöhÒ:Ó1üåêQÒm&‰¯}Ë^Lê×ï.äV1òéKyÈŠÙTäEÍ)¶^ÀŸOh!?¯Ïj[eZñ6é/©x¶?×èë™ÿÔ1òñú¿¥¿ü]'>ßAŸ3¶wœÿó7ôüõİ®çıõ®Nê°ÿŸıû•¼™©w4”e¤¹¶6ˆç¨Çökœ šÌÏĞûÏk½C$^u0¾JêŸÒ{‡zSï…áT=Ï÷hN:ì¢ó1Àü¨‚pGúòCÈ'ë)ÚÔœõÂİÜùB¯ ¸`Ñ•!/l¥ô¯ÇÏOsö•-ê2ŸfC˜2˜`ÔG«|Ö’ş‡@ß<@Í/+ŸëßÌ®'úgy¥ÿ—=ÿ¤ÿ4Åg\Bb‚z{óÙ6?11ò}ÊÿKÒ±şå6S@ßzOÃx\Ó5Oë»ô»h´-ºÄXO›&@ıæ# Ş(=é›1ğAWx¾Rh/òC=üÏúú[ştwGöõïÈÚ¤Nûk;²½¶Ãù÷wĞ'bò³ı½ø™€ø¡©it§ùı{SS8µ¯o¢üûfß?÷÷LÖµ®Fx}“9×•õÔÔº¨ÈdŸïÖÚ <d 3ßç1ÇbI?Âï¨Æ¢ºJHLsËÚÃnäş0Ÿ“ŠïC‡ì†ñÀ	¡¢¡CfÃøğ„Ñ•à!áÀ”şƒ‡x@|Aé_bÅúTÄm Íø›Îú_­všH{µÉ
eıÿ_Äã©ø_àù5ÑIÿ|¢úM“I‚ão¡µ—µÂöÅá²‘¦_q=éã7í¼$¦&¦ÿç©—6àú]e«?:EÀ|7İH[kÉ,¼¶©È‹W`Åã_©‚;Nç¥1PŸ{zŞ#+ÆQ
ï7E¡Ûƒ’ğ|ßÎzìÌSûÿäo;ålÿ33öo¾Š"ıQ8Ô³µÂ+İŠ‹ba>ÄÅ|ïåMÃ}×ßPlú¨­$¯×ÆšP W¯·Çöá#92-k»œ ×ı±ºò­â<ïJ	C?¤ş·ˆ%õÀ¤¿áñ:ßOğÃùüQÒÿKÄ^¸2Ê]Hê®g £ûnâl'õ~=äÏz‡óE‹"ƒtğÿBêÍiŞ;Q%–š _1Tr‹špˆîÎkİ(ÿŸ~Y87VÿÍ¦æûœàÒ\'E÷¨Wõ[ö»Mš>ÀtÊ‹ôøyæßq"$ó!¾LüHn/ÆñƒÀº0êó¤¾‡\†ñ«ÚS¯Psåa}È¢jı<^_ÛxŞÃ6F*…ñ«)Š´íƒ‚½‰1Şxüıé±ş†3b˜O ¢=Èl†õFõÙ9¾®­zü|·û[F}MW§ÛK½v8?óß8^Ö
'w³:ì¦y®"m¯±È…ƒYçRbôÅıJÎ98C8i8ß(ÿï÷—µfêıá2¬÷¦²\[7Š×:gHL…ğyÊ×üJ€=ŠIéÿğß”Ş_+ÄıÏOt•XBàó|7Ê½ƒ?–{ç¹ÌC»ó'¸«†–ŠÀ^GRúgè=2PÈà½¡*>R~=É…Ú”õ™ÅŞJ®VB@¼¤®0‘÷7ÃŠF}‡ÿû«øY®®À7êOPÁ¶o¾m©ø}Àã£^ÜÒ’K¸¾tõ'äeş§~I†Ãj4
çû7ÔªÖÌß£úe3ÖÏ?.ô’//<ï—óÅ¨şgı3Êz,‹‘&Ãùï¼2¯ÿÕ‡Á>}ë<÷ZˆïÒ½ªÆcx>ú›Aï‡jÆC°Û7ƒS4!ƒ`¼¡tÿ3'íıúÿ¢Sü½ıÒñ¹¥á„!±Ç/uUÙÄí‹÷—#ëj$erËj+è¹.Ú:Òqáø”º9Y¤=…ç_—(×İ¥"~š£«P™®¥ßï¼te?¸ãH?Q«cÍßÆ½¾„×ô¬§$ı=U¿‡xcZDûxäÿQíõ{<>—?ÊŠš÷Ò¼o”;ïÓ”­=iŞæÈ.ÂıRIû€,õƒ@ÿ!¢Ò·x@|ğU¤R5_‚çÿ7oßÑÏ¤.„z¥«ˆ {˜îíüª‰__1îşu>;ş÷¯ãy&2 _S†¥Ln.ğW5ÕâxÿÑïÑ§ûˆa¾×²0©j¾)Ïç;½Î‰°ÁúG¥^¢S¾m[ğö*7‚Û
ãÇÏûcâş9íı3Ê`>Õ?ãäDF¿¬ÊY2Æz›Ò½>ï'|5âƒ'‚‡Ó¸‚>*x%k ßå/gCç}Û=…æ{ûßˆ%ãCß:Rÿc:ğjzmB£x9*Æ|¢†ã~ó	YïgXÍ_û›¹ßÍÁı5ë­¡h¬ô{OT´î÷ÉP;	™Pa½ËuWµ-8ŞŸP…ŠuÍ0ÙRä#¯äŸıœœärµÂ!÷S[{Ø!Õú?7Á=”Ğâü‰ÌçË#†ÀL"óùùüõù|{¼ïö‚ô÷cƒ‡ˆÁ^ì$íÁQŸ‘ğyw:rÕîŸ|p†’w†§ûğà'ûV‘¶‡µ9ıFˆÛ…=¨§²«÷R†´¶é»J/æ³óşu¼ã—øos¯wÏç±½”ŒçY‘Xå‹ŞÀõïÅñnó‰ƒ ¯eaİìm	˜ºj¸A\ŠûI¡S^Â‡­x¾Ií1.²%àù^ÒIïõ¾èd{ÿF?ëaÆzú…‡mÒ„]‡çgÑ›4æúzİ>›´İj¼>U¸ÈŞ„Pšé—¹ll
äU¯ñ·®i™ûïT9™àü›ª¿Í=±†áÿ£VúJGCıqœë0»Yïƒ?¯×j½ÍşŸ–«»úUe¸Şväl?âñÇ	UºŸtÍ0^Z· ÕÏÍ†ı½ïò­oÜÏ/í{×e˜&V×úÄÚ÷ÌéãÇ“œßÓ¨~şæ~µS¨Ë*Ğwsz»9)ú’ù>—øÛÿÈÎù} èr Cÿ9ƒ…}	=Üß\2ßw¨<ë3”Âˆÿ)âuß­ÿ¯êKÆû)&ò¡läfÉ}¤]Q*#ğß¡—ÿ4~ßÔ^ÜB3½CÂdûÂÚÕm0ÿßrí¿UHz8Î7º6âßàù=”Ñkz¶×¾â¶i üÅãƒ*~âqÓQ.aÀùe{¿¬‰ßuèŸsxT>SïÖŒ~Y¤Ş’zÇıw­¯‡øráN‘eCÿ¦]îC«1úåŸ.êµiàop½ZaÌJqI&øKKƒ5i«q>NæßÕËñ8Å«[áyÖÍ–ë*–1æ?ñú-mì_—Ø6TÆB¼Qü‰óî+Õ<èp/3dÆ‡Å¸^^¥+Ôš¡?WéJßO¾ìıFš—ZŞd®gnÚíÅ-bÌnÚïÅ+ãJï}ä²øØíègòu˜ÊûzÌU¨Wlï>7xpÄS-ék{œTı¿Èx_äëA€_?Ğ‘ÈX_ÑçÖvÈØƒæ½c•ª_ÕBğñ‚r;r‚ø¤wzº;j%b{à¸‚Ì§f¬i@U\2ßçÎ<‚Cşÿ½zùOãÎõ€]u[‡&.?¾O=±ê3[<T^Kp¿éyÊäÓ½ÅëÃ¤B/B
ñqÁÇ.[,«RŞbê}·XF0˜7èîcè_o: Té3°¿yÖ/«ƒŞ-ÿ°N{?ÃúilPgƒûp£¨e:¸åj™ûõc!?(Zë¶jmL$Œ_Üå¼ü\Ì"èç“V7¶«!ÓŞoŠ"m›VëÏ¯åêQwƒÇ»‘òF'_-h¹z¤WùC¿×aÿ3×ßäøÛƒ=°œµøÖæÏë~¨Ò×ˆçOµEßÎk„x@÷­-úzŞSĞ£îk[”7¯ì…n§­uË¼«¸ñ[Ë†y‡`üÅ¼Ù‹wÙ÷÷´d¯íõ@†ûlÜsd©c$Ô[{'¦;dÒAı’ô÷¼ŒB/¨·nêÙ­5ìé©÷y½O=„ñ¹OÑ`¹Îâ*Uºª~[æ´ëYTt¿ÍÀÊæ 6}@Ã%;vıïÿë*ãä¶ôEUcQ)Â¿GÑ²}\BŒããŠm¯ôxë‰‡ŞÛ’Ğ#ü—<èV¿ bÖ{§ŠøÏç1ğ^¯ÄëkïVº¯âõCÿïzÿh£?^åzÇn!z¨WÕyìf®Ï„÷Ó®5®b¬§×®™W¨¥/œ^å>/Ô{,Ôë.w^İÿË?Ñœ¢¨ÏÒjµoÒ\2Ñşóñãqü-oİk0È`¾ëİwå]¶½7âËÙ|÷êõ¸Ş¡xÚ0ú‘¯Òåk±~óI½kz?P¥ë¤÷´¼y×à~5mQsµ×ó-;}då‡rÀÿVf{¿­QîÎ`ğ°ú/µdg8\¯ ¹×9ïïAÏÛ†öìÚ{æTˆ²ƒ¯œ×C¾Fõ÷ Ôœ‰pü™óı>V«¡>ÑœGúûB^%¶Ù.1›Xn*?rIU.÷!º¢JBNà¿BÿmìxúW	pUİq¤6ğã6™¥ò{ ÿ]\¥Y	ÏU0KOC*yP’½”1lù6£Q"ÿk>â)4İëñ i¿RäÓ…€ùÅ÷ØXşäßÕØ¿¿t´­ .Ãúñú Çn¥;TSi¾µ¤gØOŸO‚õ?ÆÏİy‡iáú“–Rıò¤¸ŸÆªŸ„Ù//æN1ÿøF#›©âÈÁ~Ÿªši4âùDß§8ÏTibà÷<›Çìè%óÁ¿Gx=Æ3a~iƒ7¾_—»×,ÅñÃ¡ÏÄ=ØWën/Én¶æ-ŞîçkÙÑ§ÈÀ>ì¼üx¬ôGş:TşÛTÃYà0—×rr÷A¥½¡ªW‚s>ş½Yoöôüş¡ä_q‚S+Kp?Æ¬À¡¿·Áıü¦+G:”‡ßCıe‡è‹‹MÄ#ºU¾u
'ó{—âóïõT¡&ƒ<(›‡şĞªmqdıı‹ËŸTÆÍmR·É#	3Hätcş^Mš :kºŠ×§JvBIâ_AY=jĞPüünûœ/Àı®ö¹sõ/}õó.w!Q‹·›×+EıCO¬W
ïZğø_År¥{l>¬gI¤là¸^„~«•<Ë)ôë[!ªÓÿ©_^ÇşY	ş¸¿Æü8QÂŒ€'¸?V´hn”_‡şxs'ùí…ãçLÍšÄè—Óœ}Ö‰ÙO¿9;¯×+W7€Ş£øN†LŒ§LTFhµ9Oä°{m|È¨~í/…ÿö»œ™5ä‹Ùªq4çO}}©Oµ=Ü ùe;æï•Wyç¹k”x}î÷•£Ç~£A+ÔôƒzçÎ	î£ÔeéPŸŒÌİ€ª?ş„æSsÇö(šã=Í‡Óû¡JØËîÎénö(˜R‡P[“GV‚à¡Vôÿ^ˆçåÜg
e_‡ñ×ô§¦ı•äkËv™$ÙB} N±¨‘‰õzLşÔ©}Ûu‰6,ÅşLtÓİ™1ìÉØ®Rqôó«ŸÙâföN‚ü¿åôc7+Ú‰íË·]P³úk§´÷¿gôÃ5ˆ3Ô£áz’2l’ÒÔ<ë—ç‰ûç}Ğ±ŸÕ?Kã‡ûá&ÄŠ¦T3ûizÿ÷ÃœÔŞ_ìÃlRÿ‘Ìõ6‘×Ó†;ºH	ÜO47„Š/î€=;«š©‰ÖBış«X÷•fpìèc¯"ŞèèR$Ã¿wº?Ğ‘—‚ó“ı£ÜyZ3^/,ºÌœŸ³áÍıÃ2 ^ê™çf-OƒûÛ’”çFØs Ÿ¿½ÈóõÙkÊ!~‹œÊ¶¦¿ë¡¨ù|‹œõœ¼&*¿ŸºO¤»s†ÉƒëÛÛ³şşß”ç4ßŞ'Kh>QxëKj€6NaH—¾ëÊÖx¨”ÖûqşS§ÌšßÀ_}(U‘öòÑ2>È¬9ñ±"èq?ôÿşö¯k”¼;@|²ª½ÿ5œ?e…Mj†Ú«³Ş;ø÷Nı1ÿ¤÷8uwÜ/7Ndœá÷öOˆ%D1ûcFµû{°¤Şÿ€ııìgı3:­¯ÃısÚ××ù½Òa}]ø¼~J¸hZ(c~Î@G7=õüíğ^İnú[`}6µşf¹T÷kÜ³ñ{8©QER&èŸÔ»›NTıN·:ºÇe/veêãçãF(ænğGñü‚3Ÿ÷«ô{ç3Ğ»·’GØ»¸ÓLéİõ;ÿğÕMÖÍöİÛëùvl=ÿ??±Ä-ª®åãì¨¡„§Ïç¥7û/ŒÄãiekœ]œówª¼oúñ¿1€–JEL{ *#ã\?hYòy/Â€ë)›¤Œ0†Ş—ü-½wìüô@úû †ŞÛı}1ğ3Ïè‡EõÃÅñ>µ¾®³¿é7¶Çì¸Ş&z¥<ÿ~ÚŸ×Ó—‡)‚ë;ê"]Yãë3Zvä¹!+ñÍGFºs¥è.|AÏ×ãÀùw†9ví®?
ş=:Ïíã\Ìgœ«¸lÇñw ûyÃ÷å|?ğÿ‚Ø\¿Oà÷¿êÓ³İ™¿Ç¦öîUH~A—QÍµÊÁDWj|’À/ÄóÊò¿–W~í§VuSï%„°„‘ï
¤7û-ŒÌ€ú1¸8‹±=x¼ı=ë3ú 3¶Í‰öÑŸÂüvÊˆ‹õ ·Š”\­ÿô'ÿLæóO@O	¤Şg3ûãÎ¦úßWãş·3DUQŒ~÷Ïúßãşüygícõ}áÄ	îg¡C' ÿ=ßë‰X?]8Z©ZxÂ>oÁ(G!q†€ë¥Ö×jµ¸¾÷5ÿ†öí@¸£èÒ¼\¯ÿ*¨'¯¸¸ú«=[ƒõ¾o¤;ï¯Ü¯íC{öw›VõŸæx¤‡”óaü 9i‡[¸¾ÿ° &ÛgX%äõIk;èO¬uŸ¬‹ÓëÍ5µ¾5™O$¹“j·—)/¸²óuY¦yùéî”=hîløDçøÀƒ{,ƒÏßí/=S½ï2æ£œ¡ê‰O/’q{Š¥0ş<WÑµ¤&Ö‡á¿ÜÌIzĞõû6õk8ŸŸİŞô+ªšÂğ÷s¦uÒ?éï#ıö€ıˆSÜ_Ñ¸9ê”Ş‰Åx=/ßßĞ'ãû{Ìøò÷CŠ`;©®ÑÈƒü'*”Zok€íT|¨ÄıK©ùyE;q¾ß;1ÏÍ_õƒã“ÃŞÍw†ßGº¡õ\óğïy)"³¬Å±0·oª2¬:ÛìÕú@ÒŞêàßûzb½İ«kıôî¹ /‹ÍçYşå´Æî''?U?à±d¾ %~;–ß¾ş(N!M7”¼ùì£ÍÜ»IRğ§iuqvwkÆ1ÆÏ­Lòvƒúx}v†2àùı‚ô§2Ã˜?@ı>…±¦æ×("¯»i}ÇÁxÀI"±÷Ó}ßÿŒíA{|¿âëÓİİvi@}<ZÕu]ÄYÈŸ›£÷xôØæÏşŞM¿^¿Ğ9¾?Ô“ûÒ–õ`I½‹BBp<)˜lWlğ‡úÛ·c]ŞÉUÁü¾ÂÙÎ"1èõÂ{*AµáC˜¿´=Jé™«É‡ø]|ÎãEÀxBNsWİ‚hlÿ}Ô¢vîV¤/&/£ÕÌ%ãyÏK•_±şå¿ŒcMÃ”Yg=#iÎlhU×¡RdàÇõğ•®½6gùPó ¾dPrõöx|àL‘ç#Î'½É;¨É)„ùìÍg2zg}ë÷ó¦ºõ|"âœ1=…È@€½¨Ü¡2ÖàõC½I.6º}ùé=UP°ËX˜ÿô]DÏtáI>¼ßÙ1J—`{.øÛ‚á½†·½z,ˆ²“Éğ‰RL¶K3¶×GïpÂq½íP¾»V«î§€ù¼Áü'N#}ÜhÄåÚ»…Áï/7'®uCVØ»Hã
=1X{¡ªÏ¿´=B æ‹Z/¦Ô·8]<\Î'¤íıI:_,³ü¯ä>s:7j/](pj-¨RD"#âûêÊ_£æ'Ç	Äé™%e/4g%;u°‹y]2\úƒ~®—¹ƒ!ŸØ·rèÁA_‡ù|io)¼53“`|;¾.¸›VkÿøåÄ¾Æ.x×XgÎwœüš±dÁp¯ÉbÃx˜Ÿ”?Ë³nA2ÌŸKêu›fñtĞ·"~û»ÇgÃüÁHE¼“ÛøÍĞÿ'^pÙÎxÑúıöNÊsC-2/Ø®ìv(YOüşqûøÛ!?ÂŞW[Y¸¸m~ĞàÄ'Òû‘á—ìí¶'Øõu,ÿ»°ú…¸-¶Àó¯üVÛFåŸô•‘îj«ÅZĞŒJ­ÍY2ÛÌ’b†}ÚGlĞÃ|Å[Ù¯DˆÀ¿Vïò	'
9¯ß]êé²Ç×çUšc)Ûd2ŒŸİ^çãœMÀxyñRçñãR5L¾6UıÄŠ2<y§†Ç
bìŒÆjÈ×›³¸ìT}×{pŒ’7µ÷+RÌµ
 ª‹ôîf ôú+­ùåqù¹s?T~j4Tg.«´œnV;“ëyÈhµNl¨Ø0ŒÏæç,ÿw°DIÅ¯Bü0Ì”±qXÅæ.4k~yê¹¢Õó¾?¼‡Œ¨©ùÂtkÈò—Pö¢¸ÄXÿYy÷ÃåSó™¯|-g_1¬ß»š¨”åäÜıÅ¤KHöÄÆùœ›¯/®÷wæŞÑÎBR¯Ÿğ‰ü~ãÇk¢¿[¤¼û¡g*_{œ³;ó«ºòîË_ÛkàG­“ùW]³ªO·Põ6'”ÃYÑRûÃäÇÁ_sWˆ_¤ûÏ2ËÿÎÜÛŸ†_;	út/cÃ°3›À~¤5ì8>ùÔI'š¿h{üÃä_ ş¼„_˜LóZË¯''ï8Kóğš__üÊì“cÊ™õ¬f™e–Yf™e–Yf™e–Yf™e–Yf™e–Yf™e–Yf™e–Yf™e–Yf™e–Yf™e–ÿ7ùÿ c²¹òÕz-xœc`€¦ÿ@À0ÒøŒ@ó@6kÍ —ÒAû)áxœ;Ø¬5ïçÿÿÿĞ€3+öËÏKñ„ÄA$Œ@|‚‰¨¡H0£ÁÀÀ×<åè¤n·-—­.•õ,:ÏÕ'Œ©+°=_ê¢M€f°0¢È­d° Š»i}÷ÄÜT}Ç¢’âøPO}ŸÒäìÊà‚Ì<}#s}÷œü¤Äı€Ô’x§(}¿üÄ’œÄb}Ïäü<} @|&o`ÄpÇ¨o¶È°àä¢Ì‚}çü¢ÔPÿ¤¬Ôä†ºvüHr®yé™Àpishõä
;U–¤å¤•T2<óÓ=ÀtÚRÌPR^1‘ÈC¶)uKÃ$P¸¤¦%–æ”ÄÇ‡¤V””¥¹0xe0N»{if
ƒsÀ¯ñ¹ùE%©)Á™U©±¼{C8A‚y%ù™y%u¥\ U>™é%™yé`­õ+¹‚Tùø»¸å—0|şŞ±Ÿ_˜òr 9‰ÉÙ‰é©Åî¢ #Üâ]CœâƒÜ,7¼
ù9¸¤¨4¹î=†9¸€Â7ÿûëp‘!±óÅñ½ A×ˆĞ W÷ ÿĞ `ä0,Ób}‹H(ı˜ş’ğ¢E52SÒÇeÿ‡¦á¿PäWF aÜ õŒS°$Ql –LÑ“2 Ù² •mµqâ‘[ï¢a¶lÉ’½xœí	XSWÚÇ	…¨!$‚­vÀ`Á]4V­ÚAÙÜqÔª­X$,"DDš¸‡EÂRDEAÙµ.XÔqGÁ¥*‚&@T Aîwn ç03ß,_g>[/ÏÓ‡ş<wInîÿ}ÿï{Î,ĞñcÜù›Õù»ø{?zÿuï²#·ó·áßÛ/7ı“±SæİrŒ«ô:äğÌ@Ú£óß™]ÎÌÓîĞ³ó7[çäzšÀédG}=ôŠÈ_Fğ¿ÙöK§şyÊ¨¥.¶“ñW1š¤¯ûê‚CÔ*5‘(¦™fš	Q777—RãÁšq›åõÑL3Í´şi¦™fZÿ4ÓL3­ši¦™Ö?Í4ÓLëŸfši¦õO3Í4Óú§™fšiıÓL3Í´şi¦™fZÿ4ÓL3­ši¦™Ö?Í4Ìü±é¾_5Í4ÿŞØşè€XÇçfwò¦7Âù•ŞA/Dêê&©¤ŒåÚà°Æfî[q][»Q­ÔDtR%ú>‚g~YÕëÉ|óÂÏÄoŞŒp<«"2ë@$zêÔ642àó/LÆ·VBlC3Ís½HıŞ˜UÛĞÂ ÿ}Zx±Úûİ%E3Ñ]*•HÂÎúå¬²™ªj+Š<³·%`eĞ„åùwëßO•§õïuy®Ù{şøÖO­k—+^Çïu5âFÍıA™Zn‚¼À{À-‡Ÿ~ø°Ûì˜£„;×¼›W×-³Ál¥ÃšÄÖ6–€…Ú×Æ›ß*“××Î šişoò¶á§/¼Ş‰ëÛŞ%"§ïhp[9f[şºWƒøÒ‘®s]¸³J8UåÀãåZ}n+¸ÃòQzZ|¢é\AÆ­7ˆš~*Ì{7ZËó9êv‰Type);
  }
} exports.parsePostMemberNameModifiers = parsePostMemberNameModifiers;

 function parseClassProperty() {
  if (_base.isTypeScriptEnabled) {
    _tokenizer.eatTypeToken.call(void 0, _types.TokenType.bang);
    _typescript.tsTryParseTypeAnnotation.call(void 0, );
  } else if (_base.isFlowEnabled) {
    if (_tokenizer.match.call(void 0, _types.TokenType.colon)) {
      _flow.flowParseTypeAnnotation.call(void 0, );
    }
  }

  if (_tokenizer.match.call(void 0, _types.TokenType.eq)) {
    const equalsTokenIndex = _base.state.tokens.length;
    _tokenizer.next.call(void 0, );
    _expression.parseMaybeAssign.call(void 0, );
    _base.state.tokens[equalsTokenIndex].rhsEndIndex = _base.state.tokens.length;
  }
  _util.semicolon.call(void 0, );
} exports.parseClassProperty = parseClassProperty;

function parseClassId(isStatement, optionalId = false) {
  if (
    _base.isTypeScriptEnabled &&
    (!isStatement || optionalId) &&
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._implements)
  ) {
    return;
  }

  if (_tokenizer.match.call(void 0, _types.TokenType.name)) {
    _lval.parseBindingIdentifier.call(void 0, true);
  }

  if (_base.isTypeScriptEnabled) {
    _typescript.tsTryParseTypeParameters.call(void 0, );
  } else if (_base.isFlowEnabled) {
    if (_tokenizer.match.call(void 0, _types.TokenType.lessThan)) {
      _flow.flowParseTypeParameterDeclaration.call(void 0, );
    }
  }
}

// Returns true if there was a superclass.
function parseClassSuper() {
  let hasSuper = false;
  if (_tokenizer.eat.call(void 0, _types.TokenType._extends)) {
    _expression.parseExprSubscripts.call(void 0, );
    hasSuper = true;
  } else {
    hasSuper = false;
  }
  if (_base.isTypeScriptEnabled) {
    _typescript.tsAfterParseClassSuper.call(void 0, hasSuper);
  } else if (_base.isFlowEnabled) {
    _flow.flowAfterParseClassSuper.call(void 0, hasSuper);
  }
}

// Parses module export declaration.

 function parseExport() {
  const exportIndex = _base.state.tokens.length - 1;
  if (_base.isTypeScriptEnabled) {
    if (_typescript.tsTryParseExport.call(void 0, )) {
      return;
    }
  }
  // export * from '...'
  if (shouldParseExportStar()) {
    parseExportStar();
  } else if (isExportDefaultSpecifier()) {
    // export default from
    _expression.parseIdentifier.call(void 0, );
    if (_tokenizer.match.call(void 0, _types.TokenType.comma) && _tokenizer.lookaheadType.call(void 0, ) === _types.TokenType.star) {
      _util.expect.call(void 0, _types.TokenType.comma);
      _util.expect.call(void 0, _types.TokenType.star);
      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._as);
      _expression.parseIdentifier.call(void 0, );
    } else {
      parseExportSpecifiersMaybe();
    }
    parseExportFrom();
  } else if (_tokenizer.eat.call(void 0, _types.TokenType._default)) {
    // export default ...
    parseExportDefaultExpression();
  } else if (shouldParseExportDeclaration()) {
    parseExportDeclaration();
  } else {
    // export { x, y as z } [from '...']
    parseExportSpecifiers();
    parseExportFrom();
  }
  _base.state.tokens[exportIndex].rhsEndIndex = _base.state.tokens.length;
} exports.parseExport = parseExport;

function parseExportDefaultExpression() {
  if (_base.isTypeScriptEnabled) {
    if (_typescript.tsTryParseExportDefaultExpression.call(void 0, )) {
      return;
    }
  }
  if (_base.isFlowEnabled) {
    if (_flow.flowTryParseExportDefaultExpression.call(void 0, )) {
      return;
    }
  }
  const functionStart = _base.state.start;
  if (_tokenizer.eat.call(void 0, _types.TokenType._function)) {
    parseFunction(functionStart, true, true);
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._async) && _tokenizer.lookaheadType.call(void 0, ) === _types.TokenType._function) {
    // async function declaration
    _util.eatContextual.call(void 0, _keywords.ContextualKeyword._async);
    _tokenizer.eat.call(void 0, _types.TokenType._function);
    parseFunction(functionStart, true, true);
  } else if (_tokenizer.match.call(void 0, _types.TokenType._class)) {
    parseClass(true, true);
  } else if (_tokenizer.match.call(void 0, _types.TokenType.at)) {
    parseDecorators();
    parseClass(true, true);
  } else {
    _expression.parseMaybeAssign.call(void 0, );
    _util.semicolon.call(void 0, );
  }
}

function parseExportDeclaration() {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsParseExportDeclaration.call(void 0, );
  } else if (_base.isFlowEnabled) {
    _flow.flowParseExportDeclaration.call(void 0, );
  } else {
    parseStatement(true);
  }
}

function isExportDefaultSpecifier() {
  if (_base.isTypeScriptEnabled && _typescript.tsIsDeclarationStart.call(void 0, )) {
    return false;
  } else if (_base.isFlowEnabled && _flow.flowShouldDisallowExportDefaultSpecifier.call(void 0, )) {
    return false;
  }
  if (_tokenizer.match.call(void 0, _types.TokenType.name)) {
    return _base.state.contextualKeyword !== _keywords.ContextualKeyword._async;
  }

  if (!_tokenizer.match.call(void 0, _types.TokenType._default)) {
    return false;
  }

  const _next = _tokenizer.nextTokenStart.call(void 0, );
  const lookahead = _tokenizer.lookaheadTypeAndKeyword.call(void 0, );
  const hasFrom =
    lookahead.type === _types.TokenType.name && lookahead.contextualKeyword === _keywords.ContextualKeyword._from;
  if (lookahead.type === _types.TokenType.comma) {
    return true;
  }
  // lookahead again when `export default from` is seen
  if (hasFrom) {
    const nextAfterFrom = _base.input.charCodeAt(_tokenizer.nextTokenStartSince.call(void 0, _next + 4));
    return nextAfterFrom === _charcodes.charCodes.quotationMark || nextAfterFrom === _charcodes.charCodes.apostrophe;
  }
  return false;
}

function parseExportSpecifiersMaybe() {
  if (_tokenizer.eat.call(void 0, _types.TokenType.comma)) {
    parseExportSpecifiers();
  }
}

 function parseExportFrom() {
  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._from)) {
    _expression.parseExprAtom.call(void 0, );
    maybeParseImportAttributes();
  }
  _util.semicolon.call(void 0, );
} exports.parseExportFrom = parseExportFrom;

function shouldParseExportStar() {
  if (_base.isFlowEnabled) {
    return _flow.flowShouldParseExportStar.call(void 0, );
  } else {
    return _tokenizer.match.call(void 0, _types.TokenType.star);
  }
}

function parseExportStar() {
  if (_base.isFlowEnabled) {
    _flow.flowParseExportStar.call(void 0, );
  } else {
    baseParseExportStar();
  }
}

 function baseParseExportStar() {
  _util.expect.call(void 0, _types.TokenType.star);

  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._as)) {
    parseExportNamespace();
  } else {
    parseExportFrom();
  }
} exports.baseParseExportStar = baseParseExportStar;

function parseExportNamespace() {
  _tokenizer.next.call(void 0, );
  _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._as;
  _expression.parseIdentifier.call(void 0, );
  parseExportSpecifiersMaybe();
  parseExportFrom();
}

function shouldParseExportDeclaration() {
  return (
    (_base.isTypeScriptEnabled && _typescript.tsIsDeclarationStart.call(void 0, )) ||
    (_base.isFlowEnabled && _flow.flowShouldParseExportDeclaration.call(void 0, )) ||
    _base.state.type === _types.TokenType._var ||
    _base.state.type === _types.TokenType._const ||
    _base.state.type === _types.TokenType._let ||
    _base.state.type === _types.TokenType._function ||
    _base.state.type === _types.TokenType._class ||
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._async) ||
    _tokenizer.match.call(void 0, _types.TokenType.at)
  );
}

// Parses a comma-separated list of module exports.
 function parseExportSpecifiers() {
  let first = true;

  // export { x, y as z } [from '...']
  _util.expect.call(void 0, _types.TokenType.braceL);

  while (!_tokenizer.eat.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      _util.expect.call(void 0, _types.TokenType.comma);
      if (_tokenizer.eat.call(void 0, _types.TokenType.braceR)) {
        break;
      }
    }
    parseExportSpecifier();
  }
} exports.parseExportSpecifiers = parseExportSpecifiers;

function parseExportSpecifier() {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsParseExportSpecifier.call(void 0, );
    return;
  }
  _expression.parseIdentifier.call(void 0, );
  _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _tokenizer.IdentifierRole.ExportAccess;
  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._as)) {
    _expression.parseIdentifier.call(void 0, );
  }
}

/**
 * Starting at the `module` token in an import, determine if it was truly an
 * import reflection token or just looks like one.
 *
 * Returns true for:
 * import module foo from "foo";
 * import module from from "foo";
 *
 * Returns false for:
 * import module from "foo";
 * import module, {bar} from "foo";
 */
function isImportReflection() {
  const snapshot = _base.state.snapshot();
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._module);
  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._from)) {
    if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._from)) {
      _base.state.restoreFromSnapshot(snapshot);
      return true;
    } else {
      _base.state.restoreFromSnapshot(snapshot);
      return false;
    }
  } else if (_tokenizer.match.call(void 0, _types.TokenType.comma)) {
    _base.state.restoreFromSnapshot(snapshot);
    return false;
  } else {
    _base.state.restoreFromSnapshot(snapshot);
    return true;
  }
}

/**
 * Eat the "module" token from the import reflection proposal.
 * https://github.com/tc39/proposal-import-reflection
 */
function parseMaybeImportReflection() {
  // isImportReflection does snapshot/restore, so only run it if we see the word
  // "module".
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._module) && isImportReflection()) {
    _tokenizer.next.call(void 0, );
  }
}

// Parses import declaration.

 function parseImport() {
  if (_base.isTypeScriptEnabled && _tokenizer.match.call(void 0, _types.TokenType.name) && _tokenizer.lookaheadType.call(void 0, ) === _types.TokenType.eq) {
    _typescript.tsParseImportEqualsDeclaration.call(void 0, );
    return;
  }
  if (_base.isTypeScriptEnabled && _util.isContextual.call(void 0, _keywords.ContextualKeyword._type)) {
    const lookahead = _tokenizer.lookaheadTypeAndKeyword.call(void 0, );
    if (lookahead.type === _types.TokenType.name && lookahead.contextualKeyword !== _keywords.ContextualKeyword._from) {
      // One of these `import type` cases:
      // import type T = require('T');
      // import type A from 'A';
      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._type);
      if (_tokenizer.lookaheadType.call(void 0, ) === _types.TokenType.eq) {
        _typescript.tsParseImportEqualsDeclaration.call(void 0, );
        return;
      }
      // If this is an `import type...from` statement, then we already ate the
      // type token, so proceed to the regular import parser.
    } else if (lookahead.type === _types.TokenType.star || lookahead.type === _types.TokenType.braceL) {
      // One of these `import type` cases, in which case we can eat the type token
      // and proceed as normal:
      // import type * as A from 'A';
      // import type {a} from 'A';
      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._type);
    }
    // Otherwise, we are importing the name "type".
  }

  // import '...'
  if (_tokenizer.match.call(void 0, _types.TokenType.string)) {
    _expression.parseExprAtom.call(void 0, );
  } else {
    parseMaybeImportReflection();
    parseImportSpecifiers();
    _util.expectContextual.call(void 0, _keywords.ContextualKeyword._from);
    _expression.parseExprAtom.call(void 0, );
  }
  maybeParseImportAttributes();
  _util.semicolon.call(void 0, );
} exports.parseImport = parseImport;

// eslint-disable-next-line no-unused-vars
function shouldParseDefaultImport() {
  return _tokenizer.match.call(void 0, _types.TokenType.name);
}

function parseImportSpecifierLocal() {
  _lval.parseImportedIdentifier.call(void 0, );
}

// Parses a comma-separated list of module imports.
function parseImportSpecifiers() {
  if (_base.isFlowEnabled) {
    _flow.flowStartParseImportSpecifiers.call(void 0, );
  }

  let first = true;
  if (shouldParseDefaultImport()) {
    // import defaultObj, { x, y as z } from '...'
    parseImportSpecifierLocal();

    if (!_tokenizer.eat.call(void 0, _types.TokenType.comma)) return;
  }

  if (_tokenizer.match.call(void 0, _types.TokenType.star)) {
    _tokenizer.next.call(void 0, );
    _util.expectContextual.call(void 0, _keywords.ContextualKeyword._as);

    parseImportSpecifierLocal();

    return;
  }

  _util.expect.call(void 0, _types.TokenType.braceL);
  while (!_tokenizer.eat.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      // Detect an attempt to deep destructure
      if (_tokenizer.eat.call(void 0, _types.TokenType.colon)) {
        _util.unexpected.call(void 0, 
          "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
        );
      }

      _util.expect.call(void 0, _types.TokenType.comma);
      if (_tokenizer.eat.call(void 0, _types.TokenType.braceR)) {
        break;
      }
    }

    parseImportSpecifier();
  }
}

function parseImportSpecifier() {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsParseImportSpecifier.call(void 0, );
    return;
  }
  if (_base.isFlowEnabled) {
    _flow.flowParseImportSpecifier.call(void 0, );
    return;
  }
  _lval.parseImportedIdentifier.call(void 0, );
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._as)) {
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _tokenizer.IdentifierRole.ImportAccess;
    _tokenizer.next.call(void 0, );
    _lval.parseImportedIdentifier.call(void 0, );
  }
}

/**
 * Parse import attributes like `with {type: "json"}`, or the legacy form
 * `assert {type: "json"}`.
 *
 * Import attributes technically have their own syntax, but are always parseable
 * as a plain JS object, so just do that for simplicity.
 */
function maybeParseImportAttributes() {
  if (_tokenizer.match.call(void 0, _types.TokenType._with) || (_util.isContextual.call(void 0, _keywords.ContextualKeyword._assert) && !_util.hasPrecedingLineBreak.call(void 0, ))) {
    _tokenizer.next.call(void 0, );
    _expression.parseObj.call(void 0, false, false);
  }
}
